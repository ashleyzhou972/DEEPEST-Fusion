{
  "class": "Workflow",
  "steps": [
    {
      "id": "#SBG_Prepare_Scatter_Trim",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python prepare_scatter.py",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/sbg-prepare-scatter-trim/1",
        "arguments": [],
        "x": 919.9412506245427,
        "id": "milos_jordanski/spachete-salzman-collaboration/sbg-prepare-scatter-trim/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520432783,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "prepare_scatter.py",
                "fileContent": "\"\"\"\nUsage:\n    group_by_metadata.py\n\nDescription:\n    Prepare Input Files manipulates / creates an output list as group of files with the same metadata.\n\nOptions:\n\n    -h, --help            Show this message.\n\n    -v, -V, --version     Tool version.\n\"\"\"\n\nimport json\n\njob = \"\"\nwith open('job.json') as data_file:\n    job = json.load(data_file)\n\nif \"inputs\" in job and \"input_files\" in job[\"inputs\"]:\n    input_files = job[\"inputs\"][\"input_files\"]\nelse:\n    input_files = []\n\nfiles_1 = []\nfiles_2 = []\n\nfor file_list in input_files:\n    if file_list and not isinstance(file_list, list):\n        f=file_list\n        d = {'class': 'File'}\n        d['path'] = f[\"path\"]\n        print f\n        if \"size\" in f:\n            d['size'] = f[\"size\"]\n\n        if \"contents\" in f:\n            d['contents'] = f[\"contents\"]\n\n        if \"name\" in f:\n            d['name'] = f[\"name\"]\n\n        if \"checksum\" in f:\n            d['checksum'] = f[\"checksum\"]\n\n        if \"location\" in f:\n            d['location'] = f[\"location\"]\n\n        if \"metadata\" in f:\n            d['metadata'] = f[\"metadata\"]\n\n        if \"secondaryFiles\" in f:\n            d['secondaryFiles'] = f[\"secondaryFiles\"]\n\n        if \"metadata\" in f and \"paired_end\" in f[\"metadata\"] and f[\"metadata\"][\"paired_end\"] == \"1\":\n            files_1.append(d)\n        else:\n            files_2.append(d)\n\n    elif file_list:\n        for f in file_list:\n            print(f)\n            d = {'class': 'File'}\n            d['path'] = f[\"path\"]\n\n            if \"size\" in f:\n                d['size'] = f[\"size\"]\n\n            if \"contents\" in f:\n                d['contents'] = f[\"contents\"]\n\n            if \"name\" in f:\n                d['name'] = f[\"name\"]\n\n            if \"checksum\" in f:\n                d['checksum'] = f[\"checksum\"]\n\n            if \"location\" in f:\n                d['location'] = f[\"location\"]\n\n            if \"metadata\" in f:\n                d['metadata'] = f[\"metadata\"]\n\n            if \"secondaryFiles\" in f:\n                d['secondaryFiles'] = f[\"secondaryFiles\"]\n\n            if \"metadata\" in f and \"paired_end\" in f[\"metadata\"] and f[\"metadata\"][\"paired_end\"] == \"1\":\n                files_1.append(d)\n            else:\n                files_2.append(d)\n\ndata = {}\nif files_1:\n    data['output_files_1'] = files_1\n\nif files_2:\n    data['output_files_2'] = files_2\n\nwith open('cwl.output.json', 'w') as w:\n    json.dump(data, w)"
              }
            ]
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "input_files": [
              {
                "path": "/path/to/input_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/input_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520432762,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520432783,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 3 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#output_files_2"
          },
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#output_files_1"
          }
        ],
        "label": "SBG Prepare Scatter Trim",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 3 copied",
        "y": -97.92555469911298,
        "inputs": [
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#input_files",
            "required": false,
            "sbg:stageInput": null
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "prepare_scatter.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520432762
      },
      "inputs": [
        {
          "id": "#SBG_Prepare_Scatter_Trim.input_files",
          "source": [
            "#Trim_Galore_Skip_New.merged",
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.result_sam_file",
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.result_sam_file",
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.result_sam_file",
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SBG_Prepare_Scatter_Trim.output_files_2"
        },
        {
          "id": "#SBG_Prepare_Scatter_Trim.output_files_1"
        }
      ],
      "sbg:x": 919.9412506245427,
      "sbg:y": -97.92555469911298
    },
    {
      "id": "#getUnalignedReads_1",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python getUnalignedReadCount.py   -ribs /path/to/input_files-ribosomal.ext -gens /path/to/input_files-genome.ext -regs /path/to/input_files-regular.ext -scrs /path/to/input_files-scrambled.ext -r /path/to/input_files.ext   -ribsm /path/to/mate_input_files-ribosomal.ext -gensm /path/to/mate_input_files-genome.ext -regsm /path/to/mate_input_files-regular.ext -scrsm /path/to/mate_input_files-scrambled.ext  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/getunalignedreads/1",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n\tinput_files = [].concat($job.inputs.input_files)\n    for(i = 0; i < input_files.length; i++)\n    {\n    \tif(input_files[i].path.indexOf(\"regular\") !== -1)\n        {\n          cmd += \" -regs \" + input_files[i].path\n          continue\n        }\n        if(input_files[i].path.indexOf(\"scrambled\") !== -1)\n        {\n          cmd += \" -scrs \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"genome\") !== -1)\n        {\n          cmd += \" -gens \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"ribosomal\") !== -1)\n        {\n          cmd += \" -ribs \" + input_files[i].path\n          continue\n        }\n      \telse\n        {\n        \tcmd += \" -r \" + input_files[i].path\n        }\n      \n    }\n  \treturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    for(i = 0; i < input_files.length; i++)\n    {\n    \tif(input_files[i].path.indexOf(\"regular\") !== -1)\n        {\n          cmd += \" -regsm \" + input_files[i].path\n          continue\n        }\n        if(input_files[i].path.indexOf(\"scrambled\") !== -1)\n        {\n          cmd += \" -scrsm \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"genome\") !== -1)\n        {\n          cmd += \" -gensm \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"ribosomal\") !== -1)\n        {\n          cmd += \" -ribsm \" + input_files[i].path\n          continue\n        }\n      \n    }\n  \treturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.input_files)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 1596,
        "sbg:categories": [
          "RNA"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/getunalignedreads/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520432864,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "getUnalignedReadCount.py",
                "fileContent": "# Creates a fasta and fastq file containing all reads for the sample that did not align to any of\n# the Bowtie2 indices in the directory \"orig/unaligned\". It also creates a fastq file under\n# \"orig/unaligned/forDenovoIndex\" that contains the subset of unaligned reads that are long\n# enough to be used for the de novo index (NTRIM + 8). This forDenovoIndex file had to be\n# created because Bowtie does not gracefully handle when a read gets trimmed to a negative length.\n#\n# This script is called by qualityStatsSingleSample.sh when the sampleStats reports are being generated,\n# so it returns the number of unaligned reads to be reported. This is the total number of unaligned reads,\n# not just those that were long enough to be used for the de novo index.\n\nimport argparse\nimport subprocess\nfrom ParseFastQ import ParseFastQ\nimport multiprocessing\nimport Queue\n\n\ndef addAlignedIds(samFile):\n    handle = open(samFile, \"rU\")\n\n    for line in handle:\n        if not line.startswith(\"@\"):  # ignore header lines\n            if args.fastqIdStyle == \"appended\":\n                aligned[line.strip().split()[0][:-1]] = None\n            else:\n                aligned[line.strip().split()[0]] = None\n\n    handle.close()\n\ndef RemoveIds(samFile, tmpSamFile):\n    handle = open(samFile, \"rU\")\n    output = open(tmpSamFile, \"w\")\n\n    for line in handle:\n        if line.startswith(\"@\"):\n            output.write(line)\n        elif args.fastqIdStyle == \"appended\" and line.strip().split()[0][:-1] not in aligned:\n            output.write(line)\n        elif args.fastqIdStyle == \"complete\" and line.strip().split()[0] not in aligned:\n            output.write(line)\n\n    handle.close()\n    output.close()\n\n    cmd = \"mv -f \" + tmpSamFile + \" \" + samFile\n    print(cmd)\n    subprocess.call(cmd, shell=True)\n\n\nif __name__ == \"__main__\":\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-r', '--readFile', help='path to fastq file containing reads you attempted to align',required=True)\n    #parser.add_argument('-r2', '--readFile2', help='path to fastq file 2 containing reads you attempted to align',required=True)\n\n    parser.add_argument('-s', '--sample', help='base name used in alignment output files', required=True)\n    parser.add_argument('-n', '--suffix', help='base name used in alignment output files', required=True)\n    parser.add_argument('-t', '--ntrim', help='ntrim used in denovo pipeline', type=int, required=True)\n\n    parser.add_argument('-v', '--verbose', help='print info about data obtained', action='store_true')\n\n    parser.add_argument('-q', '--fastqIdStyle', help='type of read ids used', required=True, choices=['appended', 'complete'])\n\n    parser.add_argument('-gens', '--genomeSAM', help = 'path to the genome SAM file', required=True)\n    parser.add_argument('-ribs', '--ribosomalSAM', help='path to the ribosomal SAM file', required=True)\n    parser.add_argument('-regs', '--regularSAM', help='path to the regular junction SAM file', required=True)\n    parser.add_argument('-scrs', '--scrambledSAM', help='path to the scrambled junction SAM file', required=True)\n\n    parser.add_argument('-gensm', '--genomeSAMMate', help = 'path to the genome mate SAM file', required=True)\n    parser.add_argument('-ribsm', '--ribosomalSAMMate', help='path to the ribosomal mate SAM file', required=True)\n    parser.add_argument('-regsm', '--regularSAMMate', help='path to the regular junction mate SAM file', required=True)\n    parser.add_argument('-scrsm', '--scrambledSAMMate', help='path to the scrambled junction mate SAM file', required=True)\n\n    args = parser.parse_args()\n\n    aligned = {}\n    unaligned = {}\n\n    #aligned2 = {}\n    #unaligned2 = {}\n\n    minReadLen = args.ntrim + 8  # we want to have at least 8 nt left after read is trimmed for denovo split reads\n\n    try:\n        # put each id from sam files in a dict\n\n\n        addAlignedIds(args.genomeSAM)\n        addAlignedIds(args.ribosomalSAM)\n        addAlignedIds(args.regularSAM)\n        addAlignedIds(args.scrambledSAM)\n\n        # get each id from fastq file, add it to a dict if not in the aligned dict\n        parser = ParseFastQ(args.readFile)\n        for (seqHeader, seqStr, qualHeader, qualStr) in parser:\n            if args.fastqIdStyle == \"appended\":\n                title = seqHeader.split()[0][1:-1]\n            else:\n                title = seqHeader.split()[0][1:]\n\n            if title not in aligned:\n                unaligned[seqHeader.split()[0][1:]] = (seqHeader, seqStr, qualHeader, qualStr)\n\n        # write list of unaligned ids to fasta and fastq files\n        out_handle = open(\"unaligned_\" + args.sample + \".\" + args.suffix + \".fasta\", \"wb\")\n        out_fq_handle = open(\"unaligned_\" + args.sample + \".\" + args.suffix + \".fq\", \"wb\")\n        out_denovo_handle = open(\"forDenovoIndex_unaligned_\" + args.suffix + \".fq\", \"wb\")\n        for id in unaligned.keys():\n            # fasta file\n            out_handle.write(\">\" + id + \"\\n\")\n            out_handle.write(unaligned[id][1] + \"\\n\")\n            # fastq file\n            out_fq_handle.write(\"%s\\n%s\\n%s\\n%s\\n\" % (unaligned[id][0], unaligned[id][1], unaligned[id][2], unaligned[id][3]))\n            # fastq file for denovo index\n            if len(unaligned[id][1]) >= minReadLen:\n                out_denovo_handle.write(\"%s\\n%s\\n%s\\n%s\\n\" % (unaligned[id][0], unaligned[id][1], unaligned[id][2], unaligned[id][3]))\n\n        out_handle.close()\n        out_fq_handle.close()\n        out_denovo_handle.close()\n\n        # return size of unaligned dict\n        print len(unaligned)\n    except Exception as e:\n        print \"Exception:\", e\n\n    procs = []\n    try:\n        p_genome_mate = multiprocessing.Process(target=RemoveIds, args=(args.genomeSAMMate, \"tmp_genome.sam\"))\n        procs.append(p_genome_mate)\n        p_genome_mate.start()\n        #p_genome_mate.join()\n\n        p_ribosomal_mate = multiprocessing.Process(target=RemoveIds, args=(args.ribosomalSAMMate, \"tmp_ribosomal.sam\"))\n        procs.append(p_ribosomal_mate)\n        p_ribosomal_mate.start()\n        #p_ribosomal_mate.join()\n\n        p_regular_mate = multiprocessing.Process(target=RemoveIds, args=(args.regularSAMMate, \"tmp_regular.sam\"))\n        procs.append(p_regular_mate)\n        p_regular_mate.start()\n        #p_regular_mate.join()\n\n        p_scambled_mate = multiprocessing.Process(target=RemoveIds, args=(args.scrambledSAMMate, \"tmp_scrambled.sam\"))\n        procs.append(p_scambled_mate)\n        p_scambled_mate.start()\n        #p_scambled_mate.join()\n\n        for p in procs:\n            p.join()\n\n        #RemoveIds(args.genomeSAMMate, \"tmp_genome.sam\")\n        #RemoveIds(args.ribosomalSAMMate, \"tmp_ribosomal.sam\")\n        #RemoveIds(args.regularSAMMate, \"tmp_regular.sam\")\n        #RemoveIds(args.scrambledSAMMate, \"tmp_scrambled.sam\")\n    except Exception as e:\n        print \"Exception:\", e"
              },
              {
                "filename": "ParseFastQ.py",
                "fileContent": "import gzip\n\n\nclass ParseFastQ(object):\n    \"\"\"Returns a read-by-read fastQ parser analogous to file.readline()\"\"\"\n\n    def __init__(self, filePath, headerSymbols=['@', '+']):\n        \"\"\"Returns a read-by-read fastQ parser analogous to file.readline().\n        Exmpl: parser.next()\n        -OR-\n        Its an iterator so you can do:\n        for rec in parser:\n            ... do something with rec ...\n\n        rec is tuple: (seqHeader,seqStr,qualHeader,qualStr)\n        \"\"\"\n        if filePath.endswith('.gz'):\n            self._file = gzip.open(filePath)\n        else:\n            self._file = open(filePath, 'rU')\n        self._currentLineNumber = 0\n        self._hdSyms = headerSymbols\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        \"\"\"Reads in next element, parses, and does minimal verification.\n        Returns: tuple: (seqHeader,seqStr,qualHeader,qualStr)\"\"\"\n        # ++++ Get Next Four Lines ++++\n        elemList = []\n        for i in range(4):\n            line = self._file.readline()\n            self._currentLineNumber += 1  ## increment file position\n            if line:\n                elemList.append(line.strip('\\n'))\n            else:\n                elemList.append(None)\n\n        # ++++ Check Lines For Expected Form ++++\n        trues = [bool(x) for x in elemList].count(True)\n        nones = elemList.count(None)\n        # -- Check for acceptable end of file --\n        if nones == 4:\n            raise StopIteration\n        # -- Make sure we got 4 full lines of data --\n        assert trues == 4, \\\n            \"** ERROR: It looks like I encountered a premature EOF or empty line.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._currentLineNumber)\n        # -- Make sure we are in the correct \"register\" --\n        assert elemList[0].startswith(self._hdSyms[0]), \\\n            \"** ERROR: The 1st line in fastq element does not start with '%s'.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._hdSyms[0], self._currentLineNumber)\n        assert elemList[2].startswith(self._hdSyms[1]), \\\n            \"** ERROR: The 3rd line in fastq element does not start with '%s'.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._hdSyms[1], self._currentLineNumber)\n        # -- Make sure the seq line and qual line have equal lengths --\n        assert len(elemList[1]) == len(elemList[3]), \"** ERROR: The length of Sequence data and Quality data of the last record aren't equal.\\n\\\n               Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n        self._currentLineNumber)\n\n        # ++++ Return fatsQ data as tuple ++++\n        return tuple(elemList)"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 3000
          },
          "inputs": {
            "mode": "appended",
            "ntrim": 2,
            "mate_input_files": [
              {
                "path": "/path/to/mate_input_files-ribosomal.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "path": "/path/to/mate_input_files-genome.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "path": "/path/to/mate_input_files-regular.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "path": "/path/to/mate_input_files-scrambled.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "path": "/path/to/mate_input_files.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "case_id": "1"
                }
              }
            ],
            "input_files": [
              {
                "path": "/path/to/input_files-ribosomal.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "case_id": "1"
                }
              },
              {
                "path": "/path/to/input_files-genome.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/input_files-regular.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/input_files-scrambled.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/input_files.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "suffix": "output_name-string-value"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520432843,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520432864,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 3 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "sbg:links": [
          {
            "label": "Publication",
            "id": "https://academic.oup.com/nar/article-lookup/doi/10.1093/nar/gkx453"
          }
        ],
        "label": "getUnalignedReads_1",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 3 copied",
        "y": 266.015625,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-n"
            },
            "id": "#suffix",
            "type": [
              "null",
              "string"
            ]
          },
          {
            "label": "Ntrim",
            "description": "Ntrim used in denovo pipeline.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-t"
            },
            "id": "#ntrim",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Mode",
            "sbg:includeInPorts": true,
            "required": false,
            "description": "\"Appended\" mode should be selected if read_ids in first mate ends with 1 and in the second. If reads have the same read_id in both paired_end files, \"complete\" should be selected.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-q"
            },
            "id": "#mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "appended",
                  "complete"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Mate input files",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM, FASTQ",
            "description": "Mate fastq file and mate genome, ribosomal, regular and scrambled sam files.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#mate_input_files",
            "sbg:stageInput": "link",
            "required": false
          },
          {
            "label": "Input files",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM, FASTQ",
            "description": "Fastq file, genome, ribosomal, regular and scrambled sam files.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#input_files",
            "required": false
          }
        ],
        "description": "Tool getUnalignedReads takes as input fastq file, ribosomal, genome, regular and scrambled junctions sam files of one read and ribosomal, genome, regular and scrambled junctions sam files for its mates and outputs the following files:\n\n1. unaligned\\_fastq file: all reads that are not aligned neither to ribosomal, genome, regular nor scrambled junctions.\n2. unaligned\\_fasta file: same as unaligned_fastq file, but in fasta format without qualities.\n3. mate\\_genome\\_sam: sam file contains only lines from mate genome sam file for which read_id is in unaligned\\_fastq\\_file.\n4. mate\\_ribosomal\\_sam: sam file contains only lines from mate ribosomal sam file for which read_id is in unaligned\\_fastq\\_file.\n5. mate\\_regular\\_sam: sam file contains only lines from mate regular sam file for which read_id is in unaligned\\_fastq\\_file.\n6. mate\\_scrambled\\_sam: sam file contains only lines from mate scrambled sam file for which read_id is in unaligned\\_fastq\\_file.",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "outputs": [
          {
            "outputBinding": {
              "glob": "unaligned_*.fq",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#unaligned_fastq"
          },
          {
            "outputBinding": {
              "glob": "unaligned_*fasta",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#unaligned_fasta"
          },
          {
            "outputBinding": {
              "glob": "*scrambled.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_scrambled_sam"
          },
          {
            "outputBinding": {
              "glob": "*ribosomal.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_ribosomal_sam"
          },
          {
            "outputBinding": {
              "glob": "*regular_sorted.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_regular_sam"
          },
          {
            "outputBinding": {
              "glob": "*genome_sorted.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_genome_sam"
          },
          {
            "outputBinding": {
              "glob": "forDenovoIndex_unaligned*.fq",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "label": "ForDenovoIndex unaligned reads",
            "type": [
              "null",
              "File"
            ],
            "id": "#denovo_unaligned",
            "sbg:fileTypes": "FQ, FASTQ"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "getUnalignedReadCount.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 3000
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "c4.8xlarge;ebs-gp2;1024"
          }
        ],
        "sbg:createdOn": 1520432843
      },
      "inputs": [
        {
          "id": "#getUnalignedReads_1.suffix",
          "default": "_1"
        },
        {
          "id": "#getUnalignedReads_1.ntrim",
          "default": 50
        },
        {
          "id": "#getUnalignedReads_1.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#getUnalignedReads_1.mate_input_files",
          "source": [
            "#SBG_Prepare_Scatter_Trim.output_files_2"
          ]
        },
        {
          "id": "#getUnalignedReads_1.input_files",
          "source": [
            "#SBG_Prepare_Scatter_Trim.output_files_1"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#getUnalignedReads_1.unaligned_fastq"
        },
        {
          "id": "#getUnalignedReads_1.unaligned_fasta"
        },
        {
          "id": "#getUnalignedReads_1.mate_scrambled_sam"
        },
        {
          "id": "#getUnalignedReads_1.mate_ribosomal_sam"
        },
        {
          "id": "#getUnalignedReads_1.mate_regular_sam"
        },
        {
          "id": "#getUnalignedReads_1.mate_genome_sam"
        },
        {
          "id": "#getUnalignedReads_1.denovo_unaligned"
        }
      ],
      "sbg:x": 1596,
      "sbg:y": 266.015625
    },
    {
      "id": "#Knife_Preprocess_Aligned_Reads",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "awk '$1 !~ /^@/ && $2 != 4 {print $1  \"\\t\" $2 \"\\t\" $3 \"\\t\" $4}' /path/to/input_sam.sam > output_name-string-value.txt",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \toutput_file_name = $job.inputs.input_sam.path.split(\"/\").pop()\n    output_file_name = output_file_name.slice(0, output_file_name.length - 4)\n  \tif ($job.inputs.output_name)\n    {\n    \toutput_file_name = $job.inputs.output_name\n    }\n\tif($job.inputs.aligned_reference == \"genome\" || $job.inputs.aligned_reference == \"ribosomal\")\n    {\n      \treturn \"awk '$1 !~ /^@/ && $2 != 4 {print $1  \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3 \\\"\\\\t\\\" $4}' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n  \telse if($job.inputs.aligned_reference == \"regular\" || $job.inputs.aligned_reference == \"scrambled\")\n    {\n    \treturn \"awk \\'$1 !~ /^@/ && $4 >= \" + $job.inputs.junction_midpoint + \" -length($10)+ \" + $job.inputs.overlap + \" +1 && $4 <= \" + $job.inputs.junction_midpoint + \"- \" + $job.inputs.overlap + \" +1 {print $1 \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3}\\' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 786,
        "id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520442544,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "junction_midpoint": 3,
            "output_name": "output_name-string-value",
            "overlap": 5,
            "input_sam": {
              "path": "/path/to/input_sam.sam",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "aligned_reference": "ribosomal"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520442509,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520442544,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 4 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_sam",
              "glob": "*.txt"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#aligned_reads"
          }
        ],
        "label": "Knife Preprocess Aligned Reads",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 4 copied",
        "y": -34.984375,
        "inputs": [
          {
            "type": [
              "null",
              "int"
            ],
            "id": "#overlap",
            "required": false
          },
          {
            "type": [
              "null",
              "string"
            ],
            "id": "#output_name",
            "required": false
          },
          {
            "type": [
              "null",
              "int"
            ],
            "id": "#junction_midpoint",
            "required": false
          },
          {
            "type": [
              "File"
            ],
            "id": "#input_sam",
            "required": true
          },
          {
            "type": [
              {
                "type": "enum",
                "name": "aligned_reference",
                "symbols": [
                  "ribosomal",
                  "genome",
                  "regular",
                  "scrambled"
                ]
              }
            ],
            "id": "#aligned_reference",
            "required": true
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "successCodes": [],
        "stdout": "",
        "sbg:createdOn": 1520442509,
        "baseCommand": [
          ""
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "ubuntu"
          }
        ]
      },
      "inputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads.overlap"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads.output_name"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads.junction_midpoint"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads.input_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.result_sam_file"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads.aligned_reference",
          "default": "genome"
        }
      ],
      "outputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads.aligned_reads"
        }
      ],
      "sbg:x": 786,
      "sbg:y": -34.984375,
      "scatter": "#Knife_Preprocess_Aligned_Reads.input_sam"
    },
    {
      "id": "#Knife_Preprocess_Aligned_Reads_1",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "awk '$1 !~ /^@/ && $2 != 4 {print $1  \"\\t\" $2 \"\\t\" $3 \"\\t\" $4}' /path/to/input_sam.sam > output_name-string-value.txt",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \toutput_file_name = $job.inputs.input_sam.path.split(\"/\").pop()\n    output_file_name = output_file_name.slice(0, output_file_name.length - 4)\n  \tif ($job.inputs.output_name)\n    {\n    \toutput_file_name = $job.inputs.output_name\n    }\n\tif($job.inputs.aligned_reference == \"genome\" || $job.inputs.aligned_reference == \"ribosomal\")\n    {\n      \treturn \"awk '$1 !~ /^@/ && $2 != 4 {print $1  \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3 \\\"\\\\t\\\" $4}' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n  \telse if($job.inputs.aligned_reference == \"regular\" || $job.inputs.aligned_reference == \"scrambled\")\n    {\n    \treturn \"awk \\'$1 !~ /^@/ && $4 >= \" + $job.inputs.junction_midpoint + \" -length($10)+ \" + $job.inputs.overlap + \" +1 && $4 <= \" + $job.inputs.junction_midpoint + \"- \" + $job.inputs.overlap + \" +1 {print $1 \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3}\\' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 788,
        "id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520442544,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "junction_midpoint": 3,
            "output_name": "output_name-string-value",
            "overlap": 5,
            "input_sam": {
              "path": "/path/to/input_sam.sam",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "aligned_reference": "ribosomal"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520442509,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520442544,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 4 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_sam",
              "glob": "*.txt"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#aligned_reads"
          }
        ],
        "label": "Knife Preprocess Aligned Reads",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 4 copied",
        "y": 110.015625,
        "inputs": [
          {
            "type": [
              "null",
              "int"
            ],
            "id": "#overlap",
            "required": false
          },
          {
            "type": [
              "null",
              "string"
            ],
            "id": "#output_name",
            "required": false
          },
          {
            "type": [
              "null",
              "int"
            ],
            "id": "#junction_midpoint",
            "required": false
          },
          {
            "type": [
              "File"
            ],
            "id": "#input_sam",
            "required": true
          },
          {
            "type": [
              {
                "type": "enum",
                "name": "aligned_reference",
                "symbols": [
                  "ribosomal",
                  "genome",
                  "regular",
                  "scrambled"
                ]
              }
            ],
            "id": "#aligned_reference",
            "required": true
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "successCodes": [],
        "stdout": "",
        "sbg:createdOn": 1520442509,
        "baseCommand": [
          ""
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "ubuntu"
          }
        ]
      },
      "inputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.overlap"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.output_name"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.junction_midpoint"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.input_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.result_sam_file"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.aligned_reference",
          "default": "ribosomal"
        }
      ],
      "outputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_1.aligned_reads"
        }
      ],
      "sbg:x": 788,
      "sbg:y": 110.015625,
      "scatter": "#Knife_Preprocess_Aligned_Reads_1.input_sam"
    },
    {
      "id": "#Knife_Preprocess_Aligned_Reads_2",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "awk '$1 !~ /^@/ && $2 != 4 {print $1  \"\\t\" $2 \"\\t\" $3 \"\\t\" $4}' /path/to/input_sam.sam > output_name-string-value.txt",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \toutput_file_name = $job.inputs.input_sam.path.split(\"/\").pop()\n    output_file_name = output_file_name.slice(0, output_file_name.length - 4)\n  \tif ($job.inputs.output_name)\n    {\n    \toutput_file_name = $job.inputs.output_name\n    }\n\tif($job.inputs.aligned_reference == \"genome\" || $job.inputs.aligned_reference == \"ribosomal\")\n    {\n      \treturn \"awk '$1 !~ /^@/ && $2 != 4 {print $1  \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3 \\\"\\\\t\\\" $4}' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n  \telse if($job.inputs.aligned_reference == \"regular\" || $job.inputs.aligned_reference == \"scrambled\")\n    {\n    \treturn \"awk \\'$1 !~ /^@/ && $4 >= \" + $job.inputs.junction_midpoint + \" -length($10)+ \" + $job.inputs.overlap + \" +1 && $4 <= \" + $job.inputs.junction_midpoint + \"- \" + $job.inputs.overlap + \" +1 {print $1 \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3}\\' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 792,
        "id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520442544,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "junction_midpoint": 3,
            "output_name": "output_name-string-value",
            "overlap": 5,
            "input_sam": {
              "path": "/path/to/input_sam.sam",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "aligned_reference": "ribosomal"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520442509,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520442544,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 4 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_sam",
              "glob": "*.txt"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#aligned_reads"
          }
        ],
        "label": "Knife Preprocess Aligned Reads",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 4 copied",
        "y": 253.015625,
        "inputs": [
          {
            "sbg:includeInPorts": true,
            "id": "#overlap",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "type": [
              "null",
              "string"
            ],
            "id": "#output_name",
            "required": false
          },
          {
            "type": [
              "null",
              "int"
            ],
            "id": "#junction_midpoint",
            "required": false
          },
          {
            "type": [
              "File"
            ],
            "id": "#input_sam",
            "required": true
          },
          {
            "type": [
              {
                "type": "enum",
                "name": "aligned_reference",
                "symbols": [
                  "ribosomal",
                  "genome",
                  "regular",
                  "scrambled"
                ]
              }
            ],
            "id": "#aligned_reference",
            "required": true
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "successCodes": [],
        "stdout": "",
        "sbg:createdOn": 1520442509,
        "baseCommand": [
          ""
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "ubuntu"
          }
        ]
      },
      "inputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.output_name"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.junction_midpoint",
          "default": 150
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.input_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.result_sam_file"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.aligned_reference",
          "default": "regular"
        }
      ],
      "outputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_2.aligned_reads"
        }
      ],
      "sbg:x": 792,
      "sbg:y": 253.015625,
      "scatter": "#Knife_Preprocess_Aligned_Reads_2.input_sam"
    },
    {
      "id": "#Knife_Preprocess_Aligned_Reads_3",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "awk '$1 !~ /^@/ && $2 != 4 {print $1  \"\\t\" $2 \"\\t\" $3 \"\\t\" $4}' /path/to/input_sam.sam > output_name-string-value.txt",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \toutput_file_name = $job.inputs.input_sam.path.split(\"/\").pop()\n    output_file_name = output_file_name.slice(0, output_file_name.length - 4)\n  \tif ($job.inputs.output_name)\n    {\n    \toutput_file_name = $job.inputs.output_name\n    }\n\tif($job.inputs.aligned_reference == \"genome\" || $job.inputs.aligned_reference == \"ribosomal\")\n    {\n      \treturn \"awk '$1 !~ /^@/ && $2 != 4 {print $1  \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3 \\\"\\\\t\\\" $4}' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n  \telse if($job.inputs.aligned_reference == \"regular\" || $job.inputs.aligned_reference == \"scrambled\")\n    {\n    \treturn \"awk \\'$1 !~ /^@/ && $4 >= \" + $job.inputs.junction_midpoint + \" -length($10)+ \" + $job.inputs.overlap + \" +1 && $4 <= \" + $job.inputs.junction_midpoint + \"- \" + $job.inputs.overlap + \" +1 {print $1 \\\"\\\\t\\\" $2 \\\"\\\\t\\\" $3}\\' \" + $job.inputs.input_sam.path + \" > \" + output_file_name + \".txt\"\n    }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 795,
        "id": "milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520442544,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "junction_midpoint": 3,
            "output_name": "output_name-string-value",
            "overlap": 5,
            "input_sam": {
              "path": "/path/to/input_sam.sam",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "aligned_reference": "ribosomal"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520442509,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520442544,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 4 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_sam",
              "glob": "*.txt"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#aligned_reads"
          }
        ],
        "label": "Knife Preprocess Aligned Reads",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 4 copied",
        "y": 386.015625,
        "inputs": [
          {
            "sbg:includeInPorts": true,
            "id": "#overlap",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "type": [
              "null",
              "string"
            ],
            "id": "#output_name",
            "required": false
          },
          {
            "type": [
              "null",
              "int"
            ],
            "id": "#junction_midpoint",
            "required": false
          },
          {
            "type": [
              "File"
            ],
            "id": "#input_sam",
            "required": true
          },
          {
            "type": [
              {
                "type": "enum",
                "name": "aligned_reference",
                "symbols": [
                  "ribosomal",
                  "genome",
                  "regular",
                  "scrambled"
                ]
              }
            ],
            "id": "#aligned_reference",
            "required": true
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/knife-preprocess-aligned-reads/1",
        "successCodes": [],
        "stdout": "",
        "sbg:createdOn": 1520442509,
        "baseCommand": [
          ""
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "ubuntu"
          }
        ]
      },
      "inputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.output_name"
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.junction_midpoint",
          "default": 150
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.input_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.result_sam_file"
          ]
        },
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.aligned_reference",
          "default": "scrambled"
        }
      ],
      "outputs": [
        {
          "id": "#Knife_Preprocess_Aligned_Reads_3.aligned_reads"
        }
      ],
      "sbg:x": 795,
      "sbg:y": 386.015625,
      "scatter": "#Knife_Preprocess_Aligned_Reads_3.input_sam"
    },
    {
      "id": "#KNIFE_GLM_model",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "chmod +x JS_forFindCircularRNA_GLMfix.r && Rscript JS_forFindCircularRNA_GLMfix.r /path/to/SAMPLE_ID__output.txt SAMPLE_ID_glm.RData_cdf SAMPLE_ID_linearJuncProbs.txt_cdf SAMPLE_ID_circJuncProbs.txt_cdf",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/glm-model/1",
        "arguments": [],
        "x": 1195,
        "sbg:categories": [
          "RNA"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/glm-model/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520432679,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "JS_forFindCircularRNA_GLMfix.r",
                "fileContent": "#!/usr/bin/env Rscript\n#   PFA_VMEM=\"200000\"  # this is used for glm reports, needed for srun\n# DT[, c(\"z\",\"u\",\"v\"):=NULL] #remove several columns at once\n\n## The heart of the GLM. Uses the text files of ids generated by the naive method run\n# to assign reads to categories and outputs predictions per junction to glmReports. models\n# are saved into glmModels for further manual investigation.\n\n########## FUNCTIONS ##########\n\nrequire(data.table)\nlibrary(base)\nset.seed(1, kind = NULL, normal.kind = NULL)\n\n# allows for variable read length (for trimmed reads)\ngetOverlapForTrimmed <- function(x, juncMidpoint=150){\n    if (as.numeric(x[\"pos\"]) > juncMidpoint){\n      overlap = 0\n    } else if (as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - 1 < juncMidpoint + 1){\n      overlap = 0\n    } else {\n      overlap = min(as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - juncMidpoint,\n      juncMidpoint + 1 - as.numeric(x[\"pos\"]))\n    }\n\n  return(overlap)\n}\n\nprocessScoreInput <- function(scoreFile){\n  setkey(scores, id)\n    return(scores)\n}\n\naddDerivedFields <- function(dt, useClass){\n# correction 4/2016 of class files\nif(nrow(dt) > 0){\n    # calculate and add on cols for junction overlap, score adjusted for N penalties,\n    ########## now, we have info for read1 and read2\n    # calculate and add on cols for junction overlap, score adjusted for N penalties,\n    dt[,`:=`(is.pos=useClass,overlap=apply(dt, 1, getOverlapForTrimmed))]  # syntax for multiple :=\n    # and length-adjusted alignment score (laplace smoothing so alignment score of 0 treated different for different length reads)\n    dt[, lenAdjScore:=(as.numeric(aScore) - 0.001)/as.numeric(readLen)]\n    dt[,`:=`(pos=NULL, aScore=NULL, numN=NULL, readLen=NULL)]\n################# repeat for read2\n ## therefore, only add length adjusted alignment score for R2 !!\n    # and length-adjusted alignment score (`` smoothing\" so alignment score of 0 treated different for different length reads)\n    dt[, lenAdjScoreR2:=(aScoreR2 - 0.001)/readLenR2]\n    dt[,`:=`(pos=NULL, aScoreR2=NULL, numNR2=NULL, readLenR2=NULL, adjScoreR2=NULL, aScore=NULL, numN=NULL, readLen=NULL, adjScore=NULL)]\n}\n    return(dt)\n}\n\n# the input file is just the file output by the circularRNApipeline under /ids\nprocessClassInput <- function(classFile,my.names){\n\n#cats = fread(classFile,  sep=\"\\t\", nrows=100000)\ncats = fread(classFile,  sep=\"\\t\")\n############################################################\nif ( my.names!=\"none\"){\nnames(cats)=my.names\n}\n\n# syntax for changing names setnames(cats, names(cats), c(\"id\", \"R1\", \"R2\", \"class\"))\n  setkey(cats, id)\n  return(cats)\n}\n\n# To avoid integer underflow issue when we have too many very small or very large probabilities.\n# Take inverse of posterior probability, then take log, which simplifies to sum(log(q) - /sum(log(p))\n# and then reverse operations to convert answer back to a probability.\n# param p: vector of p values for all reads aligning to junction\n# return posterior probability that this is a circular junction based on all reads aligned to it\ngetPprodByJunction <- function(p ){\n  out = tryCatch(\n{\n  x = sum(log(p))  # use sum of logs to avoid integer underflow\n  return(exp(x))\n},\nerror = function(cond){\n  print(cond)\n  print(p)\n  return(\"?\")\n},\nwarning = function(cond){\n  print(cond)\n  print(p)\n  return(\"-\")\n}\n  )\nreturn(out)\n}\n\napplyToClass <- function(dt, expr) {\n  e = substitute(expr)\n  dt[,eval(e),by=is.pos]\n}\n\napplyToJunction <- function(dt, expr) {\n  e = substitute(expr)\n  dt[,eval(e),by=junction]\n}\n\n\n#######################################################################\n######################## BEGIN JS ADDITION ############################\n####################### FIRST JS FUNCTION #############################\n########################################################################\n################# JS added function to FIT the GLM using arbitrary two-classes\n\nmy.glm.model<-function( linear_reads, decoy_reads,use_R2 , max.iter){\n### FUNCTION TO FIT GLM TO linear READS, returns the GLM and junction predictions,\nsaves = list()  # to hold all of the glms for future use\n#max.iter = 2  # number of iterations updating weights and retraining glm\n\n# set up structure to hold per-read predictions\nn.neg = nrow(decoy_reads)\nn.pos = nrow(linear_reads)\nn.reads = n.neg+n.pos\nclass.weight = min(n.pos, n.neg)\n\n## note that this is coded as linear_reads and decoy_reads but applies to any pair class\n\nreadPredictions = rbindlist(list(linear_reads, decoy_reads))\n\n# set initial weights uniform for class sum off all weights within any class is equal\nif (n.pos >= n.neg){\n  readPredictions[,cur_weight:=c(rep(n.neg/n.pos, n.pos), rep(1, n.neg))]\n} else {\n  readPredictions[,cur_weight:=c(rep(1, n.pos), rep(n.pos/n.neg, n.neg))]\n}\n\n# glm\nfor(i in 1:max.iter){\n  # M step: train model based on current read assignments, down-weighting the class with more reasourcds\n\nif (use_R2==1){\n  x = glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n\n}\nif (use_R2==0){\n  x = glm(is.pos~overlap+lenAdjScore+qual , data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n}\n  saves[[i]] = x\n\n  # get CI on the output probabilities and use 95% CI\n  preds = predict(x, type = \"link\", se.fit = TRUE)\n  critval = 1.96 # ~ 95% CI\n  upr = preds$fit + (critval * preds$se.fit)\n  lwr = preds$fit - (critval * preds$se.fit)\n  upr2 = x$family$linkinv(upr)\n  lwr2 = x$family$linkinv(lwr)\n\n  # use the upper 95% value for decoys and lower 95% for linear\n  adj_vals = c(rep(NA, n.reads))\n  adj_vals[which(readPredictions$is.pos == 1)] = lwr2[which(readPredictions$is.pos == 1)]\n  adj_vals[which(readPredictions$is.pos == 0)] = upr2[which(readPredictions$is.pos == 0)]\n  x$fitted.values = adj_vals  # so I don't have to modify below code\n\n  # report some info about how we did on the training predictions\n  totalerr = sum(abs(readPredictions[,is.pos] - round(x$fitted.values)))\n  print (paste(i,\"total reads:\",n.reads))\n  print(paste(\"both negative\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==0), \"out of \", n.neg))\n  print(paste(\"both positive\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==2), \"out of \", n.pos))\n  print(paste(\"classification errors\", totalerr, \"out of\", n.reads, totalerr/n.reads ))\n  print(coef(summary(x)))\n  readPredictions[, cur_p:=x$fitted.values] # add this round of predictions to the running totals\n\n  # calculate junction probabilities based on current read probabilities and add to junction predictions data.table\n\n  tempDT = applyToJunction(subset(readPredictions, is.pos == 1), getPprodByJunction(cur_p))\n  setnames(tempDT, \"V1\", paste(\"iter\", i, sep=\"_\")) # iter_x is the iteration of product of ps\n  setkey(tempDT, junction)\n  junctionPredictions = junctionPredictions[tempDT]  # join junction predictions and the new posterior probabilities\n  rm(tempDT)  # clean up\n\n  # E step: weight the reads according to how confident we are in their classification. Only if we are doing another loop\n  if(i < max.iter){\n    posScale = class.weight/applyToClass(readPredictions,sum(cur_p))[is.pos == 1,V1]\n    negScale = class.weight/(n.neg - applyToClass(readPredictions,sum(cur_p))[is.pos == 0,V1])\n    readPredictions[is.pos == 1,cur_weight:=cur_p*posScale]\n    readPredictions[is.pos == 0,cur_weight:=((1 - cur_p)*negScale)]\n  }\n  setnames(readPredictions, \"cur_p\", paste(\"iter\", i, sep=\"_\")) # update names\n}\n\n# calculate mean and variance for null distribution\n## this uses a normal approximation which holds only in cases with large numbers of reads, ie the CLT only holds as the number of reads gets very large\n\n## should be called p-predicted\n##read_pvals = readPredictions[,max.iter]\n\n# rename cols to be consistent with circular glmReports, syntax below removes col. \"ITER_1\"\nif (max.iter>1){\n# cleaning up\nfor (myi in c(1:(max.iter-1))){\njunctionPredictions[, paste(\"iter_\",myi,sep=\"\"):=NULL]\n}\n}\nsetnames(junctionPredictions, paste(\"iter_\",max.iter,sep=\"\"), \"p_predicted\")\nlist(saves, junctionPredictions) ## JS these are the outputs and done with function\n}\n\n\n########################################################################\n###################### prediction from model ##########################\n##### as a function, needs input data and model\n\npredictNewClassP <- function(my_reads, null){ ## need not be circ_reads, just easier syntax\n######### up until this point, every calculation is PER READ, now we want a function to collapse\n######### want to do hypothesis testing\n# calculate junction probabilities based on predicted read probabilities\n## Use simple function-- NOTE: \"p predicted\" is a CI bound not the point estimate. It is still technically a consistent estimate of p predicted\n## prob of an anomaly by glm is phat/(1+phat) under 'real' 1/(1+phat) under 'decoy' junction, so the ratio of these two reduces to 1/phat. as phat -> 1, no penalty is placed on anomaly.\n\n#merge\njunctionPredictions = my_reads[, .N, by = junction] # get number of reads per junction\nsetnames(junctionPredictions, \"N\", \"numReads\")\nsetkey(junctionPredictions, junction)\n\nmy_reads[, logproduct:=sum( log (p_predicted) * (1-is.anomaly) + log( 1/(1+p_predicted) *is.anomaly)), by=junction]\n\n## is anomaly adjusted log sum scoremm\nlogsum=my_reads[,sum( log ( p_predicted / (1+p_predicted*is.anomaly))), by=junction]\nlogsum_2=my_reads[,sum( log ( p_predicted_2 / (1+p_predicted_2*is.anomaly))), by=junction]\nprint (\"Logsum is reported which is equal to the sum of the logs of phats-- if exponentiated, corresponds to product of ps\")\n\n## merge these new variables to the dataframe\njunctionPredictions=merge(junctionPredictions,logsum)\nsetnames(junctionPredictions, \"V1\", \"logsum\")\n\njunctionPredictions=merge(junctionPredictions,logsum_2)\nsetnames(junctionPredictions, \"V1\", \"logsum_2\")\n\nprint (names(junctionPredictions))\n\n########### adding quantiles of p_predicted\nn.quant=2\nfor (qi in 1:n.quant){\nmy_quantiles = my_reads[,round(10*quantile(p_predicted/(1+is.anomaly* p_predicted),probs=c(0:n.quant)/n.quant)[qi])/10,by=junction]\n\n# merge into junctionPredictions\nprint (head(my_quantiles))\nsetkey(my_quantiles,junction)\njunctionPredictions=merge(junctionPredictions,my_quantiles)\nsetnames(junctionPredictions, \"V1\", paste(\"q_\",qi,sep=\"\"))\n}\n\n##################################\n##  tempDT, to collapse across junctions\n# p_predicteds are the exponentiation\njunctionPredictions [ ,p_predicted_2:=exp(logsum_2),by=junction]\njunctionPredictions [ ,p_predicted:=exp(logsum),by=junction]\n\nprint (head(junctionPredictions[order(junction),]))\n\n## NOTE: P VALUE IS probability of observing a posterior as extreme as it is, \"getPvaluebyJunction\" is a bayesian posterior\njunctionPredictionsWP=assignP(junctionPredictions,null)\n\nrm(tempDT)  # clean up\n## adding here:\n\nunique(junctionPredictionsWP) ## returned\n\n}\n########################################################################################### ASSIGN p values through permutation\n###################################\nassignP<-function(junctionPredictions,null) {\n# logsum is the logged sum\n# add p-value to junctionPredictions (see GB supplement with logic for this)\n\nlognull=log(null)\n\nuse_mu = mean(lognull) # this is actually the mean of the read level predictions\nuse_var=var(lognull)\n## for large n,\n#print (\"using cdf of null distribution as \"p_value\" which is misnomer for convenient and replaced below \")\nn.thresh.exact=15\nprint (n.thresh.exact)\n\njunctionPredictions[ (numReads>n.thresh.exact) , p_value :=  pnorm((logsum - numReads*use_mu)/sqrt(numReads*use_var))]\n\njunctionPredictions[ (numReads>n.thresh.exact) , p_value_2 :=  pnorm((logsum_2 - numReads*use_mu)/sqrt(numReads*use_var))]\n\n## make empirical distribution of posteriors:\n\nprint (\"exact calculation through sampling 10K p predicted\")\nmy.dist=list(n.thresh.exact)\nfor ( tempN in 1:n.thresh.exact){ #### get distributions to convolve in next loop\nn.sampled=1000 # used to compute the null distribution of posteriors\nmy.dist[[tempN]]=sample(lognull, n.sampled, replace=T)\n}\n\nfor ( tempN in 1:n.thresh.exact){ ## use this loop to assign jncts w/ tempN\nsim.readps=my.dist[[1]]\nif (tempN>1){\nfor (tj in 2: tempN){ # loop, taking products\nsim.readps=my.dist[[tj]] +  sim.readps\n}\n}\n# convert to posterior\n## fraction of time p_predicted is smaller than -- so if p_predicted is very large, the fraction of time it is smaller is big\n## use the null to compute p_vals\nprint (head(junctionPredictions))\nprint (paste(tempN, \"is value of readcount for exact calculation and length of sim reads is \",length(sim.readps)))\n\njunctionPredictions [ (numReads == tempN ), p_value:= sum( exp(sim.readps)<p_predicted)/length(sim.readps),by=junction]\n\nprint (\"if below table is not empty, ERROR\")\nprint (junctionPredictions[p_value>1])\n\n\njunctionPredictions [ (numReads == tempN ), p_value_2:= sum( exp(sim.readps)<p_predicted_2)/length(sim.readps), by=junction]\n\n}\nreturn(junctionPredictions)\n}\n###########################################################################################\n###########################################################################################\n###########################################################################################\n###########################################################################################\n######## END FUNCTIONS, BEGIN WORK #########\n\n## command line inputs\n\n################# USER INPUT SHOULD BE 0 if it is used in an automated script\n\n#parentdir=\"/scratch/PI/horence/alignments/EWS_FLI_bigmem/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/gillian/CML_UConn/circpipe_K562/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/alignments/EWS_FLI_bigmem/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/gillian/CML_test/aligned/CML/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/gillian/Ewing/circpipe/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/gillian/normal_breast/circpipe/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/gillian/SEQC_study_set/circpipe_SEQC/circReads/ids/\"\n#parentdir=\"/scratch/PI/horence/alignments/Stavros/circReads/ids/\"\n#output_dir=\"\"\nsampletest=\"EWS\"\nuser.input=0\n\n\nargs = commandArgs(trailingOnly = TRUE)\nclass_input = args[1]\nglm_out = args[2]\nlinear_juncp_out = args[3]\ncirc_juncp_out = args[4]\n#print(paste(\"predict junctions called with args:\", args))\n\nmax.iter=2 ## iterations for glm\n\nmy.names=\"none\" ## this is bc Gillians fields are not names like Lindas are\nmyClasses = processClassInput(class_input, my.names)\n\n\nprint(paste(\"class info processed\", dim(myClasses)))\n\nprint (\"finished circ_reads\")\n\ndecoy_reads = myClasses[(tolower(class) %like% 'decoy'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2),]\nif (dim(decoy_reads)[1] == 0){\n  print(\"Exiting: number of decoy reads is 0.\")\n  quit(status = 0)\n}\ndecoy_reads = addDerivedFields(decoy_reads, 0)\ndecoy_reads [, is.anomaly:=1] ######## this IS an anomaly type\n\nprint (\"finished decoy_reads\")\n## was\nlinear_reads = myClasses[(tolower(class) %like% 'linear'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2),]\nif (dim(linear_reads)[1] == 0){\n  print(\"Exiting: number of linear reads is 0.\")\n  quit(status = 0)\n}\nlinear_reads = addDerivedFields(linear_reads, 1)\nlinear_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\nprint (\"finished linear_reads\")\n\n###############################################################################################\n## CANNOT ADD DERIVED FIELDS HERE BECAUSE WE DON'T KNOW WHICH ANOMALIES ARE GOOD AND/OR BAD\n##################### DERIVED FIELDS ADDED LATER ##############################################\n###############################################################################################\n\n# set up data structure to hold per-junction predictions\njunctionPredictions = linear_reads[, .N, by = junction] # get number of reads per junction\nsetnames(junctionPredictions, \"N\", \"numReads\")\nsetkey(junctionPredictions, junction)\n\n#### TRAIN EM ####\n## this should be a function of any two classes; and the output will be the model\n\n##\n\nn.row= dim(linear_reads)[1]\nn.sample=min(n.row,10000)\n\n#syntax example decoy_reads[,p_predicted:=NULL]\nprint (\"calling linear decoy model\")\nlinearDecoyGLMoutput = my.glm.model ( linear_reads[ sample(n.row,n.sample,replace=FALSE),], decoy_reads, 1, max.iter) ## 0 does not use R2 info\n\nsaves = linearDecoyGLMoutput[[1]]\nlinearJunctionPredictions =  linearDecoyGLMoutput[[2]]\nsave(saves, file=glm_out)  # save models\nlinearDecoyGLM = saves[[max.iter]] ##### this is the glm model\n\n## after fitting the GLM to linear vs. decoy, we want to store linear junction predictions in order to subset anomalies\n######## JS ADDITION: NOTE- NOT stratifying on permutation p value, although could add this too\n\n\n############################################################################\n### START LINEARS\n################# predict on anomaly reads -- AND TEST HOW THIS IMPACTS LINEAR PREDICTIONS\n############################ linear predictions ONLY ON THE BASIS of anomalies...\n\npreds = predict(linearDecoyGLM, newdata=linear_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\nlinear_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\nlinear_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n## for null\nprint (\"Assigning null distribution for all linear reads\")\nnull=linear_reads$p_predicted\n\n### ASSIGN p value:\nlinearJunctionPredictionsForModels = predictNewClassP(linear_reads, null)\n\npGoodThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.8)\ngood.linear=linearJunctionPredictionsForModels[p_value> pGoodThresh,]\n\npBadThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.2)\nbad.linear=linearJunctionPredictionsForModels[p_value< pBadThresh,]\n#####################################\n\n\n\n##### now, re-run script training on anomalies from good vs. bad\n\nsave(linearDecoyGLM, file=glm_out)  # save models\n\npreds = predict(linearDecoyGLM, newdata=decoy_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\ndecoy_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ndecoy_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n\nlinearJunctionPredictions = predictNewClassP(linear_reads, null)\n\nlinearJunctionPredictions[,q_1:=NULL]\nlinearJunctionPredictions[,q_2:=NULL]\nlinearJunctionPredictions[,logsum_2:=NULL]\nlinearJunctionPredictions[,p_predicted_2:=NULL]\nlinearJunctionPredictions[,p_value_2:=NULL]\nsetnames(linearJunctionPredictions,\"p_predicted\", \"productPhat.x\")\nsetnames(linearJunctionPredictions,\"p_value\", \"junction_cdf.x\")\n\nwrite.table(unique(linearJunctionPredictions), linear_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\n################# DONE WITH LINEARS\n#########################################################################\n\n#### PREDICT CIRCULAR JUNCTIONS #### SHOULD MAKE THIS MODULAR AND A FUNCTION so Farjunction and Anomalies can be used\n## SIMPLE PREDICT ON CIRCLES\n\ncirc_reads = myClasses[(tolower(class) %like% 'circ'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2),]\nif (dim(circ_reads)[1] == 0){\n  print(\"Exiting: number of circular reads is 0.\")\n  quit(status = 0)\n}\ncirc_reads = addDerivedFields(circ_reads, 1)\ncirc_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\npreds = predict(linearDecoyGLM, newdata=circ_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n\ncirc_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ncirc_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\ncircularJunctionPredictions = predictNewClassP(circ_reads, null)\n\n\n\n## write circle prediction\n\ncircularJunctionPredictions[,q_1:=NULL]\ncircularJunctionPredictions[,q_2:=NULL]\ncircularJunctionPredictions[,logsum_2:=NULL]\ncircularJunctionPredictions[,p_predicted_2:=NULL]\ncircularJunctionPredictions[,p_value_2:=NULL]\n\nsetnames(circularJunctionPredictions,\"p_predicted\", \"productPhat.x\")\nsetnames(circularJunctionPredictions,\"p_value\", \"junction_cdf.x\")\n\nwrite.table(unique(circularJunctionPredictions), circ_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 5000
          },
          "inputs": {
            "input_report": {
              "path": "/path/to/SAMPLE_ID__output.txt",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520432659,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520432679,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 21 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "sbg:links": [
          {
            "label": "Publication",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed/26076956"
          }
        ],
        "label": "KNIFE GLM model",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 21 copied",
        "y": 180.015625,
        "inputs": [
          {
            "description": "Output of FilterFDR.py which contains report about reads.",
            "label": "Input report",
            "type": [
              "File"
            ],
            "id": "#input_report",
            "required": true
          }
        ],
        "description": "GLM model fits logistic generalized linear model (GLM) model in order to predict probability that a paired-end read is a \"decoy\" read. GLM uses five predictors — alignment scores of read 1 and read 2 (a composite of sequencing quality and mismatch rate), mapping quality of read 1 and read 2, and offset position to predict the response variable, which is the binary set of class labels (class 1 or 2). Class 1 is a set of \"linear\" reads while class 2 is a set of \"decoy\" reads. In KNIFE, the GLM predicts the probability that each circular read belongs to class 1 (true positive) versus class 2 (false positive). \n\nThe GLM was fit with the larger class downweighted so that each class had equal influence in the model. All reads within a class were initially weighted equally. After fitting this model, the weights of reads with poor fit to the model were downweighted in proportion to their lack of fit, maintaining the constraint that, together, reads in each class had equal total weight. The model was then fit again to the dataset using the modified weights to obtain the final estimates of the five coefficients in the GLM and their statistical significance. This model is used to predict the probability of class membership in the independent set of reads with paired-end alignments consistent with being generated from circular RNA.\n\nThe next step of the algorithm is quantification of each putative junction via Bayesian hypothesis testing. For each junction, the posterior probability that junction-spanning reads, in aggregate, had a statistical profile consistent with decoy reads is computed , which would suggest they are artifacts versus those from linear splice junctions, which would suggest they are real. The posterior probability is the conditional probability that a junction is a true positive conditioned on one of two scenarios: reads from the junction are all decoys or all true positives.\n\nAfter estimating the predicted probabilities of each read, a p value for the posterior probability of a junction is computed based on the null hypothesis which induces a permutation distribution on the {pˆi}, the distribution that randomly assigns a p^j for each read independent of the junction to which the read aligned. The permutation distribution on {p^i} induces a distribution on the posterior probability for a linear junction as a function of number of aligned reads. An analogous test is performed for each circular junction with a simple model to provide a false discovery rate (FDR) because the above approach is too conservative for circular RNA junctions, as these reads were not used to fit the GLM model.\n\nThe GLM model outputs three files:\n\n1. r\\_data: R object which contains trained GLM model\n2. linear\\_junc\\_probs: predicted posterior probabilities for each junction using only \"linear\" reads\n3. circ\\_junc\\_probs: predicted posterior probabilities for each junction using only \"circular\" reads",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "outputs": [
          {
            "outputBinding": {
              "glob": "*.RData_cdf"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#r_data"
          },
          {
            "outputBinding": {
              "glob": "*linearJuncProbs.txt_cdf"
            },
            "label": "Linear junctions probability",
            "sbg:fileTypes": "TXT",
            "description": "Information about junctions which contain linear reads",
            "type": [
              "null",
              "File"
            ],
            "id": "#linear_junc_probs"
          },
          {
            "outputBinding": {
              "glob": "*circJuncProbs.txt_cdf"
            },
            "label": "Circular junction probabilities",
            "sbg:fileTypes": "TXT",
            "description": "Information about junctions which contain circular reads",
            "type": [
              "null",
              "File"
            ],
            "id": "#circ_junc_probs"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  \tname = $job.inputs.input_report.path.split('/').pop()\n    sample_id = name.slice(0, name.length - 12)\n    \n\treturn \"chmod +x JS_forFindCircularRNA_GLMfix.r && Rscript JS_forFindCircularRNA_GLMfix.r \" + $job.inputs.input_report.path + \" \" + sample_id + \"_glm.RData_cdf \" + sample_id + \"_linearJuncProbs.txt_cdf \" + sample_id + \"_circJuncProbs.txt_cdf\"\n\n}",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 5000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/machete_glm:r"
          }
        ],
        "sbg:createdOn": 1520432659
      },
      "inputs": [
        {
          "id": "#KNIFE_GLM_model.input_report",
          "source": [
            "#KNIFE_filterFDR.output"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#KNIFE_GLM_model.r_data"
        },
        {
          "id": "#KNIFE_GLM_model.linear_junc_probs"
        },
        {
          "id": "#KNIFE_GLM_model.circ_junc_probs"
        }
      ],
      "sbg:x": 1195,
      "sbg:y": 180.015625
    },
    {
      "id": "#getUnalignedReads_2",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python getUnalignedReadCount.py   -ribs /path/to/input_files-ribosomal.ext -gens /path/to/input_files-genome.ext -regs /path/to/input_files-regular.ext -scrs /path/to/input_files-scrambled.ext -r /path/to/input_files.ext   -ribsm /path/to/mate_input_files-ribosomal.ext -gensm /path/to/mate_input_files-genome.ext -regsm /path/to/mate_input_files-regular.ext -scrsm /path/to/mate_input_files-scrambled.ext  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/getunalignedreads/1",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n\tinput_files = [].concat($job.inputs.input_files)\n    for(i = 0; i < input_files.length; i++)\n    {\n    \tif(input_files[i].path.indexOf(\"regular\") !== -1)\n        {\n          cmd += \" -regs \" + input_files[i].path\n          continue\n        }\n        if(input_files[i].path.indexOf(\"scrambled\") !== -1)\n        {\n          cmd += \" -scrs \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"genome\") !== -1)\n        {\n          cmd += \" -gens \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"ribosomal\") !== -1)\n        {\n          cmd += \" -ribs \" + input_files[i].path\n          continue\n        }\n      \telse\n        {\n        \tcmd += \" -r \" + input_files[i].path\n        }\n      \n    }\n  \treturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    for(i = 0; i < input_files.length; i++)\n    {\n    \tif(input_files[i].path.indexOf(\"regular\") !== -1)\n        {\n          cmd += \" -regsm \" + input_files[i].path\n          continue\n        }\n        if(input_files[i].path.indexOf(\"scrambled\") !== -1)\n        {\n          cmd += \" -scrsm \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"genome\") !== -1)\n        {\n          cmd += \" -gensm \" + input_files[i].path\n          continue\n        }\n      \tif(input_files[i].path.indexOf(\"ribosomal\") !== -1)\n        {\n          cmd += \" -ribsm \" + input_files[i].path\n          continue\n        }\n      \n    }\n  \treturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.input_files)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 1594.1765152706823,
        "sbg:categories": [
          "RNA"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/getunalignedreads/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520432864,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "getUnalignedReadCount.py",
                "fileContent": "# Creates a fasta and fastq file containing all reads for the sample that did not align to any of\n# the Bowtie2 indices in the directory \"orig/unaligned\". It also creates a fastq file under\n# \"orig/unaligned/forDenovoIndex\" that contains the subset of unaligned reads that are long\n# enough to be used for the de novo index (NTRIM + 8). This forDenovoIndex file had to be\n# created because Bowtie does not gracefully handle when a read gets trimmed to a negative length.\n#\n# This script is called by qualityStatsSingleSample.sh when the sampleStats reports are being generated,\n# so it returns the number of unaligned reads to be reported. This is the total number of unaligned reads,\n# not just those that were long enough to be used for the de novo index.\n\nimport argparse\nimport subprocess\nfrom ParseFastQ import ParseFastQ\nimport multiprocessing\nimport Queue\n\n\ndef addAlignedIds(samFile):\n    handle = open(samFile, \"rU\")\n\n    for line in handle:\n        if not line.startswith(\"@\"):  # ignore header lines\n            if args.fastqIdStyle == \"appended\":\n                aligned[line.strip().split()[0][:-1]] = None\n            else:\n                aligned[line.strip().split()[0]] = None\n\n    handle.close()\n\ndef RemoveIds(samFile, tmpSamFile):\n    handle = open(samFile, \"rU\")\n    output = open(tmpSamFile, \"w\")\n\n    for line in handle:\n        if line.startswith(\"@\"):\n            output.write(line)\n        elif args.fastqIdStyle == \"appended\" and line.strip().split()[0][:-1] not in aligned:\n            output.write(line)\n        elif args.fastqIdStyle == \"complete\" and line.strip().split()[0] not in aligned:\n            output.write(line)\n\n    handle.close()\n    output.close()\n\n    cmd = \"mv -f \" + tmpSamFile + \" \" + samFile\n    print(cmd)\n    subprocess.call(cmd, shell=True)\n\n\nif __name__ == \"__main__\":\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-r', '--readFile', help='path to fastq file containing reads you attempted to align',required=True)\n    #parser.add_argument('-r2', '--readFile2', help='path to fastq file 2 containing reads you attempted to align',required=True)\n\n    parser.add_argument('-s', '--sample', help='base name used in alignment output files', required=True)\n    parser.add_argument('-n', '--suffix', help='base name used in alignment output files', required=True)\n    parser.add_argument('-t', '--ntrim', help='ntrim used in denovo pipeline', type=int, required=True)\n\n    parser.add_argument('-v', '--verbose', help='print info about data obtained', action='store_true')\n\n    parser.add_argument('-q', '--fastqIdStyle', help='type of read ids used', required=True, choices=['appended', 'complete'])\n\n    parser.add_argument('-gens', '--genomeSAM', help = 'path to the genome SAM file', required=True)\n    parser.add_argument('-ribs', '--ribosomalSAM', help='path to the ribosomal SAM file', required=True)\n    parser.add_argument('-regs', '--regularSAM', help='path to the regular junction SAM file', required=True)\n    parser.add_argument('-scrs', '--scrambledSAM', help='path to the scrambled junction SAM file', required=True)\n\n    parser.add_argument('-gensm', '--genomeSAMMate', help = 'path to the genome mate SAM file', required=True)\n    parser.add_argument('-ribsm', '--ribosomalSAMMate', help='path to the ribosomal mate SAM file', required=True)\n    parser.add_argument('-regsm', '--regularSAMMate', help='path to the regular junction mate SAM file', required=True)\n    parser.add_argument('-scrsm', '--scrambledSAMMate', help='path to the scrambled junction mate SAM file', required=True)\n\n    args = parser.parse_args()\n\n    aligned = {}\n    unaligned = {}\n\n    #aligned2 = {}\n    #unaligned2 = {}\n\n    minReadLen = args.ntrim + 8  # we want to have at least 8 nt left after read is trimmed for denovo split reads\n\n    try:\n        # put each id from sam files in a dict\n\n\n        addAlignedIds(args.genomeSAM)\n        addAlignedIds(args.ribosomalSAM)\n        addAlignedIds(args.regularSAM)\n        addAlignedIds(args.scrambledSAM)\n\n        # get each id from fastq file, add it to a dict if not in the aligned dict\n        parser = ParseFastQ(args.readFile)\n        for (seqHeader, seqStr, qualHeader, qualStr) in parser:\n            if args.fastqIdStyle == \"appended\":\n                title = seqHeader.split()[0][1:-1]\n            else:\n                title = seqHeader.split()[0][1:]\n\n            if title not in aligned:\n                unaligned[seqHeader.split()[0][1:]] = (seqHeader, seqStr, qualHeader, qualStr)\n\n        # write list of unaligned ids to fasta and fastq files\n        out_handle = open(\"unaligned_\" + args.sample + \".\" + args.suffix + \".fasta\", \"wb\")\n        out_fq_handle = open(\"unaligned_\" + args.sample + \".\" + args.suffix + \".fq\", \"wb\")\n        out_denovo_handle = open(\"forDenovoIndex_unaligned_\" + args.suffix + \".fq\", \"wb\")\n        for id in unaligned.keys():\n            # fasta file\n            out_handle.write(\">\" + id + \"\\n\")\n            out_handle.write(unaligned[id][1] + \"\\n\")\n            # fastq file\n            out_fq_handle.write(\"%s\\n%s\\n%s\\n%s\\n\" % (unaligned[id][0], unaligned[id][1], unaligned[id][2], unaligned[id][3]))\n            # fastq file for denovo index\n            if len(unaligned[id][1]) >= minReadLen:\n                out_denovo_handle.write(\"%s\\n%s\\n%s\\n%s\\n\" % (unaligned[id][0], unaligned[id][1], unaligned[id][2], unaligned[id][3]))\n\n        out_handle.close()\n        out_fq_handle.close()\n        out_denovo_handle.close()\n\n        # return size of unaligned dict\n        print len(unaligned)\n    except Exception as e:\n        print \"Exception:\", e\n\n    procs = []\n    try:\n        p_genome_mate = multiprocessing.Process(target=RemoveIds, args=(args.genomeSAMMate, \"tmp_genome.sam\"))\n        procs.append(p_genome_mate)\n        p_genome_mate.start()\n        #p_genome_mate.join()\n\n        p_ribosomal_mate = multiprocessing.Process(target=RemoveIds, args=(args.ribosomalSAMMate, \"tmp_ribosomal.sam\"))\n        procs.append(p_ribosomal_mate)\n        p_ribosomal_mate.start()\n        #p_ribosomal_mate.join()\n\n        p_regular_mate = multiprocessing.Process(target=RemoveIds, args=(args.regularSAMMate, \"tmp_regular.sam\"))\n        procs.append(p_regular_mate)\n        p_regular_mate.start()\n        #p_regular_mate.join()\n\n        p_scambled_mate = multiprocessing.Process(target=RemoveIds, args=(args.scrambledSAMMate, \"tmp_scrambled.sam\"))\n        procs.append(p_scambled_mate)\n        p_scambled_mate.start()\n        #p_scambled_mate.join()\n\n        for p in procs:\n            p.join()\n\n        #RemoveIds(args.genomeSAMMate, \"tmp_genome.sam\")\n        #RemoveIds(args.ribosomalSAMMate, \"tmp_ribosomal.sam\")\n        #RemoveIds(args.regularSAMMate, \"tmp_regular.sam\")\n        #RemoveIds(args.scrambledSAMMate, \"tmp_scrambled.sam\")\n    except Exception as e:\n        print \"Exception:\", e"
              },
              {
                "filename": "ParseFastQ.py",
                "fileContent": "import gzip\n\n\nclass ParseFastQ(object):\n    \"\"\"Returns a read-by-read fastQ parser analogous to file.readline()\"\"\"\n\n    def __init__(self, filePath, headerSymbols=['@', '+']):\n        \"\"\"Returns a read-by-read fastQ parser analogous to file.readline().\n        Exmpl: parser.next()\n        -OR-\n        Its an iterator so you can do:\n        for rec in parser:\n            ... do something with rec ...\n\n        rec is tuple: (seqHeader,seqStr,qualHeader,qualStr)\n        \"\"\"\n        if filePath.endswith('.gz'):\n            self._file = gzip.open(filePath)\n        else:\n            self._file = open(filePath, 'rU')\n        self._currentLineNumber = 0\n        self._hdSyms = headerSymbols\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        \"\"\"Reads in next element, parses, and does minimal verification.\n        Returns: tuple: (seqHeader,seqStr,qualHeader,qualStr)\"\"\"\n        # ++++ Get Next Four Lines ++++\n        elemList = []\n        for i in range(4):\n            line = self._file.readline()\n            self._currentLineNumber += 1  ## increment file position\n            if line:\n                elemList.append(line.strip('\\n'))\n            else:\n                elemList.append(None)\n\n        # ++++ Check Lines For Expected Form ++++\n        trues = [bool(x) for x in elemList].count(True)\n        nones = elemList.count(None)\n        # -- Check for acceptable end of file --\n        if nones == 4:\n            raise StopIteration\n        # -- Make sure we got 4 full lines of data --\n        assert trues == 4, \\\n            \"** ERROR: It looks like I encountered a premature EOF or empty line.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._currentLineNumber)\n        # -- Make sure we are in the correct \"register\" --\n        assert elemList[0].startswith(self._hdSyms[0]), \\\n            \"** ERROR: The 1st line in fastq element does not start with '%s'.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._hdSyms[0], self._currentLineNumber)\n        assert elemList[2].startswith(self._hdSyms[1]), \\\n            \"** ERROR: The 3rd line in fastq element does not start with '%s'.\\n\\\n            Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n            self._hdSyms[1], self._currentLineNumber)\n        # -- Make sure the seq line and qual line have equal lengths --\n        assert len(elemList[1]) == len(elemList[3]), \"** ERROR: The length of Sequence data and Quality data of the last record aren't equal.\\n\\\n               Please check FastQ file near line number %s (plus or minus ~4 lines) and try again**\" % (\n        self._currentLineNumber)\n\n        # ++++ Return fatsQ data as tuple ++++\n        return tuple(elemList)"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 3000
          },
          "inputs": {
            "mode": "appended",
            "ntrim": 2,
            "mate_input_files": [
              {
                "path": "/path/to/mate_input_files-ribosomal.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "path": "/path/to/mate_input_files-genome.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "path": "/path/to/mate_input_files-regular.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "path": "/path/to/mate_input_files-scrambled.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "case_id": "1"
                }
              },
              {
                "path": "/path/to/mate_input_files.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "case_id": "1"
                }
              }
            ],
            "input_files": [
              {
                "path": "/path/to/input_files-ribosomal.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "case_id": "1"
                }
              },
              {
                "path": "/path/to/input_files-genome.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/input_files-regular.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/input_files-scrambled.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/input_files.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "suffix": "output_name-string-value"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520432843,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520432864,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 3 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "sbg:links": [
          {
            "label": "Publication",
            "id": "https://academic.oup.com/nar/article-lookup/doi/10.1093/nar/gkx453"
          }
        ],
        "label": "getUnalignedReads_2",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 3 copied",
        "y": 31.95680256494705,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-n"
            },
            "id": "#suffix",
            "type": [
              "null",
              "string"
            ]
          },
          {
            "label": "Ntrim",
            "description": "Ntrim used in denovo pipeline.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-t"
            },
            "id": "#ntrim",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Mode",
            "sbg:includeInPorts": true,
            "required": false,
            "description": "\"Appended\" mode should be selected if read_ids in first mate ends with 1 and in the second. If reads have the same read_id in both paired_end files, \"complete\" should be selected.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-q"
            },
            "id": "#mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "appended",
                  "complete"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Mate input files",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM, FASTQ",
            "description": "Mate fastq file and mate genome, ribosomal, regular and scrambled sam files.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#mate_input_files",
            "sbg:stageInput": "link",
            "required": false
          },
          {
            "label": "Input files",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM, FASTQ",
            "description": "Fastq file, genome, ribosomal, regular and scrambled sam files.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#input_files",
            "required": false
          }
        ],
        "description": "Tool getUnalignedReads takes as input fastq file, ribosomal, genome, regular and scrambled junctions sam files of one read and ribosomal, genome, regular and scrambled junctions sam files for its mates and outputs the following files:\n\n1. unaligned\\_fastq file: all reads that are not aligned neither to ribosomal, genome, regular nor scrambled junctions.\n2. unaligned\\_fasta file: same as unaligned_fastq file, but in fasta format without qualities.\n3. mate\\_genome\\_sam: sam file contains only lines from mate genome sam file for which read_id is in unaligned\\_fastq\\_file.\n4. mate\\_ribosomal\\_sam: sam file contains only lines from mate ribosomal sam file for which read_id is in unaligned\\_fastq\\_file.\n5. mate\\_regular\\_sam: sam file contains only lines from mate regular sam file for which read_id is in unaligned\\_fastq\\_file.\n6. mate\\_scrambled\\_sam: sam file contains only lines from mate scrambled sam file for which read_id is in unaligned\\_fastq\\_file.",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "outputs": [
          {
            "outputBinding": {
              "glob": "unaligned_*.fq",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#unaligned_fastq"
          },
          {
            "outputBinding": {
              "glob": "unaligned_*fasta",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#unaligned_fasta"
          },
          {
            "outputBinding": {
              "glob": "*scrambled.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_scrambled_sam"
          },
          {
            "outputBinding": {
              "glob": "*ribosomal.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_ribosomal_sam"
          },
          {
            "outputBinding": {
              "glob": "*regular_sorted.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_regular_sam"
          },
          {
            "outputBinding": {
              "glob": "*genome_sorted.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.sample_id)\n      return input_files[0].metadata.sample_id\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  \t\n\tinput_files = [].concat($job.inputs.mate_input_files)\n    if (input_files[0].metadata && input_files[0].metadata.paired_end)\n      return input_files[0].metadata.paired_end\n    return \"\"\n  \t\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#mate_genome_sam"
          },
          {
            "outputBinding": {
              "glob": "forDenovoIndex_unaligned*.fq",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.sample_id)\n    {\n    \treturn input_files[i].metadata.sample_id\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                },
                "paired_end": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.input_files)\n  for(i=0; i<input_files.length; i++)\n  {\n    if(input_files[i].metadata && input_files[i].metadata.paired_end)\n    {\n    \treturn input_files[i].metadata.paired_end\n    }\n  }\n  return \"\"\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "label": "ForDenovoIndex unaligned reads",
            "type": [
              "null",
              "File"
            ],
            "id": "#denovo_unaligned",
            "sbg:fileTypes": "FQ, FASTQ"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "getUnalignedReadCount.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 3000
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "c4.8xlarge;ebs-gp2;1024"
          }
        ],
        "sbg:createdOn": 1520432843
      },
      "inputs": [
        {
          "id": "#getUnalignedReads_2.suffix",
          "default": "_2"
        },
        {
          "id": "#getUnalignedReads_2.ntrim",
          "default": 50
        },
        {
          "id": "#getUnalignedReads_2.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#getUnalignedReads_2.mate_input_files",
          "source": [
            "#SBG_Prepare_Scatter_Trim.output_files_1"
          ]
        },
        {
          "id": "#getUnalignedReads_2.input_files",
          "source": [
            "#SBG_Prepare_Scatter_Trim.output_files_2"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#getUnalignedReads_2.unaligned_fastq"
        },
        {
          "id": "#getUnalignedReads_2.unaligned_fasta"
        },
        {
          "id": "#getUnalignedReads_2.mate_scrambled_sam"
        },
        {
          "id": "#getUnalignedReads_2.mate_ribosomal_sam"
        },
        {
          "id": "#getUnalignedReads_2.mate_regular_sam"
        },
        {
          "id": "#getUnalignedReads_2.mate_genome_sam"
        },
        {
          "id": "#getUnalignedReads_2.denovo_unaligned"
        }
      ],
      "sbg:x": 1594.1765152706823,
      "sbg:y": 31.95680256494705
    },
    {
      "id": "#MACHETE_DistantPE_devide_equally",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python DistantPE_Counter.py  -s sample_name   && mkdir tmp && for f in *Distant_PE_frequency.txt; do tail -n -1 $f > tmp_1.txt; tac $f | tail -n +2 | tac - > tmp_2.txt; sort -k1,1.1 -k1,1.2 -k2,2 tmp_2.txt > tmp_3.txt; cat tmp_1.txt tmp_3.txt > tmp/sorted_$f; done;",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/distantpe-divide-equally/1",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && mkdir tmp && for f in *Distant_PE_frequency.txt; do tail -n -1 $f > tmp_1.txt; tac $f | tail -n +2 | tac - > tmp_2.txt; sort -k1,1.1 -k1,1.2 -k2,2 tmp_2.txt > tmp_3.txt; cat tmp_1.txt tmp_3.txt > tmp/sorted_$f; done;\"\n\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\tcmd = \"\"\n    if($job.inputs.distant_pairs.metadata && $job.inputs.distant_pairs.metadata.sample_id)\n      cmd = \"-s \" + $job.inputs.distant_pairs.metadata.sample_id\n     \n    return cmd  \n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 1974.4706437167004,
        "id": "milos_jordanski/spachete-salzman-collaboration/distantpe-divide-equally/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520437795,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "DistantPE_Counter.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Aug  4 14:36:05 2015\n\n@author: Gillian\n\"\"\"\n\ndef writetofile(outfile, key, value):\n    outfile.write(\"%s\\t %s\" % (key, value) + \"\\n\")\n\n\nimport os\nimport glob\nimport argparse\n\nparser = argparse.ArgumentParser()\n#parser.add_argument(\"-d\", \"--Dir\", required=True, help=\"path to Far Junc parent directory\")\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"unique sample that identifies the file to count distant PE from\")\nparser.add_argument(\"-nf\", \"--number_of_files\", required=True, help=\"number_of_files_to_split\")\n\nparser.add_argument('-dp', '--distnatPairs', required=True, help=\"Distant pairs file\")\n\nargs = parser.parse_args()\n\nPairLibrary = {}  # documents frequency of that pair occurring\n\n#if args.Dir[-1] != \"/\":\n#    path = args.Dir + \"/DistantPEFiles/\"\n#else:\n#    path = args.Dir + \"DistantPEFiles/\"\n\n#outpath = path + args.stem + \"/\"\n#outpath = args.sample\n\n#os.chdir(path)\n\n#for name in glob.glob(os.path.join(path + \"*\" + args.stem + \"*_distant_pairs.txt\")):\n#    (path, filename) = os.path.split(name)\n#    f1 = open(name, mode=\"rU\")\n#    print name\n#    f1.next()\n#    f1.next()\n#   f1.next()\n\n#    for line_raw in f1:\n#        line = line_raw.strip().split(\"\\t\")\n#        read = Paired_Reads(line[1], line[2])\n\n#        if not read.bothPE in PairLibrary:\n#            PairLibrary[read.bothPE] = 1\n#        else:\n#            PairLibrary[read.bothPE] += 1\n\n#    f1.close()\n\nf1 = open(args.distnatPairs, mode=\"rU\")\nf1.next()\nf1.next()\nf1.next()\n\nfor line_raw in f1:\n    line = line_raw.strip().split(\"\\t\")\n    read_id = line[1] + \"\\t\" + line[2]\n    if not read_id in PairLibrary:\n        PairLibrary[read_id] = 1\n    else:\n        PairLibrary[read_id] += 1\n\nf1.close()\n\nprint len(PairLibrary)\nnumber_of_files_to_split = int(args.number_of_files)\nFileDict = {}\nfor file in range(number_of_files_to_split):\n    FileDict[file] = open(str(file) + \"_Distant_PE_frequency.txt\", mode=\"w\")\n\nnumber_of_chrom = {}\n\nnum_lines = len(PairLibrary)/number_of_files_to_split\ncount = 0\nfile_num = 0\nnumber_of_chrom[file_num] = {}\nfor key, value in PairLibrary.iteritems():\n    chr1 = key.split(\"\\t\")[0].split(\":\")[0]\n    chr2 = key.split(\"\\t\")[1].split(\":\")[0]\n\n    if count == num_lines and file_num < number_of_files_to_split - 1:\n        count = 0\n        file_num +=1\n        number_of_chrom[file_num] = {}\n\n    if chr1 not in number_of_chrom[file_num]:\n        number_of_chrom[file_num][chr1] = 0\n\n    if chr2 not in number_of_chrom[file_num]:\n        number_of_chrom[file_num][chr2] = 0\n\n    count += 1\n    writetofile(FileDict[file_num], key, value)\n\n\nfor file_num in number_of_chrom.keys():\n    #chromosome = key.split(\":\")[0]\n    file = FileDict[file_num]\n    file.write(str(len(number_of_chrom[file_num])) + \"\\n\")\n    file.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "distant_pairs": {
              "path": "/path/to/distant_pairs.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "sample_name"
              }
            },
            "number_of_files": 1
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520437767,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520437795,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 1 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#distant_pairs",
              "glob": "tmp/sorted_*Distant_PE_frequency.txt"
            },
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#distant_pe_frequency"
          }
        ],
        "label": "MACHETE_DistantPE_devide_equally",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 1 copied",
        "y": 354.48622552130155,
        "inputs": [
          {
            "sbg:altPrefix": "--number_of_files",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-nf"
            },
            "id": "#number_of_files",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-dp"
            },
            "id": "#distant_pairs",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "DistantPE_Counter.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520437767
      },
      "inputs": [
        {
          "id": "#MACHETE_DistantPE_devide_equally.number_of_files",
          "default": 26
        },
        {
          "id": "#MACHETE_DistantPE_devide_equally.distant_pairs",
          "source": [
            "#MACHETE_PEfinder_new.distant_pairs"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_DistantPE_devide_equally.distant_pe_frequency"
        }
      ],
      "sbg:x": 1974.4706437167004,
      "sbg:y": 354.48622552130155
    },
    {
      "id": "#Known_FarJuncJustNaiveReport",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python FarJuncJustNaiveReport.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/known-farjuncjustnaivereport/1",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 2760.824066607611,
        "id": "milos_jordanski/spachete-salzman-collaboration/known-farjuncjustnaivereport/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520438465,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "FarJuncJustNaiveReport.py",
                "fileContent": "import argparse\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\"-fusj1\", \"--fusionJuncSAM1\", required=True, help=\"unaligned reads1 to fusion junctions\")\nparser.add_argument(\"-fusj2\", \"--fusionJuncSAM2\", required=True, help=\"unaligned reads2 to fusion junctions\")\nparser.add_argument(\"-w\", \"--window\", required=True, help=\"# of bases needed on each side of the junction\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\n\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\n\nargs = parser.parse_args()\n\nwindow = int(args.window)\n\nf1_FarJunc = open(args.fusionJuncSAM1, mode = \"rB\")\nf2_FarJunc = open(args.fusionJuncSAM2, mode = \"rB\")\n\n\nprint \"opening FarJunc _1 file\"\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\nAllJunctions = {}\nAllFJRead1 = {}\n\nfor line_raw in f1_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n\n    FJ1read = ReadInfoFJ(line_raw)\n    if FJ1read.offset <= (150 - window) and (FJ1read.offset + FJ1read.NumOfBases) >= 150 + window:\n        goodlinecounter += 1\n\n        AllFJRead1[FJ1read.ID] = 0\n        if FJ1read.junction not in AllJunctions:\n            AllJunctions[FJ1read.junction] = 0\n            newjunccounter += 1\n\n\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\noverlapwithFJ1 = 0\n\nfor line_raw in f2_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n    FJ2read = ReadInfoFJ(line_raw)\n\n    #    if FJ1read.junction==\"chr1:S100A4:153516097:-|chr1:IFI16:158985661:+|strandcross\":\n    #        print \"ERROR AT LINE 409\"\n\n    # if R1 and R2 both in Far Junc, then add to FJ-FJ list\n    if FJ2read.ID in AllFJRead1:\n        overlapwithFJ1 += 1\n\n    else:\n        if FJ2read.offset <= (150 - window) and (FJ2read.offset + FJ2read.NumOfBases) >= 150 + window:\n            goodlinecounter += 1\n\n            if FJ2read.junction not in AllJunctions:\n                newjunccounter += 1\n                AllJunctions[FJ2read.junction] = 0\nf2_FarJunc.close()\n\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\nprint \"overlapping with FJ1 \" + str(overlapwithFJ1)\n\nfout = open(\"Known_fusions_\" + args.sample + \"_naive_report.txt\", mode=\"w\")\nfout.write(\"@Junction\\n\")\n\nfor key in AllJunctions:\n    fout.write(key + \"\\n\")"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "mode": "complete",
            "fusion_junction_sam": [
              {
                "path": "/path/to/fusion_junction_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/fusion_junction_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "window": 4
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520438446,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520438465,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 1 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*naive_report.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#just_naive_report"
          }
        ],
        "label": "Known_FarJuncJustNaiveReport",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 1 copied",
        "y": 854.8392719352407,
        "inputs": [
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "id": "#window",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-w"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "id": "#mode",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-m"
            },
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -fusj1 \" + inputs[i].path\n        else\n          cmd += \" -fusj2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#fusion_junction_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "FarJuncJustNaiveReport.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520438446
      },
      "inputs": [
        {
          "id": "#Known_FarJuncJustNaiveReport.window",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#Known_FarJuncJustNaiveReport.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#Known_FarJuncJustNaiveReport.fusion_junction_sam",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#Known_FarJuncJustNaiveReport.just_naive_report"
        }
      ],
      "sbg:x": 2760.824066607611,
      "sbg:y": 854.8392719352407
    },
    {
      "id": "#MACHETE_SplitFastaforBadFJ",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python SplitFastaforBadFJ.py",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/splitfastaforbadfj/1",
        "arguments": [],
        "x": 3789.118086123559,
        "id": "milos_jordanski/spachete-salzman-collaboration/splitfastaforbadfj/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520433735,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "SplitFastaforBadFJ.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Apr 15 11:32:18 2016\n\n@author: Gillian\n\"\"\"\n\nimport argparse\nimport os\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-i\", \"--inputFasta\", required=True, help=\"fasta file for processing\")\nparser.add_argument(\"-l\", \"--ReadLength\", required=True, help=\"length of R1 and R2\")\n#parser.add_argument(\"-o\", \"--outputDir\", required=True, help=\"directory for output\")\nargs = parser.parse_args()\n\n#if args.outputDir[-1] != \"/\":\n#    args.outputDir += \"/\"\n\nbasename = os.path.basename(args.inputFasta)\n\nif basename[-3:] == \".fa\":\n    basename = basename[:-3]\nif basename[-6:] == \".fasta\":\n    basename = basename[:-6]\n\nFastaOut_R1 = open(basename + \"_1.fa\", mode=\"w\")\nFastaOut_R2 = open(basename + \"_2.fa\", mode=\"w\")\n\nFastaFile = open(args.inputFasta, mode=\"rU\")\nfor line in FastaFile:\n    if line[0] == \">\":\n        FastaOut_R1.write(line.strip() + \"\\n\")\n        FastaOut_R2.write(line.strip() + \"\\n\")\n        continue\n\n    line = line.strip().replace(\"N\", \"\")\n    FastaOut_R1.write(line[0:int(args.ReadLength)] + \"\\n\")\n    FastaOut_R2.write(line[-int(args.ReadLength):] + \"\\n\")\n\nFastaFile.close()\nFastaOut_R1.close\nFastaOut_R2.close()"
              }
            ]
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "read_length": 4,
            "input_fasta": {
              "path": "/path/to/input_fasta.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433714,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520433735,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 3 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_2.fa",
              "sbg:metadata": {
                "paired_end": "2"
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_junction_fq2"
          },
          {
            "outputBinding": {
              "glob": "*_1.fa",
              "sbg:metadata": {
                "paired_end": "1"
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_junction_fq1"
          }
        ],
        "label": "MACHETE SplitFastaforBadFJ",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 3 copied",
        "y": 342.13325605469225,
        "inputs": [
          {
            "label": "Read length",
            "sbg:altPrefix": "--ReadLength",
            "sbg:category": "Input",
            "description": "Length of each contig in the output fasta files.",
            "sbg:toolDefaultValue": "40",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-l"
            },
            "id": "#read_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Input fasta file",
            "sbg:altPrefix": "--inputFasta",
            "sbg:category": "Input",
            "sbg:fileTypes": "FA, FASTA",
            "description": "Input fasta file which is going to be devided into two fasta files. First fasta file contains first read_length bases, while the second one contains last read_length bases of each FusionJunction",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-i"
            },
            "id": "#input_fasta",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "SplitFastaforBadFJ.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520433714
      },
      "inputs": [
        {
          "id": "#MACHETE_SplitFastaforBadFJ.read_length",
          "default": 40
        },
        {
          "id": "#MACHETE_SplitFastaforBadFJ.input_fasta",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate.far_junctions"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_SplitFastaforBadFJ.fusion_junction_fq2"
        },
        {
          "id": "#MACHETE_SplitFastaforBadFJ.fusion_junction_fq1"
        }
      ],
      "sbg:x": 3789.118086123559,
      "sbg:y": 342.13325605469225
    },
    {
      "id": "#MACHETE_Bowtie2_Indexer_Indels",
      "run": {
        "sbg:toolkitVersion": "2.3.4.1",
        "x": 4371.647296301638,
        "cwlVersion": "sbg:draft-2",
        "stdin": "",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 60000
          },
          "inputs": {
            "reference_or_index": {
              "path": "/test/human_g1k_v37_decoy_bowtie2-2.2.6.tar",
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "test"
              }
            },
            "large_index": false,
            "difference_cover_period": 6,
            "threads": 10,
            "disable_default_parameters": true
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520444443,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520444463,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 1 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520458480,
            "sbg:revision": 2,
            "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*.tar",
              "sbg:metadata": {
                "reference_genome": {
                  "class": "Expression",
                  "script": "{\n  var ref_name = $job.inputs.reference_or_index.path.split(\"/\").pop().replace(/\\.[^/.]+$/, \"\")\n//  var inherited_name = $job.inputs.reference_or_index.metadata.reference_genome\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\" ||\n      $job.inputs.reference_or_index.metadata == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == \"\"){\n    return ref_name\n  } else{\n    return $job.inputs.reference_or_index.metadata.reference_genome\n  }\n}",
                  "engine": "#cwl-js-engine"
                },
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Bowtie index archive",
            "sbg:fileTypes": "TAR",
            "description": "Archived Bowtie2 index files.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive"
          }
        ],
        "sbg:image_url": null,
        "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
        "sbg:cmdPreview": "echo 'Archive provided on the input, no indexing.'",
        "description": "Bowtie2 Indexer is a tool for indexing reference genomes of any size used in an alignment. It was built from `bowtie2-build` script and used for reference genome indexing aimed at assisting Bowtie2 in fast and memory-efficient alignment. It outputs an archive which consists of 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2. This archive constitutes the index and should be provided when aligning the reads (either with [Bowtie2 Aligner](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-aligner) or [TopHat2](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/tophat2)). \n\n###Common issues###\nNo issues have been reported.",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "label": "MACHETE Bowtie2-2.3.4.1 Indexer Indels",
        "successCodes": [],
        "sbg:createdOn": 1520444443,
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"bowtie2-build -f\"\n  } else {\n    return \"echo 'Archive provided on the input, no indexing.'\"\n  }\n}",
            "engine": "#cwl-js-engine"
          }
        ],
        "y": 348.25092921581347,
        "sbg:publisher": "sbg",
        "sbg:toolkit": "Bowtie2",
        "sbg:validationErrors": [],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  index_prefix = $job.inputs.reference_or_index.path.split('.').slice(0, $job.inputs.reference_or_index.path.split('.').length-1).join('.').replace(/^.*[\\\\\\/]/, '')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"./\".concat(index_prefix)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": false,
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var bt = \"bowtie2-2.3.4.1\"\n  var suffix_glob = \"\"\n  var ref = $job.inputs.reference_or_index.path\n  var ref_name = ref.split('/').pop(0).replace(/\\.[^/.]+$/, \"\")\n  var tar_name = ref_name.concat(\"_\", bt, '.tar')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  \n  if ($job.inputs.large_index) {\n    suffix_glob = \" ./*.bt2l*\"\n  } else {\n    suffix_glob = \" ./*.bt2*\"\n  }\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \" && tar -vcf \".concat(tar_name, suffix_glob)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": false,
            "position": 102
          }
        ],
        "sbg:categories": [
          "Alignment",
          "Indexing"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "temporaryFailCodes": [],
        "sbg:modifiedOn": 1520458480,
        "sbg:createdBy": "milos_jordanski",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:latestRevision": 2,
        "inputs": [
          {
            "label": "Number of threads",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--threads"
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Suffixes as fraction",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Advanced Options",
            "description": "The maximum number of suffixes allowed in a block, expressed as a fraction of the length of the reference. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes_as_fraction\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes_as_fraction) {\n      return \"--bmaxdivn \".concat($job.inputs.suffixes_as_fraction)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#suffixes_as_fraction",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "label": "Suffixes",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Advanced Options",
            "description": "The maximum number of suffixes allowed in a block. Allowing more suffixes per block makes indexing faster, but increases peak memory usage. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". Default (in terms of the \"Suffixes (as fraction)\" parameter) is 4. This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes) {\n      return \"--bmax \".concat($job.inputs.suffixes)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#suffixes",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "label": "Seed",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Basic Options",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.seed\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--seed\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#seed",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "label": "Rows to mark",
            "sbg:toolDefaultValue": "5",
            "sbg:category": "Basic Options",
            "description": "To map alignments back to positions on the reference sequences, it is necessary to annotate (\"mark\") some or all of the Burrows-Wheeler rows with their corresponding location on the genome. \"Rows to mark\" governs how many rows get marked: the indexer will mark every 2^(given number) rows. Marking more rows makes reference-position lookups faster, but requires more memory to hold the annotations at runtime. The default is 5 (every 32nd row is marked; for human genome, annotations occupy about 340 megabytes).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.rows_to_mark\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--offrate\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#rows_to_mark",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "label": "Reference/Index files",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FA, TAR",
            "description": "Reference sequence to which to align the reads. If tar bundle with indexes provided, this file would just be passed to the output.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return $job.inputs.reference_or_index.path\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": false,
              "sbg:cmdInclude": true,
              "streamable": false,
              "position": 100
            },
            "id": "#reference_or_index",
            "type": [
              "File"
            ],
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Packed representation",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Advanced Options",
            "description": "Use a packed (2-bits-per-nucleotide) representation for DNA strings. This saves memory but makes indexing 2-3 times slower. This is configured automatically by default; set \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.packed_representation\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.packed_representation){\n      return \"--packed \".concat($job.inputs.packed_representation)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#packed_representation",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Only bitpacked files",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Build only the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.only_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--justref\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#only_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Large index",
            "sbg:toolDefaultValue": "True",
            "sbg:category": "Basic Options",
            "description": "Force indexer to build a large index, even if the reference is less than ~ 4 billion nucleotides inlong.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.large_index\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--large-index\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#large_index",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Ftab lookup table size",
            "sbg:toolDefaultValue": "10",
            "sbg:category": "Basic Options",
            "description": "The ftab is the lookup table used to calculate an initial Burrows-Wheeler range with respect to the first given number of characters of the query. A larger number yields a larger lookup table but faster query times. The ftab has size 4^(given number + 1) bytes. The default setting is 10 (ftab is 4MB).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.ftab_lookup_table_size\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--ftabchars\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#ftab_lookup_table_size",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "label": "Discard bitpacked files",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Do not build the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.discard_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noref\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#discard_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Disable diff-cover sample",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Disable use of the difference-cover sample. Suffix sorting becomes quadratic-time in the worst case (where the worst case is an extremely repetitive reference).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_diff_cover_sample\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--nodc\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#disable_diff_cover_sample",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Disable default parameters",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Disable the default behavior whereby indexer automatically selects values for the parameters under \"Advanced Options\" according to available memory. Instead, user may specify values for those parameters. If memory is exhausted during indexing, an error message will be printed; it is up to the user to try new parameters.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_default_parameters\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noauto\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#disable_default_parameters",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Difference-cover period",
            "sbg:toolDefaultValue": "1024",
            "sbg:category": "Advanced Options",
            "description": "Set the period for the difference-cover sample. A larger period yields less memory overhead, but may make suffix sorting slower, especially if repeats are present. Must be a power of 2 no greater than 4096. This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.difference_cover_period\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.difference_cover_period) {\n      return \"--dcv \".concat($job.inputs.difference_cover_period)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#difference_cover_period",
            "type": [
              "null",
              "int"
            ],
            "required": false
          }
        ],
        "sbg:modifiedBy": "milos_jordanski",
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1",
            "diskSize": null
          },
          {
            "class": "sbg:MemRequirement",
            "value": 60000,
            "diskSize": null
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "r3.8xlarge"
          },
          {
            "class": "sbg:CPURequirement",
            "value": 1
          }
        ]
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.suffixes_as_fraction"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.suffixes"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.seed"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.rows_to_mark"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.reference_or_index",
          "source": [
            "#MACHETE_AddIndelsToFasta.filtered_fusion_junction_indels"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.packed_representation"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.only_bitpacked_files"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.large_index"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.ftab_lookup_table_size"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.discard_bitpacked_files"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.disable_diff_cover_sample"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.disable_default_parameters"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.difference_cover_period"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_Indexer_Indels.bowtie_index_archive"
        }
      ],
      "sbg:x": 4371.647296301638,
      "sbg:y": 348.25092921581347,
      "scatter": "#MACHETE_Bowtie2_Indexer_Indels.reference_or_index"
    },
    {
      "id": "#MACHETE_Split_Fastq_Files",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python split_fastq_files.py",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/split-fastq-files/1",
        "arguments": [],
        "x": 4537.76483339422,
        "id": "milos_jordanski/spachete-salzman-collaboration/split-fastq-files/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520433882,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "split_fastq_files.py",
                "fileContent": "import json\nimport subprocess\nimport sys\n\njob = \"\"\nwith open('job.json') as data_file:\n    job = json.load(data_file)\n\nif \"inputs\" in job and \"fastq_files\" in job[\"inputs\"]:\n    fastq_files = job[\"inputs\"][\"fastq_files\"]\nelse:\n    fastq_files = []\n\nif len(fastq_files)!=2:\n    fastq_files = []\n\noutput_files = []\nfor f in fastq_files:\n\n    f = f[0]\n    d = {'class': 'File'}\n\n    d['path'] = f[\"path\"]\n\n    if \"size\" in f:\n        d['size'] = f[\"size\"]\n\n    if \"contents\" in f:\n        d['contents'] = f[\"contents\"]\n\n    if \"name\" in f:\n        d['name'] = f[\"name\"]\n\n    if \"checksum\" in f:\n        d['checksum'] = f[\"checksum\"]\n\n    if \"location\" in f:\n        d['location'] = f[\"location\"]\n\n    if \"metadata\" in f:\n        d['metadata'] = f[\"metadata\"]\n\n    if \"secondaryFiles\" in f:\n        d['secondaryFiles'] = f[\"secondaryFiles\"]\n\n    output_files.append(d)\n\ndata = {}\nif output_files:\n    if \"metadata\" in output_files[0] and \"paired_end\" in output_files[0][\"metadata\"] and output_files[0][\"metadata\"][\"paired_end\"]==\"1\":\n        data['fastq_file_1'] = output_files[0]\n        data['fastq_file_2'] = output_files[1]\n    else:\n        data['fastq_file_1'] = output_files[1]\n        data['fastq_file_2'] = output_files[0]\n\nwith open('cwl.output.json', 'w') as w:\n    json.dump(data, w)"
              }
            ]
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "fastq_files": [
              {
                "path": "/path/to/fastq_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/fastq_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433867,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520433882,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 6 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#fastq_file_2"
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#fastq_file_1"
          }
        ],
        "label": "MACHETE Split Fastq Files",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 6 copied",
        "y": 356.6626978205408,
        "inputs": [
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#fastq_files",
            "required": false,
            "sbg:stageInput": null
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "split_fastq_files.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520433867
      },
      "inputs": [
        {
          "id": "#MACHETE_Split_Fastq_Files.fastq_files",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.unaligned_reads_only"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Split_Fastq_Files.fastq_file_2"
        },
        {
          "id": "#MACHETE_Split_Fastq_Files.fastq_file_1"
        }
      ],
      "sbg:x": 4537.76483339422,
      "sbg:y": 356.6626978205408
    },
    {
      "id": "#MACHETE_RegIndels_ClassIDFile",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python RegIndels_ClassIDFile.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/regindels-classidfile/1",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 5210.177361433915,
        "id": "milos_jordanski/spachete-salzman-collaboration/regindels-classidfile/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520439070,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "RegIndels_ClassIDFile.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 16 16:12:27 2015\n\n@author: Gillian\n\"\"\"\n# takes alignments from Indels and finds read partner.\n# all Far Junction and Scrambled junction reads where the alignment does not overlap the\n# Junction by args.window bp will be thrown out.\n\n\n################\n# Current categories\n# linear -- genomeGood, RegGood, JuncGood, RegIndelGood\n# anomaly -- genomeBad, RegBad, JuncBad, RegIndelBad\n##################\n\n\n\nimport argparse\nimport os\nimport glob\n\n\ndef AddToDict(inputtype, line_raw_comparison, line_raw_RI):\n    lineRI = ReadInfoRI(line_raw_RI)\n\n    if inputtype == \"RI\":  # if comparing Far Junc to Far Junc, they have to be identical\n        line2 = ReadInfoRI(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineRI.offset) + \"\\t\" + str(lineRI.MAPQ) + \"\\t\" + str(\n            lineRI.adjAS) + \"\\t\" + lineRI.NumN + \"\\t\" + str(lineRI.NumOfBases) + \"\\t\" + lineRI.junction[\n                                                                                        :-5] + \"\\t\" + lineRI.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        if lineRI.junction == line2.junction and lineRI.refstrand in [\"0\", \"16\"] and line2.refstrand in [\"0\",\n                                                                                                         \"16\"] and lineRI.refstrand != line2.refstrand:\n            IDfiletype = \"linear,RegIndelGood,\" + lineRI.junction[-4:]\n        else:\n            IDfiletype = \"anomaly,RegIndelBad,\" + lineRI.junction[-4:]\n\n        IDfile.write(\n            line_raw_RI.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"reg\":\n        line2 = ReadInfoJunc(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineRI.offset) + \"\\t\" + str(lineRI.MAPQ) + \"\\t\" + str(\n            lineRI.adjAS) + \"\\t\" + lineRI.NumN + \"\\t\" + str(lineRI.NumOfBases) + \"\\t\" + lineRI.junction[\n                                                                                        :-5] + \"\\t\" + lineRI.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"linear,RegGood,\" + lineRI.junction[-4:]\n\n        if lineRI.chr == line2.chr and lineRI.refstrand != line2.refstrand and lineRI.strand == line2.strand:\n            if lineRI.strand == \"+\":\n                if line2.loc_right < lineRI.loc_left or line2.loc_left > lineRI.loc_right:\n                    pass\n                else:\n                    IDfiletype = \"anomaly,RegBad,\" + lineRI.junction[-4:]\n            elif lineRI.strand == \"-\":\n                if line2.loc_right > lineRI.loc_left or line2.loc_left < lineRI.loc_right:\n                    pass\n                else:\n                    IDfiletype = \"anomaly,RegBad,\" + lineRI.junction[-4:]\n        else:\n            IDfiletype = \"anomaly,RegBad,\" + lineRI.junction[-4:]\n\n        IDfile.write(\n            line_raw_RI.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"junc\":  # if reg or junc read, then one side has to be within 100KB, and meets refstrand criteria below\n\n        line2 = ReadInfoJunc(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineRI.offset) + \"\\t\" + str(lineRI.MAPQ) + \"\\t\" + str(\n            lineRI.adjAS) + \"\\t\" + lineRI.NumN + \"\\t\" + str(lineRI.NumOfBases) + \"\\t\" + lineRI.junction[\n                                                                                        :-5] + \"\\t\" + lineRI.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"linear,JuncGood,\" + lineRI.junction[-4:]\n\n        if lineRI.chr == line2.chr and lineRI.refstrand != line2.refstrand and lineRI.strand == line2.strand and min(\n                line2.loc_left, line2.loc_right) < lineRI.loc_left and min(line2.loc_left,\n                                                                           line2.loc_right) < lineRI.loc_right and max(\n                line2.loc_left, line2.loc_right) > lineRI.loc_left and max(line2.loc_left,\n                                                                           line2.loc_right) > lineRI.loc_right:\n            pass\n        else:\n            IDfiletype = \"anomaly,JuncBad,\" + lineRI.junction[-4:]\n\n        IDfile.write(\n            line_raw_RI.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"genome\":  # comparing FJ to genome, has to be within 100Kbp, meet ref strand criteria (opp refstrand if + read, same refstrand if - read)\n\n        line2 = ReadInfoGenome(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineRI.offset) + \"\\t\" + str(lineRI.MAPQ) + \"\\t\" + str(\n            lineRI.adjAS) + \"\\t\" + lineRI.NumN + \"\\t\" + str(lineRI.NumOfBases) + \"\\t\" + lineRI.junction[\n                                                                                        :-5] + \"\\t\" + lineRI.refstrand\n        IDfileoutputR2 = str(line2.loc) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(line2.NumOfBases) + \"\\t\" + line2.chr + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"linear,genomeGood,\" + lineRI.junction[-4:]\n\n        if lineRI.chr == line2.chr and lineRI.refstrand != line2.refstrand and lineRI.strand == \"+\":\n            if line2.loc > lineRI.loc_right or line2.loc < lineRI.loc_left:\n                pass\n            else:\n                IDfiletype = \"anomaly,genomeBad,\" + lineRI.junction[-4:]\n        elif lineRI.chr == line2.chr and lineRI.refstrand != line2.refstrand and lineRI.strand == \"-\":\n            if line2.loc > lineRI.loc_left or line2.loc > lineRI.loc_right:\n                pass\n            else:\n                IDfiletype = \"anomaly,genomeBad,\" + lineRI.junction[-4:]\n        else:\n            IDfiletype = \"anomaly,genomeBad,\" + lineRI.junction[-4:]\n\n        IDfile.write(\n            line_raw_RI.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\nclass ReadInfoRI:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        if line[2][-4:-1] == \"DEL\":\n            #            print \"is a deletion\"\n            #            print line[2][-1:]\n            self.indel = -int(line[2][-1:])\n\n        if line[2][-4:-1] == \"INS\":\n            self.indel = int(line[2][-1:])\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr = JuncInfo[0]\n        self.loc_left = int(JuncInfo[2])\n        self.loc_right = int(JuncInfo[4])\n        self.strand = JuncInfo[6]\n\n\nclass ReadInfoGenome:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.chr = line[2]\n        self.loc = int(line[3])\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\nclass ReadInfoJunc:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.chr = line[2].split(\"|\")[0]\n        self.loc_left = int(line[2].replace(\":\", \"|\").split(\"|\")[2])\n        self.loc_right = int(line[2].replace(\":\", \"|\").split(\"|\")[4])\n        self.strand = line[2][-1]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\n# =========================================\n# start here\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name of file to generate report\")\n#parser.add_argument(\"-c\", \"--circReads\", required=True, help=\"path to circReads Dir\")\n#parser.add_argument(\"-i\", \"--origDir\", required=True, help=\"path to orig dir containing genome reads\")\nparser.add_argument(\"-w\", \"--window\", required=True, help=\"# of bases needed on each side of the junction\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\n\nparser.add_argument(\"-ris1\", \"--regularIndelsSAM1\", nargs='+', required=True, help=\"unaligned reads 1 from KNIFE aligned to regular indels\")\nparser.add_argument(\"-ris2\", \"--regularIndelsSAM2\", nargs='+', required=True, help=\"unaligned reads 2 from KNIFE aligned to regular indels\")\n\nparser.add_argument(\"-gens1\", \"--genomeSAM1\", required=True, help=\"read1 to genome\")\nparser.add_argument(\"-gens2\", \"--genomeSAM2\", required=True, help=\"read2 to genome\")\nparser.add_argument(\"-regs1\", \"--regularSAM1\", required=True, help=\"read1 to regular junction\")\nparser.add_argument(\"-regs2\", \"--regularSAM2\", required=True, help=\"read2 to regular junction\")\nparser.add_argument(\"-scrs1\", \"--scrambledSAM1\", required=True, help=\"read1 to ribosomal junction\")\nparser.add_argument(\"-scrs2\", \"--scrambledSAM2\", required=True, help=\"read2 to ribosomal junction\")\n\nargs = parser.parse_args()\nwindow = int(args.window)\n\n# f1 = open(\"/Users/Gillian/Desktop/sherlock/unaligned_ENCFF000HOC1_1.sam\", mode =\"rU\")\n# f2 = open(\"/Users/Gillian/Desktop/sherlock/20000_ENCFF000HOC2_1_genome_output.sam\", mode =\"rU\")\n\n\n\n#if args.origDir[-1] != \"/\":\n#    args.origDir += \"/\"\n#if args.circReads[-1] != \"/\":\n#    args.circReads += \"/\"\n\n#stem = args.stem\n\nregIndelfiles = []\nregfiles = []\ngenomefiles = []\njunctionfiles = []\n\n#for name in glob.glob(args.origDir + \"RegIndelAlignments/\" + stem + \"/*.sam\"):\n#    print name\n#    if \"All_\" not in name:\n#        regIndelfiles.append(name)\n        # Regfiles contains indel alignments for _1 and _2 files to indels 1-5\n\n#for name in glob.glob(os.path.join(args.origDir, \"genome/*\" + stem + \"*.sam\")):\n#    print name\n#    if \"sorted\" not in name:\n#        genomefiles.append(name)\n\n#for name in glob.glob(os.path.join(args.origDir, \"reg/*\" + stem + \"*.sam\")):\n#    print name\n#    if \"sorted\" not in name:\n#        regfiles.append(name)\n\n#for name in glob.glob(os.path.join(args.origDir, \"junction/*\" + stem + \"*.sam\")):\n#    print name\n#    if \"sorted\" not in name:\n#        junctionfiles.append(name)\n\n\n        # opening all files for a particular stem\n# print sorted(regIndelfiles)\n# print sorted(genomefiles)\n# print sorted(regfiles)\n# print sorted(junctionfiles)\n\n\n## concatenate all reg indels files into a single big indels file\n\n#regIndel1_list = sorted(regIndelfiles)[0:len(regIndelfiles) / 2]\n#regIndel2_list = sorted(regIndelfiles)[len(regIndelfiles) / 2:]\n\nregIndel1_list = args.regularIndelsSAM1\nregIndel2_list = args.regularIndelsSAM2\n\n\nIndelsReadIDs = {}\n\nfor name in regIndel1_list:\n    print \"reg1 indels\"\n    print name\n    f1 = open(name, mode=\"rU\")\n\n    for line in f1:\n        if line[0] == \"@\":\n            continue\n\n        read = ReadInfoRI(line)\n        # if the read overlaps the junction\n        if read.offset <= (150 - int(args.window) + read.indel) and read.offset + read.NumOfBases >= (\n                150 + int(args.window) + read.indel):\n\n            # if the read isn't in dictionary then add it\n            if read.ID not in IndelsReadIDs:\n                IndelsReadIDs[read.ID] = line\n            # if the read is in the dictionary, compare it to existing read. If AS is better, then replace existing read\n            else:\n                compareRead = ReadInfoRI(IndelsReadIDs[read.ID])\n                if int(compareRead.AS) >= int(read.AS):\n                    pass\n                else:\n                    IndelsReadIDs[read.ID] = line\n    f1.close()\n\n# write all distinct readIDs to an All_1_indels file\nfout_regIndel1 = open(\"All_\" + args.sample + \"_1_Regindels.sam\", mode=\"w\")\n\nfor key in IndelsReadIDs:\n    fout_regIndel1.write(IndelsReadIDs[key].strip() + \"\\n\")\n\nfout_regIndel1.close()\n\n## CLEAR Read IDs dictionary and do the same with FJ2 list\nIndelsReadIDs = {}\n\nfor name in regIndel2_list:\n    print \"regIndel2 indels\"\n    print name\n\n    f1 = open(name, mode=\"rU\")\n\n    for line in f1:\n        if line[0] == \"@\":\n            continue\n\n        read = ReadInfoRI(line)\n        # if the read overlaps the junction\n        if read.offset <= (150 - int(args.window) + read.indel) and read.offset + read.NumOfBases >= (\n                150 + int(args.window) + read.indel):\n\n            # if the read isn't in dictionary then add it\n            if read.ID not in IndelsReadIDs:\n                IndelsReadIDs[read.ID] = line\n            # if the read is in the dictionary, compare it to existing read. If AS is better, then replace existing read\n            else:\n                compareRead = ReadInfoRI(IndelsReadIDs[read.ID])\n                if int(compareRead.AS) >= int(read.AS):\n                    pass\n                else:\n                    IndelsReadIDs[read.ID] = line\n    f1.close()\n\n# write all distinct readIDs to an All_1_indels file\nfout_regIndel2 = open(\"All_\" + args.sample + \"_2_Regindels.sam\", mode=\"w\")\n\nfor key in IndelsReadIDs:\n    fout_regIndel2.write(IndelsReadIDs[key].strip() + \"\\n\")\nfout_regIndel2.close()\n\n## open big indels files\n\nf1_regIndel = open(\"All_\" + args.sample + \"_1_Regindels.sam\", mode=\"rB\")\nf2_regIndel = open(\"All_\" + args.sample + \"_2_Regindels.sam\", mode=\"rB\")\n\n# ID file ReadID and different buckets.\n# [0] = readID\n# [1] = R2 in genome\n# [2] = R2 in genome anomaly\n# [3] = reg\n# [4] = reg anom\n# [5] = junc\n# [6] = junc anom\n\n\n\nIDfile = open(args.sample + \"_temp_output_RegIndel.txt\", mode=\"w\")\nIDfile.write(\n    \"ID\\tclass\\tR1_offset\\tR1_MAPQ\\tR1_adjAS\\tR1_NumN\\tR1_Readlength\\tR1_JuncName\\tR1_strand\\tR2_offset\\tR2_MAPQ\\tR2_adjAS\\tR2_NumN\\tR2_Readlength\\tR2_JuncName\\tR2_strand\\n\")\n\n# populate all reads and junctions into separate dictionaries\nAllRegIndelRead1 = {}\nAllRegIndelRead2 = {}\n\n# AllJunctions = {}\n# genomeDict = {}  # for all these dictionaries, [0] = reg, [1] = anom\n# regDict = {}        # [2] = sum of AS, [3] = read length\n# juncDict = {}\n# unmappedDict= {} # start with all readIDs.  if a partner is seen, then remove from list.\n\n\n# populate AllFJRead1 dictionary - all read 1's from FarJunction alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening All_regIndels_1 file\"\n\nfor line_raw in f1_regIndel:\n    if line_raw[0] == \"@\":\n        continue\n\n    RegIndel1read = ReadInfoRI(line_raw)\n\n    if RegIndel1read.offset <= (150 + RegIndel1read.indel - window) and (\n        RegIndel1read.offset + RegIndel1read.NumOfBases) >= 150 + RegIndel1read.indel + window:\n        AllRegIndelRead1[RegIndel1read.ID] = [line_raw, 0]\n# if FJ1read.junction not in AllJunctions:\n#            AllJunctions[FJ1read.junction]=0\n#        AllJunctions[FJ1read.junction] +=1\n#        unmappedDict[AllRegRead1.ID] = AllRegRead1.junction\n\nf1_regIndel.close()\nIDfile.flush()\n\n# populate AllFJRead2 dictionary - all read 2's from FarJunc alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening All_regIndels _2 file\"\nfor line_raw in f2_regIndel:\n    if line_raw[0] == \"@\":\n        continue\n\n    RegIndel2read = ReadInfoRI(line_raw)\n\n    #    if FJ1read.junction==\"chr1:S100A4:153516097:-|chr1:IFI16:158985661:+|strandcross\":\n    #        print \"ERROR AT LINE 409\"\n\n    # if R1 and R2 both in Far Junc, then add to FJ-FJ list\n    if RegIndel2read.ID in AllRegIndelRead1:\n        # print \"found FJ read\"\n        # AllFJRead1[FJ2read.ID][1]=\"FJ\"\n        if RegIndel2read.offset <= (150 + RegIndel2read.indel - window) and (\n            RegIndel2read.offset + RegIndel2read.NumOfBases) >= 150 + RegIndel2read.indel + window and \\\n                        AllRegIndelRead1[RegIndel2read.ID][1] == 0:\n            AddToDict(\"RI\", line_raw, AllRegIndelRead1[RegIndel2read.ID][0])\n            AllRegIndelRead1[RegIndel2read.ID][1] = \"RI\"\n            #            if FJ2read.ID in unmappedDict:\n            #               del unmappedDict[FJ2read.ID]\n            # otherwise add to F2 read\n    else:\n        AllRegIndelRead2[RegIndel2read.ID] = [line_raw, 0]\n# unmappedDict[FJ2read.ID] = FJ2read.junction\n\n#    if RegIndel2read.junction not in AllJunctions:\n#        AllJunctions[FJ2read.junction]=0\n\n#    AllJunctions[FJ2read.junction]+=1\nf2_regIndel.close()\nIDfile.flush()\n\n#f2_genome = open(sorted(genomefiles)[1], mode=\"rB\")\nf2_genome = open(args.genomeSAM2, mode = \"rB\")\n\n# compare FJ read 1 to genome read 2\nprint \"comparing Indels to genome_2\"\nfor line_raw in f2_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g2read = ReadInfoGenome(line_raw)\n\n    if g2read.ID in AllRegIndelRead1 and AllRegIndelRead1[g2read.ID][1] == 0:\n        # print \"found genome R2\"+ g2read.ID\n        #        if g2read.ID in unmappedDict:\n        #            del unmappedDict[g2read.ID]\n        AddToDict(\"genome\", line_raw, AllRegIndelRead1[g2read.ID][0])\n        AllRegIndelRead1[g2read.ID][1] = \"genome\"\n\nf2_genome.close()\nIDfile.flush()\n\n#f1_genome = open(sorted(genomefiles)[0], mode=\"rB\")\nf1_genome = open(args.genomeSAM1, mode = \"rB\")\n\n# compare FJ read 2 to genome read 1\nprint \"comparing Indels to genome_1\"\n\nfor line_raw in f1_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g1read = ReadInfoGenome(line_raw)\n\n    if g1read.ID in AllRegIndelRead2 and AllRegIndelRead2[g1read.ID][1] == 0:\n        # print \"found genome R1\"+g1read.ID\n        #        if g1read.ID in unmappedDict:\n        #            del unmappedDict[g1read.ID]\n        AddToDict(\"genome\", line_raw, AllRegIndelRead2[g1read.ID][0])\n        AllRegIndelRead2[g1read.ID][1] = \"genome\"\nf1_genome.close()\nIDfile.flush()\n#\n\n\n#f2_reg = open(sorted(regfiles)[1], mode=\"rB\")\nf2_reg = open(args.regularSAM2, mode = \"rB\")\n\n# compare FJ read 1 to reg read 2\nprint \"comparing Indels to reg_2\"\n\nfor line_raw in f2_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg2read = ReadInfoJunc(line_raw)\n\n    if reg2read.offset <= (150 - window) and (reg2read.offset + reg2read.NumOfBases) >= (150 + window):\n        if reg2read.ID in AllRegIndelRead1 and AllRegIndelRead1[reg2read.ID][1] == 0:\n            # print \"found reg R2: \" + reg2read.ID\n            #            if reg2read.ID in unmappedDict:\n            #                del unmappedDict[reg2read.ID]\n            AddToDict(\"reg\", line_raw, AllRegIndelRead1[reg2read.ID][0])\n            AllRegIndelRead1[reg2read.ID][1] = \"reg\"\nf2_reg.close()\nIDfile.flush()\n\n#f1_reg = open(sorted(regfiles)[0], mode=\"rB\")\nf1_reg = open(args.regularSAM1, mode = \"rB\")\n\n# compare FJ read 2 to reg read 1\nprint \"comparing Indels to reg_1\"\n\nfor line_raw in f1_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg1read = ReadInfoJunc(line_raw)\n\n    if reg1read.offset <= (150 - window) and (reg1read.offset + reg1read.NumOfBases) >= (150 + window):\n        if reg1read.ID in AllRegIndelRead2 and AllRegIndelRead2[reg1read.ID][1] == 0:\n            # print \"found reg R1: \" + reg1read.ID\n            #            if reg1read.ID in unmappedDict:\n            #                del unmappedDict[reg1read.ID]\n            AddToDict(\"reg\", line_raw, AllRegIndelRead2[reg1read.ID][0])\n            AllRegIndelRead2[reg1read.ID][1] = \"reg\"\nf1_reg.close()\nIDfile.flush()\n\n#f2_junc = open(sorted(junctionfiles)[1], mode=\"rB\")\nf2_junc = open(args.scrambledSAM2, mode = \"rB\")\n\n# compare FJ read 1 to junc read 2\nprint \"comparing Indels to junc_2\"\n\nfor line_raw in f2_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc2read = ReadInfoJunc(line_raw)\n\n    if junc2read.offset <= (150 - window) and (junc2read.offset + junc2read.NumOfBases) >= (150 + window):\n        if junc2read.ID in AllRegIndelRead1 and AllRegIndelRead1[junc2read.ID][1] == 0:\n            #            print \"found junc R2: \" + junc2read.ID\n            #            if junc2read.ID in unmappedDict:\n            #                del unmappedDict[junc2read.ID]\n            AddToDict(\"junc\", line_raw, AllRegIndelRead1[junc2read.ID][0])\n            AllRegIndelRead1[junc2read.ID][1] = \"junc\"\nf2_junc.close()\nIDfile.flush()\n\n#f1_junc = open(sorted(junctionfiles)[0], mode=\"rB\")\nf1_junc = open(args.scrambledSAM1, mode = \"rB\")\n\n# compare FJ read 2 to junc read 1\nprint \"comparing Indels to junc_1\"\n\nfor line_raw in f1_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc1read = ReadInfoJunc(line_raw)\n\n    if junc1read.offset <= (150 - window) and (junc1read.offset + junc1read.NumOfBases) >= (150 + window):\n        if junc1read.ID in AllRegIndelRead2 and AllRegIndelRead2[junc1read.ID][1] == 0:\n            #            print \"found junc R1: \" + junc1read.ID\n            #            if junc1read.ID in unmappedDict:\n            #                del unmappedDict[junc1read.ID]\n            AddToDict(\"junc\", line_raw, AllRegIndelRead2[junc1read.ID][0])\n            AllRegIndelRead2[junc1read.ID][1] = \"junc\"\nf1_junc.close()\nIDfile.flush()\n\nIDfile.close()\n\n#\n\n\n#############################################################################\n## This section of code takes the written ID file above (temp_IDs_STEM.txt) and\n## removes duplicate entries of genome and reg. The same readID may be found\n## in both libraries and would both be in the ID file.\n## The new ID file removes duplicates and only keeps the readID with the\n## best alignment score.\n#tempIDfile = open(args.circReads + \"ids/\" + stem + \"_temp_output_RegIndel.txt\", mode=\"rU\")\n#newIDfile = open(args.circReads + \"ids/\" + stem + \"_output_RegIndel.txt\", mode=\"w\")\n\ntempIDfile = open(args.sample + \"_temp_output_RegIndel.txt\", mode=\"rU\")\nnewIDfile = open(args.sample + \"__output_RegIndel.txt\", mode=\"w\")\n\n\n##grep col 2 for \"genom\", \"Regular\" or \"RegAnomaly\". if not found ,write to\n## new file immediately.\n## if found, feed into dictionary (key=readID, value= entire line from temp file)\n## if duplicate entry, then compare R2 AS. if AS larger, then replace\n## value with new value from new R2\n## at completion of file, write entire dictionary into new ID file.\n\nGenomeAndRegReadIDs = {}\n\nfor line in tempIDfile:\n    line = line.strip()\n    if \"unaligned\" in line:\n        continue\n\n    if \"Unmapped\" in line:\n        continue\n\n    readID = line.split(\"\\t\")[0]\n    classID = line.split(\"\\t\")[1]\n    AS_new = line.split(\"\\t\")[11]\n\n    if \"genom\" in classID:\n        ## if readID has been seen previously, then replace value in dictionary\n        ## only if AS is greater.\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"Regular\" in classID:\n        ## do the same if reg\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"RegAnomaly\" in classID:\n        ## do the same if reg anomaly\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    else:\n        ## if not genome/genome anomaly/ reg/ reg anomaly then\n        ## write line directly in new file.\n        newIDfile.write(line + \"\\n\")\n\nfor entry in GenomeAndRegReadIDs:\n    newIDfile.write(GenomeAndRegReadIDs[entry] + \"\\n\")\n\ntempIDfile.close()\nnewIDfile.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "mode": "complete",
            "overlap": 1,
            "regular_sam": [
              {
                "path": "/path/to/regular_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/regular_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "regularIndelsSAM1": [
              {
                "path": "/path/to/regularIndelsSAM1-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/regularIndelsSAM1-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "genome_sam": [
              {
                "path": "/path/to/genome_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/genome_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "regularIndelsSAM2": [
              {
                "path": "/path/to/regularIndelsSAM2-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/regularIndelsSAM2-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "scrambled_sam": [
              {
                "path": "/path/to/scrambled_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/scrambled_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520439045,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520439070,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 9 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*temp_output_RegIndel.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#temp_output_RegIndel"
          },
          {
            "outputBinding": {
              "glob": "*__output_RegIndel.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#output_RegIndel"
          },
          {
            "outputBinding": {
              "glob": "All*.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#all_regindels_sam"
          }
        ],
        "label": "MACHETE RegIndels_ClassIDFile",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 9 copied",
        "y": 358.6626928409747,
        "inputs": [
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrs1 \" + inputs[i].path\n        else\n          cmd += \" -scrs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#scrambled_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regs1 \" + inputs[i].path\n        else\n          cmd += \" -regs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#regular_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--regularIndelsSAM1",
            "required": false,
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-ris2",
              "itemSeparator": " "
            },
            "id": "#regularIndelsSAM2",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "--regularIndelsSAM1",
            "required": false,
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-ris1",
              "itemSeparator": " "
            },
            "id": "#regularIndelsSAM1",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "id": "#overlap",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-w"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "id": "#mode",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-m"
            },
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gens1 \" + inputs[i].path\n        else\n          cmd += \" -gens2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#genome_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "RegIndels_ClassIDFile.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520439045
      },
      "inputs": [
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.scrambled_sam",
          "source": [
            "#getUnalignedReads_1.mate_scrambled_sam",
            "#getUnalignedReads_2.mate_scrambled_sam"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.regular_sam",
          "source": [
            "#getUnalignedReads_2.mate_regular_sam",
            "#getUnalignedReads_1.mate_regular_sam"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.regularIndelsSAM2",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.regularIndelsSAM1",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.genome_sam",
          "source": [
            "#getUnalignedReads_1.mate_genome_sam",
            "#getUnalignedReads_2.mate_genome_sam"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.temp_output_RegIndel"
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.output_RegIndel"
        },
        {
          "id": "#MACHETE_RegIndels_ClassIDFile.all_regindels_sam"
        }
      ],
      "sbg:x": 5210.177361433915,
      "sbg:y": 358.6626928409747
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "echo 'Archive provided on the input, no indexing.'",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  index_prefix = $job.inputs.reference_or_index.path.split('.').slice(0, $job.inputs.reference_or_index.path.split('.').length-1).join('.').replace(/^.*[\\\\\\/]/, '')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"./\".concat(index_prefix)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": false,
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var bt = \"bowtie2-2.3.4.1\"\n  var suffix_glob = \"\"\n  var ref = $job.inputs.reference_or_index.path\n  var ref_name = ref.split('/').pop(0).replace(/\\.[^/.]+$/, \"\")\n  var tar_name = ref_name.concat(\"_\", bt, '.tar')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  \n  if ($job.inputs.large_index) {\n    suffix_glob = \" ./*.bt2l*\"\n  } else {\n    suffix_glob = \" ./*.bt2*\"\n  }\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \" && tar -vcf \".concat(tar_name, suffix_glob)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": false,
            "position": 102
          }
        ],
        "x": 2440.0590642397847,
        "sbg:categories": [
          "Alignment",
          "Indexing"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520458480,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 60000
          },
          "inputs": {
            "reference_or_index": {
              "path": "/test/human_g1k_v37_decoy_bowtie2-2.2.6.tar",
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "test"
              }
            },
            "large_index": false,
            "difference_cover_period": 6,
            "threads": 10,
            "disable_default_parameters": true
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520444443,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520444463,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 1 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520458480,
            "sbg:revision": 2,
            "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Indexer Far Junctions",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
        "y": 370.89798817958905,
        "inputs": [
          {
            "label": "Number of threads",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--threads"
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Suffixes as fraction",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Advanced Options",
            "description": "The maximum number of suffixes allowed in a block, expressed as a fraction of the length of the reference. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes_as_fraction\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes_as_fraction) {\n      return \"--bmaxdivn \".concat($job.inputs.suffixes_as_fraction)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#suffixes_as_fraction",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suffixes",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Advanced Options",
            "description": "The maximum number of suffixes allowed in a block. Allowing more suffixes per block makes indexing faster, but increases peak memory usage. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". Default (in terms of the \"Suffixes (as fraction)\" parameter) is 4. This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes) {\n      return \"--bmax \".concat($job.inputs.suffixes)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#suffixes",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Basic Options",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.seed\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--seed\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Rows to mark",
            "sbg:toolDefaultValue": "5",
            "sbg:category": "Basic Options",
            "description": "To map alignments back to positions on the reference sequences, it is necessary to annotate (\"mark\") some or all of the Burrows-Wheeler rows with their corresponding location on the genome. \"Rows to mark\" governs how many rows get marked: the indexer will mark every 2^(given number) rows. Marking more rows makes reference-position lookups faster, but requires more memory to hold the annotations at runtime. The default is 5 (every 32nd row is marked; for human genome, annotations occupy about 340 megabytes).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.rows_to_mark\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--offrate\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#rows_to_mark",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Reference/Index files",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FA, TAR",
            "description": "Reference sequence to which to align the reads. If tar bundle with indexes provided, this file would just be passed to the output.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return $job.inputs.reference_or_index.path\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": false,
              "sbg:cmdInclude": true,
              "streamable": false,
              "position": 100
            },
            "id": "#reference_or_index",
            "type": [
              "File"
            ],
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Packed representation",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Advanced Options",
            "description": "Use a packed (2-bits-per-nucleotide) representation for DNA strings. This saves memory but makes indexing 2-3 times slower. This is configured automatically by default; set \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.packed_representation\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.packed_representation){\n      return \"--packed \".concat($job.inputs.packed_representation)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#packed_representation",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Only bitpacked files",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Build only the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.only_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--justref\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#only_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Large index",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Force indexer to build a large index, even if the reference is less than ~ 4 billion nucleotides inlong.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.large_index\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--large-index\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#large_index",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ftab lookup table size",
            "sbg:toolDefaultValue": "10",
            "sbg:category": "Basic Options",
            "description": "The ftab is the lookup table used to calculate an initial Burrows-Wheeler range with respect to the first given number of characters of the query. A larger number yields a larger lookup table but faster query times. The ftab has size 4^(given number + 1) bytes. The default setting is 10 (ftab is 4MB).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.ftab_lookup_table_size\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--ftabchars\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#ftab_lookup_table_size",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Discard bitpacked files",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Do not build the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.discard_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noref\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#discard_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable diff-cover sample",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Disable use of the difference-cover sample. Suffix sorting becomes quadratic-time in the worst case (where the worst case is an extremely repetitive reference).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_diff_cover_sample\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--nodc\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#disable_diff_cover_sample",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable default parameters",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Disable the default behavior whereby indexer automatically selects values for the parameters under \"Advanced Options\" according to available memory. Instead, user may specify values for those parameters. If memory is exhausted during indexing, an error message will be printed; it is up to the user to try new parameters.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_default_parameters\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noauto\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#disable_default_parameters",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Difference-cover period",
            "sbg:toolDefaultValue": "1024",
            "sbg:category": "Advanced Options",
            "description": "Set the period for the difference-cover sample. A larger period yields less memory overhead, but may make suffix sorting slower, especially if repeats are present. Must be a power of 2 no greater than 4096. This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.difference_cover_period\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.difference_cover_period) {\n      return \"--dcv \".concat($job.inputs.difference_cover_period)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#difference_cover_period",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie2 Indexer is a tool for indexing reference genomes of any size used in an alignment. It was built from `bowtie2-build` script and used for reference genome indexing aimed at assisting Bowtie2 in fast and memory-efficient alignment. It outputs an archive which consists of 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2. This archive constitutes the index and should be provided when aligning the reads (either with [Bowtie2 Aligner](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-aligner) or [TopHat2](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/tophat2)). \n\n###Common issues###\nNo issues have been reported.",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "milos_jordanski",
        "outputs": [
          {
            "outputBinding": {
              "glob": "*.tar",
              "sbg:metadata": {
                "reference_genome": {
                  "class": "Expression",
                  "script": "{\n  var ref_name = $job.inputs.reference_or_index.path.split(\"/\").pop().replace(/\\.[^/.]+$/, \"\")\n//  var inherited_name = $job.inputs.reference_or_index.metadata.reference_genome\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\" ||\n      $job.inputs.reference_or_index.metadata == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == \"\"){\n    return ref_name\n  } else{\n    return $job.inputs.reference_or_index.metadata.reference_genome\n  }\n}",
                  "engine": "#cwl-js-engine"
                },
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Bowtie index archive",
            "sbg:fileTypes": "TAR",
            "description": "Archived Bowtie2 index files.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"bowtie2-build -f\"\n  } else {\n    return \"echo 'Archive provided on the input, no indexing.'\"\n  }\n}",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 2,
        "sbg:revision": 2,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1",
            "diskSize": null
          },
          {
            "class": "sbg:MemRequirement",
            "value": 60000,
            "diskSize": null
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "r3.8xlarge"
          },
          {
            "class": "sbg:CPURequirement",
            "value": 1
          }
        ],
        "sbg:createdOn": 1520444443
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.suffixes_as_fraction"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.suffixes"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.rows_to_mark"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.reference_or_index",
          "source": [
            "#MACHETE_combine_fasta_files.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.packed_representation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.only_bitpacked_files"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.large_index"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.ftab_lookup_table_size"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.discard_bitpacked_files"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.disable_diff_cover_sample"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.disable_default_parameters"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.difference_cover_period"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.bowtie_index_archive"
        }
      ],
      "sbg:x": 2440.0590642397847,
      "sbg:y": 370.89798817958905
    },
    {
      "id": "#MACHETE_parse_to_remove_known_fusions",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python parse_to_remove_FJ.py",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/parse-to-remove-known-fusions/2",
        "arguments": [],
        "x": 2902.1966959635424,
        "id": "milos_jordanski/spachete-salzman-collaboration/parse-to-remove-known-fusions/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520526367,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "parse_to_remove_FJ.py",
                "fileContent": "import re\nimport os\nimport subprocess\nimport csv\nimport pickle\n\n# to call this:\n# cmd=\"python {INSTALLDIR}/parse_to_remove_FJ.py --stem {STEM} --outputdir {OUTPUT_DIR}\".format(INSTALLDIR=INSTALLDIR, STEM=STEM, OUTPUT_DIR=OUTPUT_DIR)\n\n\n# python parse_to_remove_FJ.py --stem\nimport argparse\n\nparser = argparse.ArgumentParser()\n#parser.add_argument(\"--stem\", help=\"STEM string\")\n#parser.add_argument(\"--outputdir\", help=\"OUTPUT_DIR\")\n\nparser.add_argument(\"-nr\", \"--naive_report\", help=\"Naive Report\", required = True)\nparser.add_argument(\"-kf\", \"--known_fusions\", help=\"Far junctions per chromosome\", required = True)\n\nargs = parser.parse_args()\n\n\n\nrawcsv = csv.reader(open(args.naive_report), delimiter='\\t')\nfirst_column = []\nfor row in rawcsv:\n    first_column.append(row[0])\n# drop first element as it's from the header:\nfirst_column.pop(0)\n\nfirst_col_with_arrow = [(\">\" + x) for x in first_column]\n\nknown_fusions = pickle.load(open(args.known_fusions, \"rb\"))\n\nintersection = set(known_fusions.keys()).intersection(set(first_col_with_arrow))\n\nwith open(\"known_fusions_junctions.fa\", \"w\") as f:\n    for junc_id in intersection:\n        f.write(junc_id + \"\\n\")\n        f.write(known_fusions[junc_id] + \"\\n\")"
              }
            ]
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "naive_report": {
              "path": "/path/to/naive_report.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "known_fusions": {
              "path": "/path/to/chr_fusion_junctions.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520438519,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520438541,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 4 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520526367,
            "sbg:revision": 2,
            "sbg:revisionNotes": "known_fusions type pickle",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#naive_report",
              "glob": "*.fa"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#filtered_known_fusion_junction"
          }
        ],
        "label": "MACHETE_parse_to_remove_known_fusions",
        "sbg:latestRevision": 2,
        "sbg:revisionNotes": "known_fusions type pickle",
        "y": 865.0354003906252,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-nr"
            },
            "id": "#naive_report",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "required": false,
            "sbg:fileTypes": "PICKLE, pickle",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-kf",
              "itemSeparator": " "
            },
            "id": "#known_fusions",
            "type": [
              "null",
              "File"
            ],
            "sbg:stageInput": "link"
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/parse-to-remove-known-fusions/2",
        "successCodes": [],
        "stdout": "",
        "sbg:createdOn": 1520438519,
        "baseCommand": [
          "python",
          "parse_to_remove_FJ.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "r3.8xlarge"
          }
        ]
      },
      "inputs": [
        {
          "id": "#MACHETE_parse_to_remove_known_fusions.naive_report",
          "source": [
            "#Known_FarJuncJustNaiveReport.just_naive_report"
          ]
        },
        {
          "id": "#MACHETE_parse_to_remove_known_fusions.known_fusions",
          "source": [
            "#known_fusions"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_parse_to_remove_known_fusions.filtered_known_fusion_junction"
        }
      ],
      "sbg:x": 2902.1966959635424,
      "sbg:y": 865.0354003906252
    },
    {
      "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "echo 'Archive provided on the input, no indexing.'",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  index_prefix = $job.inputs.reference_or_index.path.split('.').slice(0, $job.inputs.reference_or_index.path.split('.').length-1).join('.').replace(/^.*[\\\\\\/]/, '')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"./\".concat(index_prefix)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": false,
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var bt = \"bowtie2-2.3.4.1\"\n  var suffix_glob = \"\"\n  var ref = $job.inputs.reference_or_index.path\n  var ref_name = ref.split('/').pop(0).replace(/\\.[^/.]+$/, \"\")\n  var tar_name = ref_name.concat(\"_\", bt, '.tar')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  \n  if ($job.inputs.large_index) {\n    suffix_glob = \" ./*.bt2l*\"\n  } else {\n    suffix_glob = \" ./*.bt2*\"\n  }\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \" && tar -vcf \".concat(tar_name, suffix_glob)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": false,
            "position": 102
          }
        ],
        "x": 3214.1969401041674,
        "sbg:categories": [
          "Alignment",
          "Indexing"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520458480,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 60000
          },
          "inputs": {
            "reference_or_index": {
              "path": "/test/human_g1k_v37_decoy_bowtie2-2.2.6.tar",
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "test"
              }
            },
            "large_index": false,
            "difference_cover_period": 6,
            "threads": 10,
            "disable_default_parameters": true
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520444443,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520444463,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 1 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520458480,
            "sbg:revision": 2,
            "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Indexer Known Filtered FJ",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
        "y": 870.7639160156253,
        "inputs": [
          {
            "label": "Number of threads",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--threads"
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Suffixes as fraction",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Advanced Options",
            "description": "The maximum number of suffixes allowed in a block, expressed as a fraction of the length of the reference. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes_as_fraction\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes_as_fraction) {\n      return \"--bmaxdivn \".concat($job.inputs.suffixes_as_fraction)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#suffixes_as_fraction",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suffixes",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Advanced Options",
            "description": "The maximum number of suffixes allowed in a block. Allowing more suffixes per block makes indexing faster, but increases peak memory usage. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". Default (in terms of the \"Suffixes (as fraction)\" parameter) is 4. This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes) {\n      return \"--bmax \".concat($job.inputs.suffixes)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#suffixes",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Basic Options",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.seed\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--seed\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Rows to mark",
            "sbg:toolDefaultValue": "5",
            "sbg:category": "Basic Options",
            "description": "To map alignments back to positions on the reference sequences, it is necessary to annotate (\"mark\") some or all of the Burrows-Wheeler rows with their corresponding location on the genome. \"Rows to mark\" governs how many rows get marked: the indexer will mark every 2^(given number) rows. Marking more rows makes reference-position lookups faster, but requires more memory to hold the annotations at runtime. The default is 5 (every 32nd row is marked; for human genome, annotations occupy about 340 megabytes).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.rows_to_mark\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--offrate\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#rows_to_mark",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Reference/Index files",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FA, TAR",
            "description": "Reference sequence to which to align the reads. If tar bundle with indexes provided, this file would just be passed to the output.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return $job.inputs.reference_or_index.path\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": false,
              "sbg:cmdInclude": true,
              "streamable": false,
              "position": 100
            },
            "id": "#reference_or_index",
            "type": [
              "File"
            ],
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Packed representation",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Advanced Options",
            "description": "Use a packed (2-bits-per-nucleotide) representation for DNA strings. This saves memory but makes indexing 2-3 times slower. This is configured automatically by default; set \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.packed_representation\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.packed_representation){\n      return \"--packed \".concat($job.inputs.packed_representation)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#packed_representation",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Only bitpacked files",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Build only the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.only_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--justref\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#only_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Large index",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Force indexer to build a large index, even if the reference is less than ~ 4 billion nucleotides inlong.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.large_index\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--large-index\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#large_index",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ftab lookup table size",
            "sbg:toolDefaultValue": "10",
            "sbg:category": "Basic Options",
            "description": "The ftab is the lookup table used to calculate an initial Burrows-Wheeler range with respect to the first given number of characters of the query. A larger number yields a larger lookup table but faster query times. The ftab has size 4^(given number + 1) bytes. The default setting is 10 (ftab is 4MB).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.ftab_lookup_table_size\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--ftabchars\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#ftab_lookup_table_size",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Discard bitpacked files",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Do not build the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.discard_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noref\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#discard_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable diff-cover sample",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Disable use of the difference-cover sample. Suffix sorting becomes quadratic-time in the worst case (where the worst case is an extremely repetitive reference).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_diff_cover_sample\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--nodc\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#disable_diff_cover_sample",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable default parameters",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Disable the default behavior whereby indexer automatically selects values for the parameters under \"Advanced Options\" according to available memory. Instead, user may specify values for those parameters. If memory is exhausted during indexing, an error message will be printed; it is up to the user to try new parameters.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_default_parameters\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noauto\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#disable_default_parameters",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Difference-cover period",
            "sbg:toolDefaultValue": "1024",
            "sbg:category": "Advanced Options",
            "description": "Set the period for the difference-cover sample. A larger period yields less memory overhead, but may make suffix sorting slower, especially if repeats are present. Must be a power of 2 no greater than 4096. This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.difference_cover_period\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.difference_cover_period) {\n      return \"--dcv \".concat($job.inputs.difference_cover_period)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#difference_cover_period",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie2 Indexer is a tool for indexing reference genomes of any size used in an alignment. It was built from `bowtie2-build` script and used for reference genome indexing aimed at assisting Bowtie2 in fast and memory-efficient alignment. It outputs an archive which consists of 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2. This archive constitutes the index and should be provided when aligning the reads (either with [Bowtie2 Aligner](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-aligner) or [TopHat2](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/tophat2)). \n\n###Common issues###\nNo issues have been reported.",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "milos_jordanski",
        "outputs": [
          {
            "outputBinding": {
              "glob": "*.tar",
              "sbg:metadata": {
                "reference_genome": {
                  "class": "Expression",
                  "script": "{\n  var ref_name = $job.inputs.reference_or_index.path.split(\"/\").pop().replace(/\\.[^/.]+$/, \"\")\n//  var inherited_name = $job.inputs.reference_or_index.metadata.reference_genome\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\" ||\n      $job.inputs.reference_or_index.metadata == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == \"\"){\n    return ref_name\n  } else{\n    return $job.inputs.reference_or_index.metadata.reference_genome\n  }\n}",
                  "engine": "#cwl-js-engine"
                },
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Bowtie index archive",
            "sbg:fileTypes": "TAR",
            "description": "Archived Bowtie2 index files.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"bowtie2-build -f\"\n  } else {\n    return \"echo 'Archive provided on the input, no indexing.'\"\n  }\n}",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 2,
        "sbg:revision": 2,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1",
            "diskSize": null
          },
          {
            "class": "sbg:MemRequirement",
            "value": 60000,
            "diskSize": null
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "r3.8xlarge"
          },
          {
            "class": "sbg:CPURequirement",
            "value": 1
          }
        ],
        "sbg:createdOn": 1520444443
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.suffixes_as_fraction"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.suffixes"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.seed"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.rows_to_mark"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.reference_or_index",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate_Known.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.packed_representation"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.only_bitpacked_files"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.large_index"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.ftab_lookup_table_size"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.discard_bitpacked_files"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.disable_diff_cover_sample"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.disable_default_parameters"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.difference_cover_period"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.bowtie_index_archive"
        }
      ],
      "sbg:x": 3214.1969401041674,
      "sbg:y": 870.7639160156253
    },
    {
      "id": "#Determine_mode",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python mode.py -fq fastq_files-string-value-1.fq fastq_files-string-value-2.fq -t 9  -s SAMPLE",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/determine-mode/1",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tfastq_files = [].concat($job.inputs.fastq_files)\n\tif (fastq_files[0] && fastq_files[0].metadata && fastq_files[0].metadata.sample_id)\n    {\n    \treturn \"-s \" + fastq_files[0].metadata.sample_id\n    }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 20
          }
        ],
        "x": 362,
        "id": "milos_jordanski/spachete-salzman-collaboration/determine-mode/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520537016,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "mode.py",
                "fileContent": "import argparse\n\ndef main():\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument(\"-fq\", \"--fastq\", required=True, nargs='+', help=\"fastq files\")\n    parser.add_argument('-s', '--sample', help='base name used in alignment output files', required=True)\n    parser.add_argument('-t', '--ntrim', help='ntrim used in denovo pipeline', type=int, required=True)\n\n    args = parser.parse_args()\n\n    fq_1 = args.fastq[0]\n\n    mode1 = \"complete\"\n    mode2 = \"complete\"\n\n    first = True\n\n    with open(fq_1, \"r\") as f1:\n        line1 = f1.readline()\n        read = f1.readline()\n\n    minReadLen = args.ntrim + 8\n\n    with open(args.sample + \"_readlength.txt\", \"w\") as f_write:\n        f_write.write(str(len(read.strip())))\n\n    print len(read.strip())\n    #if len(read.strip()) < minReadLen and len(args.fastq) < 2:\n    #    raise Exception(\"Single-end read! Read lenght is less then \" + str(minReadLen) + \". Exit!\\n\")\n\n    #if len(read.strip()) < minReadLen:\n    #    raise Exception(\"Read lenght is less then \" + str(minReadLen) + \". Exit!\\n\")\n\n    if len(args.fastq) < 2:\n        raise Exception(\"Single-end sample\\n\")\n\n    fq_2 = args.fastq[1]\n\n    with open(fq_2, \"r\") as f2:\n        line2 = f2.readline()\n    \n    read_id_1 = line1.strip().split(\"\\t\")[0].split(\" \")[0]\n    read_id_2 = line2.strip().split(\"\\t\")[0].split(\" \")[0]\n\n    print read_id_1\n    print read_id_2\n\n    if read_id_1 == read_id_2:\n        print mode1\n        with open(\"output_mode.txt\", \"w\") as f:\n            f.write(mode1)\n            quit(0)\n\n    if read_id_1[-2:] == \"/1\" or read_id_1[-2:] == \".1\":\n        mode1 = \"appended\"\n    elif read_id_1[-2:] == \"/2\" or read_id_1[-2:] == \".2\":\n        mode1 = \"appended\"\n        first=False\n\n\n\n    if first:\n        if read_id_2[-2:] == \"/2\" or read_id_2[-2:] == \".2\":\n            mode2 = \"appended\"\n    elif read_id_2[-2:] == \"/1\" or read_id_2[-2:] == \".1\":\n            mode2 = \"appended\"\n\n    if mode1 == mode2:\n        with open(\"output_mode.txt\", \"w\") as f:\n            print mode1\n            f.write(mode1)\n    else: raise Exception(\"Fastq files do not have the same mode\")\n\nif __name__ == '__main__':\n    main()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "ntrim": 9,
            "fastq_files": [
              {
                "path": "fastq_files-string-value-1.fq",
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "SAMPLE"
                }
              },
              {
                "path": "fastq_files-string-value-2.fq"
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520537001,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520537016,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 14 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#fastq_files",
              "glob": "*_readlength.txt"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#read_length"
          },
          {
            "outputBinding": {
              "glob": "output_mode.txt",
              "loadContents": true,
              "outputEval": {
                "class": "Expression",
                "script": "{\n\tif($self)\n    {\n    \treturn $self[0].contents\n    }\n \treturn \"\" \n}",
                "engine": "#cwl-js-engine"
              }
            },
            "type": [
              "null",
              "string"
            ],
            "id": "#output_mode"
          },
          {
            "outputBinding": {
              "glob": "*_readlength.txt",
              "loadContents": true,
              "outputEval": {
                "class": "Expression",
                "script": "{\n\tif($self)\n    {\n    \tread_length  = parseInt($self[0].contents)\n        if(read_length < 70)\n        {\n        \treturn 8\n        }\n      \telse\n        {\n        \treturn 13\n        }\n    }\n \treturn \"\" \n}",
                "engine": "#cwl-js-engine"
              }
            },
            "type": [
              "null",
              "int"
            ],
            "id": "#junction_overlap"
          }
        ],
        "label": "Determine mode",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 14 copied",
        "y": 115.015625,
        "inputs": [
          {
            "sbg:altPrefix": "--ntrim",
            "type": [
              "null",
              "int"
            ],
            "id": "#ntrim",
            "required": false
          },
          {
            "sbg:altPrefix": "--fastq",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#fastq_files",
            "required": false,
            "sbg:stageInput": "link"
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/determine-mode/1",
        "successCodes": [],
        "stdout": "",
        "sbg:createdOn": 1520537001,
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  \toutput = \"\"\n\text = [].concat($job.inputs.fastq_files)[0].path.split('.').pop()\n     \n\tif(ext == 'gz' || ext == 'GZ')\n    {\t\n      \tfastq_list = [].concat($job.inputs.fastq_files)\n      \toutput = \"gunzip -f \" \n        for(i=0; i < fastq_list.length; i++)\n        \toutput += fastq_list[i].path.split('/').pop() + \" \"\n        output += \"&& python mode.py -fq \"\n        \n        for(i=0; i < fastq_list.length; i++){\n          \t\n          \tfile_name = fastq_list[i].path.split('/').pop().split(\".\").slice(0, -1).join(\".\")\n        \toutput += file_name + \" \"\n        }\n      \t\n      \tif($job.inputs.ntrim)\n        {\n        \toutput += \"-t \" + $job.inputs.ntrim\n        }\n    }\n  \telse\n    {\n    \toutput = \"python mode.py -fq \"\n        fastq_list = [].concat($job.inputs.fastq_files)\n        for(i=0; i < fastq_list.length; i++){\n          \t\n          \tfile_name = fastq_list[i].path.split('/').pop()\n            output += file_name + \" \"\n        }\n      \tif($job.inputs.ntrim)\n        {\n        \toutput += \"-t \" + $job.inputs.ntrim\n        }\n    }\n\treturn output\n}",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ]
      },
      "inputs": [
        {
          "id": "#Determine_mode.ntrim",
          "default": 50
        },
        {
          "id": "#Determine_mode.fastq_files",
          "source": [
            "#fastq_files"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#Determine_mode.read_length"
        },
        {
          "id": "#Determine_mode.output_mode"
        },
        {
          "id": "#Determine_mode.junction_overlap"
        }
      ],
      "sbg:x": 362,
      "sbg:y": 115.015625
    },
    {
      "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ",
      "run": {
        "sbg:toolkitVersion": "2.3.4.1",
        "x": 3241.588512946996,
        "cwlVersion": "sbg:draft-2",
        "stdin": "",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 60000
          },
          "inputs": {
            "reference_or_index": {
              "path": "/test/human_g1k_v37_decoy_bowtie2-2.2.6.tar",
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "test"
              }
            },
            "large_index": false,
            "difference_cover_period": 6,
            "threads": 10,
            "disable_default_parameters": true
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520444443,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520444463,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 1 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520458480,
            "sbg:revision": 2,
            "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*.tar",
              "sbg:metadata": {
                "reference_genome": {
                  "class": "Expression",
                  "script": "{\n  var ref_name = $job.inputs.reference_or_index.path.split(\"/\").pop().replace(/\\.[^/.]+$/, \"\")\n//  var inherited_name = $job.inputs.reference_or_index.metadata.reference_genome\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\" ||\n      $job.inputs.reference_or_index.metadata == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == \"\"){\n    return ref_name\n  } else{\n    return $job.inputs.reference_or_index.metadata.reference_genome\n  }\n}",
                  "engine": "#cwl-js-engine"
                },
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Bowtie index archive",
            "sbg:fileTypes": "TAR",
            "description": "Archived Bowtie2 index files.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive"
          }
        ],
        "sbg:image_url": null,
        "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
        "sbg:cmdPreview": "echo 'Archive provided on the input, no indexing.'",
        "description": "Bowtie2 Indexer is a tool for indexing reference genomes of any size used in an alignment. It was built from `bowtie2-build` script and used for reference genome indexing aimed at assisting Bowtie2 in fast and memory-efficient alignment. It outputs an archive which consists of 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2. This archive constitutes the index and should be provided when aligning the reads (either with [Bowtie2 Aligner](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-aligner) or [TopHat2](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/tophat2)). \n\n###Common issues###\nNo issues have been reported.",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "label": "Bowtie2-2.3.4.1 Indexer",
        "successCodes": [],
        "sbg:createdOn": 1520444443,
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"bowtie2-build -f\"\n  } else {\n    return \"echo 'Archive provided on the input, no indexing.'\"\n  }\n}",
            "engine": "#cwl-js-engine"
          }
        ],
        "y": 359.6627138564595,
        "sbg:publisher": "sbg",
        "sbg:toolkit": "Bowtie2",
        "sbg:validationErrors": [],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  index_prefix = $job.inputs.reference_or_index.path.split('.').slice(0, $job.inputs.reference_or_index.path.split('.').length-1).join('.').replace(/^.*[\\\\\\/]/, '')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"./\".concat(index_prefix)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": false,
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var bt = \"bowtie2-2.3.4.1\"\n  var suffix_glob = \"\"\n  var ref = $job.inputs.reference_or_index.path\n  var ref_name = ref.split('/').pop(0).replace(/\\.[^/.]+$/, \"\")\n  var tar_name = ref_name.concat(\"_\", bt, '.tar')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  \n  if ($job.inputs.large_index) {\n    suffix_glob = \" ./*.bt2l*\"\n  } else {\n    suffix_glob = \" ./*.bt2*\"\n  }\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \" && tar -vcf \".concat(tar_name, suffix_glob)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": false,
            "position": 102
          }
        ],
        "sbg:categories": [
          "Alignment",
          "Indexing"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "temporaryFailCodes": [],
        "sbg:modifiedOn": 1520458480,
        "sbg:createdBy": "milos_jordanski",
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "sbg:latestRevision": 2,
        "inputs": [
          {
            "label": "Number of threads",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--threads"
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Suffixes as fraction",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Advanced Options",
            "description": "The maximum number of suffixes allowed in a block, expressed as a fraction of the length of the reference. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes_as_fraction\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes_as_fraction) {\n      return \"--bmaxdivn \".concat($job.inputs.suffixes_as_fraction)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#suffixes_as_fraction",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "label": "Suffixes",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Advanced Options",
            "description": "The maximum number of suffixes allowed in a block. Allowing more suffixes per block makes indexing faster, but increases peak memory usage. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". Default (in terms of the \"Suffixes (as fraction)\" parameter) is 4. This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes) {\n      return \"--bmax \".concat($job.inputs.suffixes)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#suffixes",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "label": "Seed",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Basic Options",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.seed\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--seed\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#seed",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "label": "Rows to mark",
            "sbg:toolDefaultValue": "5",
            "sbg:category": "Basic Options",
            "description": "To map alignments back to positions on the reference sequences, it is necessary to annotate (\"mark\") some or all of the Burrows-Wheeler rows with their corresponding location on the genome. \"Rows to mark\" governs how many rows get marked: the indexer will mark every 2^(given number) rows. Marking more rows makes reference-position lookups faster, but requires more memory to hold the annotations at runtime. The default is 5 (every 32nd row is marked; for human genome, annotations occupy about 340 megabytes).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.rows_to_mark\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--offrate\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#rows_to_mark",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "label": "Reference/Index files",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FA, TAR",
            "description": "Reference sequence to which to align the reads. If tar bundle with indexes provided, this file would just be passed to the output.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return $job.inputs.reference_or_index.path\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": false,
              "sbg:cmdInclude": true,
              "streamable": false,
              "position": 100
            },
            "id": "#reference_or_index",
            "type": [
              "File"
            ],
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Packed representation",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Advanced Options",
            "description": "Use a packed (2-bits-per-nucleotide) representation for DNA strings. This saves memory but makes indexing 2-3 times slower. This is configured automatically by default; set \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.packed_representation\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.packed_representation){\n      return \"--packed \".concat($job.inputs.packed_representation)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#packed_representation",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Only bitpacked files",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Build only the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.only_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--justref\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#only_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Large index",
            "sbg:toolDefaultValue": "True",
            "sbg:category": "Basic Options",
            "description": "Force indexer to build a large index, even if the reference is less than ~ 4 billion nucleotides inlong.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.large_index\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--large-index\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#large_index",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Ftab lookup table size",
            "sbg:toolDefaultValue": "10",
            "sbg:category": "Basic Options",
            "description": "The ftab is the lookup table used to calculate an initial Burrows-Wheeler range with respect to the first given number of characters of the query. A larger number yields a larger lookup table but faster query times. The ftab has size 4^(given number + 1) bytes. The default setting is 10 (ftab is 4MB).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.ftab_lookup_table_size\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--ftabchars\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#ftab_lookup_table_size",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "label": "Discard bitpacked files",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Do not build the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.discard_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noref\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#discard_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Disable diff-cover sample",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Disable use of the difference-cover sample. Suffix sorting becomes quadratic-time in the worst case (where the worst case is an extremely repetitive reference).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_diff_cover_sample\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--nodc\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#disable_diff_cover_sample",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Disable default parameters",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Disable the default behavior whereby indexer automatically selects values for the parameters under \"Advanced Options\" according to available memory. Instead, user may specify values for those parameters. If memory is exhausted during indexing, an error message will be printed; it is up to the user to try new parameters.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_default_parameters\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noauto\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#disable_default_parameters",
            "type": [
              "null",
              "boolean"
            ],
            "required": false
          },
          {
            "label": "Difference-cover period",
            "sbg:toolDefaultValue": "1024",
            "sbg:category": "Advanced Options",
            "description": "Set the period for the difference-cover sample. A larger period yields less memory overhead, but may make suffix sorting slower, especially if repeats are present. Must be a power of 2 no greater than 4096. This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.difference_cover_period\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.difference_cover_period) {\n      return \"--dcv \".concat($job.inputs.difference_cover_period)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#difference_cover_period",
            "type": [
              "null",
              "int"
            ],
            "required": false
          }
        ],
        "sbg:modifiedBy": "milos_jordanski",
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1",
            "diskSize": null
          },
          {
            "class": "sbg:MemRequirement",
            "value": 60000,
            "diskSize": null
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "r3.8xlarge"
          },
          {
            "class": "sbg:CPURequirement",
            "value": 1
          }
        ]
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.suffixes_as_fraction"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.suffixes"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.seed"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.rows_to_mark"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.reference_or_index",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.packed_representation"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.only_bitpacked_files"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.large_index"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.ftab_lookup_table_size"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.discard_bitpacked_files"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.disable_diff_cover_sample"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.disable_default_parameters"
        },
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.difference_cover_period"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_Indexer_Filtered_FJ.bowtie_index_archive"
        }
      ],
      "sbg:x": 3241.588512946996,
      "sbg:y": 359.6627138564595
    },
    {
      "id": "#SplitFastaforBadFJ",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python SplitFastaforBadFJ.py",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/splitfastaforbadfj/1",
        "arguments": [],
        "x": 3898.915308311409,
        "id": "milos_jordanski/spachete-salzman-collaboration/splitfastaforbadfj/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520433735,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "SplitFastaforBadFJ.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Apr 15 11:32:18 2016\n\n@author: Gillian\n\"\"\"\n\nimport argparse\nimport os\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-i\", \"--inputFasta\", required=True, help=\"fasta file for processing\")\nparser.add_argument(\"-l\", \"--ReadLength\", required=True, help=\"length of R1 and R2\")\n#parser.add_argument(\"-o\", \"--outputDir\", required=True, help=\"directory for output\")\nargs = parser.parse_args()\n\n#if args.outputDir[-1] != \"/\":\n#    args.outputDir += \"/\"\n\nbasename = os.path.basename(args.inputFasta)\n\nif basename[-3:] == \".fa\":\n    basename = basename[:-3]\nif basename[-6:] == \".fasta\":\n    basename = basename[:-6]\n\nFastaOut_R1 = open(basename + \"_1.fa\", mode=\"w\")\nFastaOut_R2 = open(basename + \"_2.fa\", mode=\"w\")\n\nFastaFile = open(args.inputFasta, mode=\"rU\")\nfor line in FastaFile:\n    if line[0] == \">\":\n        FastaOut_R1.write(line.strip() + \"\\n\")\n        FastaOut_R2.write(line.strip() + \"\\n\")\n        continue\n\n    line = line.strip().replace(\"N\", \"\")\n    FastaOut_R1.write(line[0:int(args.ReadLength)] + \"\\n\")\n    FastaOut_R2.write(line[-int(args.ReadLength):] + \"\\n\")\n\nFastaFile.close()\nFastaOut_R1.close\nFastaOut_R2.close()"
              }
            ]
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "read_length": 4,
            "input_fasta": {
              "path": "/path/to/input_fasta.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433714,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520433735,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 3 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_2.fa",
              "sbg:metadata": {
                "paired_end": "2"
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_junction_fq2"
          },
          {
            "outputBinding": {
              "glob": "*_1.fa",
              "sbg:metadata": {
                "paired_end": "1"
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_junction_fq1"
          }
        ],
        "label": "MACHETE SplitFastaforBadFJ Known",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 3 copied",
        "y": 864.1816515486373,
        "inputs": [
          {
            "label": "Read length",
            "sbg:altPrefix": "--ReadLength",
            "sbg:category": "Input",
            "description": "Length of each contig in the output fasta files.",
            "sbg:toolDefaultValue": "40",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-l"
            },
            "id": "#read_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Input fasta file",
            "sbg:altPrefix": "--inputFasta",
            "sbg:category": "Input",
            "sbg:fileTypes": "FA, FASTA",
            "description": "Input fasta file which is going to be devided into two fasta files. First fasta file contains first read_length bases, while the second one contains last read_length bases of each FusionJunction",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-i"
            },
            "id": "#input_fasta",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "SplitFastaforBadFJ.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520433714
      },
      "inputs": [
        {
          "id": "#SplitFastaforBadFJ.read_length",
          "default": 40
        },
        {
          "id": "#SplitFastaforBadFJ.input_fasta",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate_Known.far_junctions"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#SplitFastaforBadFJ.fusion_junction_fq2"
        },
        {
          "id": "#SplitFastaforBadFJ.fusion_junction_fq1"
        }
      ],
      "sbg:x": 3898.915308311409,
      "sbg:y": 864.1816515486373
    },
    {
      "id": "#Bowtie2_2_3_4_1_Indexer",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "echo 'Archive provided on the input, no indexing.'",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  index_prefix = $job.inputs.reference_or_index.path.split('.').slice(0, $job.inputs.reference_or_index.path.split('.').length-1).join('.').replace(/^.*[\\\\\\/]/, '')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"./\".concat(index_prefix)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": false,
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var bt = \"bowtie2-2.3.4.1\"\n  var suffix_glob = \"\"\n  var ref = $job.inputs.reference_or_index.path\n  var ref_name = ref.split('/').pop(0).replace(/\\.[^/.]+$/, \"\")\n  var tar_name = ref_name.concat(\"_\", bt, '.tar')\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  \n  if ($job.inputs.large_index) {\n    suffix_glob = \" ./*.bt2l*\"\n  } else {\n    suffix_glob = \" ./*.bt2*\"\n  }\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \" && tar -vcf \".concat(tar_name, suffix_glob)\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": false,
            "position": 102
          }
        ],
        "x": 4324.706578040222,
        "sbg:categories": [
          "Alignment",
          "Indexing"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1-indexer/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520458480,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 60000
          },
          "inputs": {
            "reference_or_index": {
              "path": "/test/human_g1k_v37_decoy_bowtie2-2.2.6.tar",
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "test"
              }
            },
            "large_index": false,
            "difference_cover_period": 6,
            "threads": 10,
            "disable_default_parameters": true
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520444443,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520444463,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 1 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520458480,
            "sbg:revision": 2,
            "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Indexer Known Indels",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "bowtie2-2.3.4.1 output tar file",
        "y": 850.6067597879498,
        "inputs": [
          {
            "label": "Number of threads",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--threads"
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Suffixes as fraction",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Advanced Options",
            "description": "The maximum number of suffixes allowed in a block, expressed as a fraction of the length of the reference. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes_as_fraction\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes_as_fraction) {\n      return \"--bmaxdivn \".concat($job.inputs.suffixes_as_fraction)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#suffixes_as_fraction",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suffixes",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Advanced Options",
            "description": "The maximum number of suffixes allowed in a block. Allowing more suffixes per block makes indexing faster, but increases peak memory usage. Setting this option overrides any previous setting for \"Suffixes\", or \"Suffixes as fraction\". Default (in terms of the \"Suffixes (as fraction)\" parameter) is 4. This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.suffixes\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.suffixes) {\n      return \"--bmax \".concat($job.inputs.suffixes)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#suffixes",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Basic Options",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.seed\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--seed\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Rows to mark",
            "sbg:toolDefaultValue": "5",
            "sbg:category": "Basic Options",
            "description": "To map alignments back to positions on the reference sequences, it is necessary to annotate (\"mark\") some or all of the Burrows-Wheeler rows with their corresponding location on the genome. \"Rows to mark\" governs how many rows get marked: the indexer will mark every 2^(given number) rows. Marking more rows makes reference-position lookups faster, but requires more memory to hold the annotations at runtime. The default is 5 (every 32nd row is marked; for human genome, annotations occupy about 340 megabytes).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.rows_to_mark\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--offrate\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#rows_to_mark",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Reference/Index files",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FA, TAR",
            "description": "Reference sequence to which to align the reads. If tar bundle with indexes provided, this file would just be passed to the output.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return $job.inputs.reference_or_index.path\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": false,
              "sbg:cmdInclude": true,
              "streamable": false,
              "position": 100
            },
            "id": "#reference_or_index",
            "type": [
              "File"
            ],
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Packed representation",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Advanced Options",
            "description": "Use a packed (2-bits-per-nucleotide) representation for DNA strings. This saves memory but makes indexing 2-3 times slower. This is configured automatically by default; set \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.packed_representation\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.packed_representation){\n      return \"--packed \".concat($job.inputs.packed_representation)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#packed_representation",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Only bitpacked files",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Build only the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.only_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--justref\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#only_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Large index",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Force indexer to build a large index, even if the reference is less than ~ 4 billion nucleotides inlong.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.large_index\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--large-index\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#large_index",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ftab lookup table size",
            "sbg:toolDefaultValue": "10",
            "sbg:category": "Basic Options",
            "description": "The ftab is the lookup table used to calculate an initial Burrows-Wheeler range with respect to the first given number of characters of the query. A larger number yields a larger lookup table but faster query times. The ftab has size 4^(given number + 1) bytes. The default setting is 10 (ftab is 4MB).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.ftab_lookup_table_size\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--ftabchars\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#ftab_lookup_table_size",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Discard bitpacked files",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Do not build the NAME.3.bt2 and NAME.4.bt2 portions of the index, which contain a bitpacked version of the reference sequences and are used for paired-end alignment.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.discard_bitpacked_files\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noref\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#discard_bitpacked_files",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable diff-cover sample",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Disable use of the difference-cover sample. Suffix sorting becomes quadratic-time in the worst case (where the worst case is an extremely repetitive reference).",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_diff_cover_sample\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--nodc\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#disable_diff_cover_sample",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable default parameters",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Basic Options",
            "description": "Disable the default behavior whereby indexer automatically selects values for the parameters under \"Advanced Options\" according to available memory. Instead, user may specify values for those parameters. If memory is exhausted during indexing, an error message will be printed; it is up to the user to try new parameters.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.disable_default_parameters\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    return \"--noauto\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#disable_default_parameters",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Difference-cover period",
            "sbg:toolDefaultValue": "1024",
            "sbg:category": "Advanced Options",
            "description": "Set the period for the difference-cover sample. A larger period yields less memory overhead, but may make suffix sorting slower, especially if repeats are present. Must be a power of 2 no greater than 4096. This is configured automatically by default; use \"Disable default parameters\" to configure manually.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var param = $job.inputs.difference_cover_period\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if ( param && (ref_ext == \"FASTA\" || ref_ext == \"FA\")){\n    if ($job.inputs.disable_default_parameters && $job.inputs.difference_cover_period) {\n      return \"--dcv \".concat($job.inputs.difference_cover_period)\n    }\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": false
            },
            "id": "#difference_cover_period",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie2 Indexer is a tool for indexing reference genomes of any size used in an alignment. It was built from `bowtie2-build` script and used for reference genome indexing aimed at assisting Bowtie2 in fast and memory-efficient alignment. It outputs an archive which consists of 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2. This archive constitutes the index and should be provided when aligning the reads (either with [Bowtie2 Aligner](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-aligner) or [TopHat2](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/tophat2)). \n\n###Common issues###\nNo issues have been reported.",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "milos_jordanski",
        "outputs": [
          {
            "outputBinding": {
              "glob": "*.tar",
              "sbg:metadata": {
                "reference_genome": {
                  "class": "Expression",
                  "script": "{\n  var ref_name = $job.inputs.reference_or_index.path.split(\"/\").pop().replace(/\\.[^/.]+$/, \"\")\n//  var inherited_name = $job.inputs.reference_or_index.metadata.reference_genome\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\" ||\n      $job.inputs.reference_or_index.metadata == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == null ||\n      $job.inputs.reference_or_index.metadata.reference_genome == \"\"){\n    return ref_name\n  } else{\n    return $job.inputs.reference_or_index.metadata.reference_genome\n  }\n}",
                  "engine": "#cwl-js-engine"
                },
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Bowtie index archive",
            "sbg:fileTypes": "TAR",
            "description": "Archived Bowtie2 index files.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var ref_ext = $job.inputs.reference_or_index.path.split('.').pop(0).toUpperCase()\n  if (ref_ext == \"FASTA\" || ref_ext == \"FA\"){\n    return \"bowtie2-build -f\"\n  } else {\n    return \"echo 'Archive provided on the input, no indexing.'\"\n  }\n}",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 2,
        "sbg:revision": 2,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1",
            "diskSize": null
          },
          {
            "class": "sbg:MemRequirement",
            "value": 60000,
            "diskSize": null
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "r3.8xlarge"
          },
          {
            "class": "sbg:CPURequirement",
            "value": 1
          }
        ],
        "sbg:createdOn": 1520444443
      },
      "inputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.threads",
          "default": 8
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.suffixes_as_fraction"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.suffixes"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.seed"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.rows_to_mark"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.reference_or_index",
          "source": [
            "#MACHETE_AddIndelsToFasta_Known.filtered_fusion_junction_indels"
          ]
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.packed_representation"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.only_bitpacked_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.large_index"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.ftab_lookup_table_size"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.discard_bitpacked_files"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.disable_diff_cover_sample"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.disable_default_parameters"
        },
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.difference_cover_period"
        }
      ],
      "outputs": [
        {
          "id": "#Bowtie2_2_3_4_1_Indexer.bowtie_index_archive"
        }
      ],
      "sbg:x": 4324.706578040222,
      "sbg:y": 850.6067597879498,
      "scatter": "#Bowtie2_2_3_4_1_Indexer.reference_or_index"
    },
    {
      "id": "#MACHETE_Split_Fastq_Files_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python split_fastq_files.py",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/split-fastq-files/1",
        "arguments": [],
        "x": 4460.000811038977,
        "id": "milos_jordanski/spachete-salzman-collaboration/split-fastq-files/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520433882,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "split_fastq_files.py",
                "fileContent": "import json\nimport subprocess\nimport sys\n\njob = \"\"\nwith open('job.json') as data_file:\n    job = json.load(data_file)\n\nif \"inputs\" in job and \"fastq_files\" in job[\"inputs\"]:\n    fastq_files = job[\"inputs\"][\"fastq_files\"]\nelse:\n    fastq_files = []\n\nif len(fastq_files)!=2:\n    fastq_files = []\n\noutput_files = []\nfor f in fastq_files:\n\n    f = f[0]\n    d = {'class': 'File'}\n\n    d['path'] = f[\"path\"]\n\n    if \"size\" in f:\n        d['size'] = f[\"size\"]\n\n    if \"contents\" in f:\n        d['contents'] = f[\"contents\"]\n\n    if \"name\" in f:\n        d['name'] = f[\"name\"]\n\n    if \"checksum\" in f:\n        d['checksum'] = f[\"checksum\"]\n\n    if \"location\" in f:\n        d['location'] = f[\"location\"]\n\n    if \"metadata\" in f:\n        d['metadata'] = f[\"metadata\"]\n\n    if \"secondaryFiles\" in f:\n        d['secondaryFiles'] = f[\"secondaryFiles\"]\n\n    output_files.append(d)\n\ndata = {}\nif output_files:\n    if \"metadata\" in output_files[0] and \"paired_end\" in output_files[0][\"metadata\"] and output_files[0][\"metadata\"][\"paired_end\"]==\"1\":\n        data['fastq_file_1'] = output_files[0]\n        data['fastq_file_2'] = output_files[1]\n    else:\n        data['fastq_file_1'] = output_files[1]\n        data['fastq_file_2'] = output_files[0]\n\nwith open('cwl.output.json', 'w') as w:\n    json.dump(data, w)"
              }
            ]
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "fastq_files": [
              {
                "path": "/path/to/fastq_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/fastq_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433867,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520433882,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 6 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#fastq_file_2"
          },
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#fastq_file_1"
          }
        ],
        "label": "MACHETE Split Fastq Files Known",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 6 copied",
        "y": 844.7244258806614,
        "inputs": [
          {
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#fastq_files",
            "required": false,
            "sbg:stageInput": null
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "split_fastq_files.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520433867
      },
      "inputs": [
        {
          "id": "#MACHETE_Split_Fastq_Files_Known.fastq_files",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.unaligned_reads_only"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Split_Fastq_Files_Known.fastq_file_2"
        },
        {
          "id": "#MACHETE_Split_Fastq_Files_Known.fastq_file_1"
        }
      ],
      "sbg:x": 4460.000811038977,
      "sbg:y": 844.7244258806614
    },
    {
      "id": "#MACHETE_parse_to_remove_FJ",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python parse_to_remove_FJ.py",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/parse-to-remove-fj/1",
        "arguments": [],
        "x": 2918.2944583348412,
        "id": "milos_jordanski/spachete-salzman-collaboration/parse-to-remove-fj/1",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1520433510,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "parse_to_remove_FJ.py",
                "fileContent": "import re\nimport os\nimport subprocess\nimport csv\n\n# to call this:\n# cmd=\"python {INSTALLDIR}/parse_to_remove_FJ.py --stem {STEM} --outputdir {OUTPUT_DIR}\".format(INSTALLDIR=INSTALLDIR, STEM=STEM, OUTPUT_DIR=OUTPUT_DIR)\n\n\n# python parse_to_remove_FJ.py --stem\nimport argparse\n\nparser = argparse.ArgumentParser()\n#parser.add_argument(\"--stem\", help=\"STEM string\")\n#parser.add_argument(\"--outputdir\", help=\"OUTPUT_DIR\")\n\nparser.add_argument(\"-nr\", \"--naive_report\", help=\"Naive Report\", required = True)\nparser.add_argument(\"-fj\", \"--far_junctions\", nargs='+', help=\"Far junctions per chromosome\", required = True)\n\nargs = parser.parse_args()\n\n# first get STEM, assume it is passed from run.py\n#STEM = args.stem\n#outputdir = args.outputdir\n\n#naive_report = os.path.join(outputdir, \"reports\", STEM + \"_naive_report.txt\")\n\n#fastadir = os.path.join(outputdir, \"fasta\")\n\n\nrawcsv = csv.reader(open(args.naive_report), delimiter='\\t')\nfirst_column = []\nfor row in rawcsv:\n    first_column.append(row[0])\n# drop first element as it's from the header:\nfirst_column.pop(0)\n\nfirst_col_with_arrow = [(\">\" + x) for x in first_column]\n\n#fasta_stem_dir = os.path.join(fastadir, STEM)\n\n#posschrfjfiles = os.listdir(fasta_stem_dir)\n\n#chrfjfiles = [os.path.join(fasta_stem_dir, x) for x in posschrfjfiles if (re.search(pattern='chr.*FarJunctions.fa', string=x))]\n\nchrfjfiles = args.far_junctions\n\nnewfile = \"temp211.txt\"\nfor thisfile in chrfjfiles:\n    # clear newfile in case already used\n    open(newfile, 'w').close()\n\n    with open(thisfile, 'r') as ff:\n        lines = ff.read().splitlines()\n    for index, thisline in enumerate(lines):\n        if (thisline in first_col_with_arrow):\n            with open(newfile, 'a') as nn:\n                nn.write(thisline + \"\\n\")\n                if (index < len(lines)):\n                    nn.write(lines[(index + 1)] + \"\\n\")\n    # then write new file over the current file\n    cmd = \"mv -f \" + newfile + \" \" + thisfile\n    print(cmd)\n    subprocess.call(cmd, shell=True)"
              }
            ]
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "naive_report": {
              "path": "/path/to/naive_report.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "chr_fusion_junctions": {
              "path": "/path/to/chr_fusion_junctions.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433484,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520433510,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 7 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#chr_fusion_junctions",
              "glob": "*.fa"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#chr_filtered_fusion_junction"
          }
        ],
        "label": "MACHETE_parse_to_remove_FJ",
        "sbg:latestRevision": 1,
        "sbg:revisionNotes": "revision 7 copied",
        "y": 370.7803608311353,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-nr"
            },
            "id": "#naive_report",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-fj",
              "itemSeparator": " "
            },
            "id": "#chr_fusion_junctions",
            "type": [
              "null",
              "File"
            ],
            "sbg:stageInput": "link",
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/parse-to-remove-fj/1",
        "successCodes": [],
        "stdout": "",
        "sbg:createdOn": 1520433484,
        "baseCommand": [
          "python",
          "parse_to_remove_FJ.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 1,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "r3.8xlarge"
          }
        ]
      },
      "inputs": [
        {
          "id": "#MACHETE_parse_to_remove_FJ.naive_report",
          "source": [
            "#MACHETE_FarJuncJustNaiveReport.just_naive_report"
          ]
        },
        {
          "id": "#MACHETE_parse_to_remove_FJ.chr_fusion_junctions",
          "source": [
            "#MACHETE_combine_fasta_files.splitted_files"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_parse_to_remove_FJ.chr_filtered_fusion_junction"
        }
      ],
      "sbg:x": 2918.2944583348412,
      "sbg:y": 370.7803608311353,
      "scatter": "#MACHETE_parse_to_remove_FJ.chr_fusion_junctions"
    },
    {
      "id": "#MACHETE_GLM_script_UseIndel",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "chmod +x GLM_script_UseIndel.r && Rscript GLM_script_UseIndel.r  sample_name  ./",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/glm-script-useindel/22",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    \n    if($job.inputs.FJ_indel_class_input.metadata && $job.inputs.FJ_indel_class_input.metadata.sample_id)\n    \tcmd = $job.inputs.FJ_indel_class_input.metadata.sample_id\n\treturn cmd\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 3
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \"./\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 4
          }
        ],
        "x": 5546.119054266362,
        "id": "milos_jordanski/spachete-salzman-collaboration/glm-script-useindel/22",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1524202034,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "GLM_script_UseIndel.r",
                "fileContent": "########## FUNCTIONS ##########\n\nrequire(data.table)\nlibrary(base)\nset.seed(1, kind = NULL, normal.kind = NULL)\n\n# allows for variable read length (for trimmed reads)\ngetOverlapForTrimmed <- function(x, juncMidpoint=150){\n  if (as.numeric(x[\"pos\"]) > juncMidpoint){\n    overlap = 0\n  } else if (as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - 1 < juncMidpoint + 1){\n    overlap = 0\n  } else {\n    overlap = min(30,as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - juncMidpoint, juncMidpoint + 1 - as.numeric(x[\"pos\"]))\n  }\n  \n  return(overlap)\n}\n\n\n#define islowquality parameter\ngetIsLowQual <- function(x){\n  if (as.numeric(x[\"qual\"]) <= 3){\n    IsLowQual = 1\n  } else {\n    IsLowQual = 0\n  }\n  \n  return(IsLowQual)\n}\n\n\ngetMaxOverlap <- function(x, juncMidpoint=150){\n  if (as.numeric(x[\"pos\"]) > juncMidpoint){\n    overlap = 0\n  } else if (as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - 1 < juncMidpoint + 1){\n    overlap = 0\n  } else {\n    overlap = max(as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - juncMidpoint, juncMidpoint + 1 - as.numeric(x[\"pos\"]))\n  }\n  \n  return(overlap)\n}\n\n\n\nprocessScoreInput <- function(scoreFile){\n  setkey(scores, id)\n  return(scores)\n}\n\naddDerivedFields <- function(dt, useClass){\n  # correction 4/2016 of class files\n  if(nrow(dt) > 0){\n    # calculate and add on cols for junction overlap, score adjusted for N penalties,\n    ########## now, we have info for read1 and read2\n    # calculate and add on cols for junction overlap, score adjusted for N penalties,\n    dt[,`:=`(is.pos=useClass,overlap=apply(dt, 1, getOverlapForTrimmed),Maxoverlap=apply(dt, 1, getMaxOverlap))]  # syntax for multiple :=\n    dt[,IsLowQual:=apply(dt,1,getIsLowQual)]\n    # and length-adjusted alignment score (laplace smoothing so alignment score of 0 treated different for different length reads)\n    dt[, lenAdjScore:=(as.numeric(aScore) - 0.001)/as.numeric(readLen)]\n    \n    dt[Maxoverlap <= 50 ,Low_MaxOverlap := 1]\n    dt[Maxoverlap > 50 & Maxoverlap <= 70,Med_MaxOverlap := 1]\n    dt[Maxoverlap > 70,High_MaxOverlap := 1]\n    dt[is.na(Low_MaxOverlap),Low_MaxOverlap := 0]\n    dt[is.na(Med_MaxOverlap),Med_MaxOverlap := 0]\n    dt[is.na(High_MaxOverlap),High_MaxOverlap := 0]\n    \n    quantiles_overlap = quantile(dt$Maxoverlap)\n    dt[Maxoverlap <= quantiles_overlap[[2]],MaxOverlap_Cat := 0]\n    dt[Maxoverlap > quantiles_overlap[[2]] & Maxoverlap <= quantiles_overlap[[4]],MaxOverlap_Cat := 1]\n    dt[Maxoverlap > quantiles_overlap[[4]],MaxOverlap_Cat := 2]\n    \n    dt[tolower(junctionR2) %like% 'reg',is.JuncR2 := 1]\n    dt[tolower(junctionR2) %like% 'rev',is.JuncR2 := 1]\n    dt[is.na(is.JuncR2),is.JuncR2 := 0]\n    \n    dt[,`:=`(pos=NULL, aScore=NULL, numN=NULL, readLen=NULL)]\n    ################# repeat for read2\n    ## therefore, only add length adjusted alignment score for R2 !!\n    # and length-adjusted alignment score (`` smoothing\" so alignment score of 0 treated different for different length reads)\n    dt[, lenAdjScoreR2:=(aScoreR2 - 0.001)/readLenR2]\n    dt[,`:=`(pos=NULL, aScoreR2=NULL, numNR2=NULL, readLenR2=NULL, adjScoreR2=NULL, aScore=NULL, numN=NULL, readLen=NULL, adjScore=NULL)]\n  }\n  return(dt)\n}\n\n# the input file is just the file output by the circularRNApipeline under /ids\nprocessClassInput <- function(classFile,my.names){\n  \n  cats = fread(classFile,  sep=\"\\t\")\n  # cats = fread(classFile,  sep=\"\\t\")\n  ############################################################\n  if ( my.names!=\"none\"){\n    names(cats)=my.names\n  }\n  \n  # syntax for changing names setnames(cats, names(cats), c(\"id\", \"R1\", \"R2\", \"class\"))\n  setkey(cats, id)\n  return(cats)\n}\n\n# To avoid integer underflow issue when we have too many very small or very large probabilities.\n# Take inverse of posterior probability, then take log, which simplifies to sum(log(q) - /sum(log(p))\n# and then reverse operations to convert answer back to a probability.\n# param p: vector of p values for all reads aligning to junction\n# return posterior probability that this is a circular junction based on all reads aligned to it\ngetPprodByJunction <- function(p ){\n  out = tryCatch(\n    {\n      x = sum(log(p))  # use sum of logs to avoid integer underflow\n      return(exp(x))\n    },\n    error = function(cond){\n      print(cond)\n      print(p)\n      return(\"?\")\n    },\n    warning = function(cond){\n      print(cond)\n      print(p)\n      return(\"-\")\n    }\n  )\n  return(out)\n}\n\napplyToClass <- function(dt, expr) {\n  e = substitute(expr)\n  dt[,eval(e),by=is.pos]\n}\n\napplyToJunction <- function(dt, expr) {\n  e = substitute(expr)\n  dt[,eval(e),by=junction]\n}\n\n\n#######################################################################\n######################## BEGIN JS ADDITION ############################\n####################### FIRST JS FUNCTION #############################\n########################################################################\n################# JS added function to FIT the GLM using arbitrary two-classes\n\nmy.glm.model<-function(which_formula, linear_reads, decoy_reads,use_R2 , max.iter){\n  ### FUNCTION TO FIT GLM TO linear READS, returns the GLM and junction predictions,\n  saves = list()  # to hold all of the glms for future use\n  #max.iter = 2  # number of iterations updating weights and retraining glm\n  \n  # set up structure to hold per-read predictions\n  n.neg = nrow(decoy_reads)\n  n.pos = nrow(linear_reads)\n  n.reads = n.neg+n.pos\n  class.weight = min(n.pos, n.neg)\n  \n  ## note that this is coded as linear_reads and decoy_reads but applies to any pair class\n  \n  readPredictions = rbindlist(list(linear_reads, decoy_reads))\n  \n  # set initial weights uniform for class sum off all weights within any class is equal\n  if (n.pos >= n.neg){\n    readPredictions[,cur_weight:=c(rep(n.neg/n.pos, n.pos), rep(1, n.neg))]\n  } else {\n    readPredictions[,cur_weight:=c(rep(1, n.pos), rep(n.pos/n.neg, n.neg))]\n  }\n  \n  # glm\n  \n  \n  \n  \n  for(i in 1:max.iter){\n    # M step: train model based on current read assignments, down-weighting the class with more reasourcds\n    \n    if (use_R2==1){\n      \n      if (which_formula==1){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==2){\n        x=glm( is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2 + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==3){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2 + Low_MaxOverlap:Maxoverlap + Med_MaxOverlap:Maxoverlap+ High_MaxOverlap:Maxoverlap, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==4){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2  + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      }\n      \n    }\n    if (use_R2==0){\n      \n      if (which_formula==1){\n        x=glm(is.pos~overlap+lenAdjScore+qual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==2){\n        x=glm( is.pos~overlap+lenAdjScore+qual + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==3){\n        x=glm(is.pos~overlap+lenAdjScore+qual + Low_MaxOverlap:Maxoverlap + Med_MaxOverlap:Maxoverlap+ High_MaxOverlap:Maxoverlap, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==4){\n        x=glm(is.pos~overlap+lenAdjScore+qual + as.factor(MaxOverlap_Cat + 0), data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      }\n      \n    }\n    saves[[i]] = x\n    \n    # get CI on the output probabilities and use 95% CI\n    preds = predict(x, type = \"link\", se.fit = TRUE)\n    critval = 1.96 # ~ 95% CI\n    upr = preds$fit + (critval * preds$se.fit)\n    lwr = preds$fit - (critval * preds$se.fit)\n    upr2 = x$family$linkinv(upr)\n    lwr2 = x$family$linkinv(lwr)\n    \n    # use the upper 95% value for decoys and lower 95% for linear\n    adj_vals = c(rep(NA, n.reads))\n    adj_vals[which(readPredictions$is.pos == 1)] = lwr2[which(readPredictions$is.pos == 1)]\n    adj_vals[which(readPredictions$is.pos == 0)] = upr2[which(readPredictions$is.pos == 0)]\n    x$fitted.values = adj_vals  # so I don't have to modify below code\n    \n    # report some info about how we did on the training predictions\n    totalerr = sum(abs(readPredictions[,is.pos] - round(x$fitted.values)))\n    print (paste(i,\"total reads:\",n.reads))\n    print(paste(\"both negative\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==0), \"out of \", n.neg))\n    print(paste(\"both positive\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==2), \"out of \", n.pos))\n    print(paste(\"classification errors\", totalerr, \"out of\", n.reads, totalerr/n.reads ))\n    #print(coef(summary(x)))\n    readPredictions[, cur_p:=x$fitted.values] # add this round of predictions to the running totals\n    \n    # calculate junction probabilities based on current read probabilities and add to junction predictions data.table\n    \n    tempDT = applyToJunction(subset(readPredictions, is.pos == 1), getPprodByJunction(cur_p))\n    setnames(tempDT, \"V1\", paste(\"iter\", i, sep=\"_\")) # iter_x is the iteration of product of ps\n    setkey(tempDT, junction)\n    junctionPredictions = junctionPredictions[tempDT]  # join junction predictions and the new posterior probabilities\n    rm(tempDT)  # clean up\n    \n    # E step: weight the reads according to how confident we are in their classification. Only if we are doing another loop\n    if(i < max.iter){\n      posScale = class.weight/applyToClass(readPredictions,sum(cur_p))[is.pos == 1,V1]\n      negScale = class.weight/(n.neg - applyToClass(readPredictions,sum(cur_p))[is.pos == 0,V1])\n      readPredictions[is.pos == 1,cur_weight:=cur_p*posScale]\n      readPredictions[is.pos == 0,cur_weight:=((1 - cur_p)*negScale)]\n    }\n    setnames(readPredictions, \"cur_p\", paste(\"iter\", i, sep=\"_\")) # update names\n  }\n  \n  # calculate mean and variance for null distribution\n  ## this uses a normal approximation which holds only in cases with large numbers of reads, ie the CLT only holds as the number of reads gets very large\n  \n  ## should be called p-predicted\n  #read_pvals = readPredictions[,max.iter]\n  \n  # rename cols to be consistent with circular glmReports, syntax below removes col. \"ITER_1\"\n  if (max.iter>1){\n    # cleaning up\n    for (myi in c(1:(max.iter-1))){\n      junctionPredictions[, paste(\"iter_\",myi,sep=\"\"):=NULL]\n    }\n  }\n  setnames(junctionPredictions, paste(\"iter_\",max.iter,sep=\"\"), \"p_predicted\")\n  list(saves, junctionPredictions) ## JS these are the outputs and done with function\n}\n\n\n########################################################################\n###################### prediction from model ##########################\n##### as a function, needs input data and model\n\npredictNewClassP <- function(my_reads, null){ ## need not be circ_reads, just easier syntax\n  ######### up until this point, every calculation is PER READ, now we want a function to collapse\n  ######### want to do hypothesis testing\n  # calculate junction probabilities based on predicted read probabilities\n  ## Use simple function-- NOTE: \"p predicted\" is a CI bound not the point estimate. It is still technically a consistent estimate of p predicted\n  ## prob of an anomaly by glm is phat/(1+phat) under 'real' 1/(1+phat) under 'decoy' junction, so the ratio of these two reduces to 1/phat. as phat -> 1, no penalty is placed on anomaly.\n  \n  #merge\n  junctionPredictions = my_reads[, .N, by = junction] # get number of reads per junction\n  setnames(junctionPredictions, \"N\", \"numReads\")\n  setkey(junctionPredictions, junction)\n  \n  my_reads[, logproduct:=sum( log (p_predicted) * (1-is.anomaly) + log( 1/(1+p_predicted) *is.anomaly)), by=junction]\n  my_reads[,means_qual:=mean(qual), by=junction]    #Roozbeh added this new column for the average of mapping qualities to the report file\n means = my_reads[,list(junction,means_qual)]\n  junctionPredictions = merge(junctionPredictions,means)\n  \n  ## is anomaly adjusted log sum scoremm\n  logsum=my_reads[,sum( log ( p_predicted / (1+p_predicted*is.anomaly))), by=junction]\n  logsum_2=my_reads[,sum( log ( p_predicted_2 / (1+p_predicted_2*is.anomaly))), by=junction]\n  print (\"Logsum is reported which is equal to the sum of the logs of phats-- if exponentiated, corresponds to product of ps\")\n  \n  ## merge these new variables to the dataframe\n  junctionPredictions=merge(junctionPredictions,logsum)\n  setnames(junctionPredictions, \"V1\", \"logsum\")\n  \n  junctionPredictions=merge(junctionPredictions,logsum_2)\n  setnames(junctionPredictions, \"V1\", \"logsum_2\")\n  \n  print (names(junctionPredictions))\n  \n  ########### adding quantiles of p_predicted\n  n.quant=2\n  for (qi in 1:n.quant){\n    my_quantiles = my_reads[,round(10*quantile(p_predicted/(1+is.anomaly* p_predicted),probs=c(0:n.quant)/n.quant,na.rm=TRUE)[qi])/10,by=junction]\n    \n    # merge into junctionPredictions\n    #print (head(my_quantiles))\n    setkey(my_quantiles,junction)\n    junctionPredictions=merge(junctionPredictions,my_quantiles)\n    setnames(junctionPredictions, \"V1\", paste(\"q_\",qi,sep=\"\"))\n  }\n  \n  ##################################\n  ##  tempDT, to collapse across junctions\n  # p_predicteds are the exponentiation\n  junctionPredictions [ ,p_predicted_2:=exp(logsum_2),by=junction]\n  junctionPredictions [ ,p_predicted:=exp(logsum),by=junction]\n  \n  #print (head(junctionPredictions[order(junction),]))\n  \n  ## NOTE: P VALUE IS probability of observing a posterior as extreme as it is, \"getPvaluebyJunction\" is a bayesian posterior\n  junctionPredictionsWP=assignP(junctionPredictions,null)\n  \n  rm(tempDT)  # clean up\n  ## adding here:\n  \n  unique(junctionPredictionsWP) ## returned\n  \n}\n########################################################################################### ASSIGN p values through permutation\n###################################\nassignP<-function(junctionPredictions,null) {\n  # logsum is the logged sum\n  # add p-value to junctionPredictions (see GB supplement with logic for this)\n  \n  lognull=log(null)\n  \n  use_mu = mean(lognull) # this is actually the mean of the read level predictions\n  use_var=var(lognull)\n  ## for large n,\n  #print (\"using cdf of null distribution as \"p_value\" which is misnomer for convenient and replaced below \")\n  n.thresh.exact=15\n  print (n.thresh.exact)\n  \n  junctionPredictions[ (numReads>n.thresh.exact) , p_value :=  pnorm((logsum - numReads*use_mu)/sqrt(numReads*use_var))]\n  \n  junctionPredictions[ (numReads>n.thresh.exact) , p_value_2 :=  pnorm((logsum_2 - numReads*use_mu)/sqrt(numReads*use_var))]\n  \n  ## make empirical distribution of posteriors:\n  \n  print (\"exact calculation through sampling 10K p predicted\")\n  my.dist=list(n.thresh.exact)\n  for ( tempN in 1:n.thresh.exact){ #### get distributions to convolve in next loop\n    n.sampled=1000 # used to compute the null distribution of posteriors\n    my.dist[[tempN]]=sample(lognull, n.sampled, replace=T)\n  }\n  \n  for ( tempN in 1:n.thresh.exact){ ## use this loop to assign jncts w/ tempN\n    sim.readps=my.dist[[1]]\n    if (tempN>1){\n      for (tj in 2: tempN){ # loop, taking products\n        sim.readps=my.dist[[tj]] +  sim.readps\n      }\n    }\n    # convert to posterior\n    ## fraction of time p_predicted is smaller than -- so if p_predicted is very large, the fraction of time it is smaller is big\n    ## use the null to compute p_vals\n    #print (head(junctionPredictions))\n    #print (paste(tempN, \"is value of readcount for exact calculation and length of sim reads is \",length(sim.readps)))\n    \n    junctionPredictions [ (numReads == tempN ), p_value:= sum( exp(sim.readps)<p_predicted)/length(sim.readps),by=junction]\n    \n    #print (\"if below table is not empty, ERROR\")\n    #print (junctionPredictions[p_value>1])\n    \n    \n    junctionPredictions [ (numReads == tempN ), p_value_2:= sum( exp(sim.readps)<p_predicted_2)/length(sim.readps), by=junction]\n    \n  }\n  return(junctionPredictions)\n}\n###########################################################################################\n###########################################################################################\n###########################################################################################\n###########################################################################################\n######## END FUNCTIONS, BEGIN WORK #########\n\n## command line inputs\nuser.input=0\n\nno.indel.classfile=0\n\nif (user.input==0){\n  args = commandArgs(trailingOnly = TRUE)\n  fusion_class_input=args[1]\n  class_input=args[2]\n  srr= args[3]\n  output_dir=args[4]\n  reg_indel_class_input = args[5]\n  FJ_indel_class_input = args[6]\n  print (paste(\"outputdir\", output_dir))\n  ## should be:\n  #FJ_indel_class_input = paste(parentdir,srr,\"_output_FJIndels.txt\",sep=\"\")\n  #reg_indel_class_input = paste(parentdir,srr,\"_output_RegIndel.txt\",sep=\"\")\n}\n\nmax.iter=2 ## iterations for glm\n\nif (user.input==1){\n  output_dir=\"\"}\n\nuse.indels=1\nuse.fusion=1\n\n## define output class files\nglm_out = paste(output_dir,srr,\"_DATAOUT\",sep=\"\")\nanomaly_glm_out = paste(output_dir,srr,\"_AnomalyDATAOUT\",sep=\"\")\n\nindel_glm_out = paste(output_dir,srr,\"_IndelDATAOUT_MACHETE\",sep=\"\")\nlinear_juncp_out = paste(output_dir,srr,\"_LINEARJUNCP_OUT_MACHETE\",sep=\"\")\ncirc_juncp_out = paste(output_dir,srr,\"_CIRC_JUNCP_OUT_MACHETE\",sep=\"\")\nfusion_juncp_out = paste(output_dir,srr,\"_FUSION_JUNCP_OUT_MACHETE\",sep=\"\")\nlinearwanomaly_juncp_out = paste(output_dir,srr,\"_LINEAR_W_ANOMALY_JUNCP_OUT_MACHETE\",sep=\"\")\nfusionwanomaly_juncp_out= paste(output_dir,srr,\"_FUSION_W_ANOM_JUNCPOUT_MACHETE\", sep=\"\")\nfusionwanomaly_and_indel_juncp_out= paste(output_dir,srr,\"_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_MACHETE\", sep=\"\")\n####### CURRENT GOAL IS TO UPDATE LINEAR pvalues w/ anomaly reads\nlinear_juncp_update_out = paste(output_dir,srr,\"_LINEARJUNCP_UPDATED_OUT_MACHETE\",sep=\"\")\n##### SINK THE SUMMARY OF THIS SCRIPT\nprint (paste(\"OUtput dir\", fusionwanomaly_and_indel_juncp_out))\n#sink(paste(output_dir,srr,\"_glmInformation_\",sep=\"\"))\n\n### DONE W/ LOOP\n\n\nmy.names=\"none\" ## this is bc Gillians fields are not names like Lindas are\nmyClasses = processClassInput(class_input, my.names)\n\nif (use.fusion==1){\n  print (paste(\"using \", fusion_class_input))\n  myClassesFusion = processClassInput(fusion_class_input,names(myClasses))\n}\nif (use.indels==1){\n  print (paste(\"using \", reg_indel_class_input,\" and \" , FJ_indel_class_input))\n  myClassesRegIndel = processClassInput(reg_indel_class_input,names(myClasses))\n  myClassesFJIndel = processClassInput(FJ_indel_class_input,names(myClasses))\n}\n\nprint(paste(\"class info processed\", dim(myClasses)))\n\ncirc_reads = myClasses[(tolower(class) %like% 'circ'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\ncirc_reads = addDerivedFields(circ_reads, 1)\ncirc_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\nprint (\"finished circ_reads\")\n\ndecoy_reads = myClasses[(tolower(class) %like% 'decoy'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\ndecoy_reads = addDerivedFields(decoy_reads, 0)\ndecoy_reads [, is.anomaly:=1] ######## this IS an anomaly type\n\nprint (\"finished decoy_reads\")\n## was\nlinear_reads = myClasses[(tolower(class) %like% 'linear'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\nlinear_reads = addDerivedFields(linear_reads, 1)\nlinear_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\nprint (\"finished linear_reads\")\n\nanomaly_reads = myClasses[(tolower(class) %like% 'anomaly'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\nanomaly_reads [, is.anomaly:=1]\nprint (\"finished anomaly_reads\")\n\nif (use.indels==1){\n  ## in analogy, we first define all indels, then assign good and bad\n  ## we will use anomaly field as a general term for 'anomaly mapping and indel'\n  reg_indel_reads = myClassesRegIndel[, list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\n  reg_indel_reads [, is.anomaly:=1]\n  print (\"Finished reg indels\")\n  \n  compatible_indel_reads = myClassesRegIndel[(tolower(class) %like% 'good'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\n  compatible_indel_reads [, is.anomaly:=1]\n  \n  incompatible_indel_reads = myClassesRegIndel[(tolower(class) %like% 'bad'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\n  incompatible_indel_reads [, is.anomaly:=1]\n  \n  FJ_indel_reads = myClassesFJIndel[, list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\n  FJ_indel_reads [, is.anomaly:=1]\n  \n  if (dim(FJ_indel_reads)[1]==0){\n    no.indel.classfile = 1\n  } else{\n    FJ_indel_reads = addDerivedFields(FJ_indel_reads, 1)\n    \n  }\n  \n}\n\nif (use.fusion==1){\n  \n  #was na.omit\n  fusion_reads = (myClassesFusion[(tolower(class) %like% 'fjgood'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),])\n  fusion_reads = addDerivedFields(fusion_reads, 1)\n  fusion_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n  \n  print (\"ANOMALY fusions defined as FJ bad-- of any variety\")\n  anomaly_fusion_reads = (myClassesFusion[(tolower(class) %like% 'fjbad'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]) # GILLIAN, pls comment here on what FJ bad is for the sake of documentation\n  \n  anomaly_fusion_reads = addDerivedFields(anomaly_fusion_reads, 1)\n  anomaly_fusion_reads [, is.anomaly:=1] ## this is not an anomaly type so WILL NOT have p value ajustment\n}\n###############################################################################################\n## CANNOT ADD DERIVED FIELDS HERE BECAUSE WE DON'T KNOW WHICH ANOMALIES ARE GOOD AND/OR BAD\n##################### DERIVED FIELDS ADDED LATER ##############################################\n###############################################################################################\n\n# set up data structure to hold per-junction predictions\njunctionPredictions = linear_reads[, .N, by = junction] # get number of reads per junction\nsetnames(junctionPredictions, \"N\", \"numReads\")\nsetkey(junctionPredictions, junction)\n\n#### TRAIN EM ####\n## this should be a function of any two classes; and the output will be the model\n\n##\n\nn.row= dim(linear_reads)[1]\nn.sample=min(n.row,10000)\n\n#syntax example decoy_reads[,p_predicted:=NULL]\nprint (\"calling linear decoy model\")\nlinearDecoyGLMoutput = my.glm.model (4, linear_reads[ sample(n.row,n.sample,replace=FALSE),], decoy_reads, 1, max.iter) ## 0 does not use R2 info\n\nsaves = linearDecoyGLMoutput[[1]]\nlinearJunctionPredictions =  linearDecoyGLMoutput[[2]]\n#save(saves, file=glm_out)  # save models\nlinearDecoyGLM = saves[[max.iter]] ##### this is the glm model\n\n## after fitting the GLM to linear vs. decoy, we want to store linear junction predictions in order to subset anomalies\n######## JS ADDITION: NOTE- NOT stratifying on permutation p value, although could add this too\n\n\n############################################################################\n### START LINEARS\n################# predict on anomaly reads -- AND TEST HOW THIS IMPACTS LINEAR PREDICTIONS\n############################ linear predictions ONLY ON THE BASIS of anomalies...\n\npreds = predict(linearDecoyGLM, newdata=linear_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\nlinear_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\nlinear_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n## for null\nprint (\"Assigning null distribution for all linear reads\")\nnull=linear_reads$p_predicted\n\n### ASSIGN p value:\nlinearJunctionPredictionsForModels = predictNewClassP(linear_reads, null)\n\npGoodThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.8,na.rm=TRUE)\ngood.linear=linearJunctionPredictionsForModels[p_value> pGoodThresh,]\n\npBadThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.2,na.rm=TRUE)\nbad.linear=linearJunctionPredictionsForModels[p_value< pBadThresh,]\n#####################################\n\n\n############## done with linears\n\n# define two classes of anomalies: those from good vs. bad junctions\n\n\ngood_anomaly_reads= anomaly_reads[!is.na(match(junction, good.linear$junction)),]\nbad_anomaly_reads= anomaly_reads[!is.na(match(junction, bad.linear$junction)),]\n## NOW add derived fields\n\nif (use.indels==1){\n  # define two classes of regular INDELS for training: those from good vs. bad junctions\n  \n  good_indel_reads= compatible_indel_reads[!is.na(match(junction, good.linear$junction)),]\n  bad_indel_reads= incompatible_indel_reads[!is.na(match(junction, bad.linear$junction)),]\n  \n  ## if either class is empty, change use.indels to zero\n  \n  if (min(dim(good_indel_reads)[1],dim(bad_indel_reads)[1])<20){\n    print (\"CHANGING TO INDELS=0 becuase too few reads\")\n    use.indels=0\n  }\n  \n  \n}\n\n##### now, re-run script training on anomalies from good vs. bad\n\nuse.anomaly = 1\n\nif (dim(good_anomaly_reads)[1]==0 & dim(bad_anomaly_reads)[1]==0){\n  use.anomaly = 0\n}\n\nif (min(dim(good_anomaly_reads)[1], dim(bad_anomaly_reads)[1]) > 0){\n  ## The \"1\" belowneeds to be 0 and 1 for good and bad anomalies\n  good_anomaly_reads = addDerivedFields(good_anomaly_reads, 1) ####\n  bad_anomaly_reads = addDerivedFields(bad_anomaly_reads, 0) ####\n  all_anomaly_reads=rbind(good_anomaly_reads,bad_anomaly_reads)\n  \n  ######## now, RECALL GLM  FOR ANOMALY READ MAPPERS\n  print (\"calling good anomaly bad anomaly model with .8 and .2 as thresholds\")\n  AnomInfo = my.glm.model (4,good_anomaly_reads, bad_anomaly_reads,1, max.iter) ## JS these are the outputs and done with function\n  ANOMALYsaves=AnomInfo[[1]]\n  ANOMALYjunctionPredictions=AnomInfo[[2]]\n  AnomalyGLM = ANOMALYsaves[[max.iter]] ##### this is the glm model\n  \n  preds = predict(AnomalyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n  \n  lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n  lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n  \n  all_anomaly_reads[, p_predicted:= AnomalyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n  all_anomaly_reads[, p_predicted_2:= AnomalyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n  use.anomaly = 2\n  \n} else{\n  if(dim(good_anomaly_reads)[1]>0){\n    all_anomaly_reads = addDerivedFields(good_anomaly_reads, 1)\n    \n    preds = predict(linearDecoyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n    \n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n    \n    all_anomaly_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    all_anomaly_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    \n  }\n  if(dim(bad_anomaly_reads)[1]>0){\n    all_anomaly_reads = addDerivedFields(bad_anomaly_reads, 1)\n    \n    preds = predict(linearDecoyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n    \n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n    \n    all_anomaly_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    all_anomaly_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    \n  }\n}\n\n## in anaolgy, same for INDELS\nif (use.indels==1){\n  good_indel_reads = addDerivedFields(good_indel_reads, 1) ####\n  bad_indel_reads = addDerivedFields(bad_indel_reads, 0) ####\n  all_indel_reads=rbind(good_indel_reads,bad_indel_reads)\n}\n\nif (use.indels==1){\n  print (\"calling INDEL model with .8 and .2 as thresholds\")\n  IndelInfo = my.glm.model (1,good_indel_reads, bad_indel_reads,1, max.iter) ## JS these are the outputs and done with function\n  INDELsaves=IndelInfo[[1]]\n  INDELjunctionPredictions=IndelInfo[[2]]\n  IndelGLM = INDELsaves[[max.iter]] ##### this is the glm model\n}\nif (use.indels==0){\n  print (\"USING GLM MODEL for INDEL MODEL\")\n  INDELsaves = linearDecoyGLMoutput[[1]]\n  INDELlinearJunctionPredictions =  linearDecoyGLMoutput[[2]]\n  IndelGLM = linearDecoyGLM\n}\n\n## save GLMS\n#save(AnomalyGLM, file=anomaly_glm_out)  # save models\nif (use.indels==1){\n  save(IndelGLM, file=indel_glm_out)  # save models\n}\n#save(linearDecoyGLM, file=glm_out)  # save models\n\npreds = predict(linearDecoyGLM, newdata=decoy_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\nlwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\ndecoy_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ndecoy_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n\n## need to rbind anomaly junctions\nif (use.anomaly != 0){\n  linear_and_anomaly=rbind(all_anomaly_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], linear_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n} else{\n  linear_and_anomaly = linear_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)]\n}\n\n\nlinearWithAnomalyJunctionPredictions = predictNewClassP(linear_and_anomaly, null)\n\n################# DONE WITH LINEARS\n#########################################################################\n\n#### PREDICT CIRCULAR JUNCTIONS #### SHOULD MAKE THIS MODULAR AND A FUNCTION so Farjunction and Anomalies can be used\n## SIMPLE PREDICT ON CIRCLES\npreds = predict(linearDecoyGLM, newdata=circ_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n\ncirc_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ncirc_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\ncircularJunctionPredictions = predictNewClassP(circ_reads, null)\n\n#########################################################################\n## start fusions ############################################################################\n############################################################################\n################# NOTE: Here, we are only using fusion reads not fusion anomaly reads and treating the prediction just like circle\n############################################################################\n############################################################################\n## start prediction on good far junctions\n\nif (use.fusion==1){\n  fusion_reads$overlap=as.numeric(as.vector(fusion_reads$overlap))\n  preds = predict(linearDecoyGLM, newdata=fusion_reads, type = \"link\", se.fit = TRUE)\n  lwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n  lwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n  \n  fusion_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n  fusion_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n  fusionJunctionPredictions = predictNewClassP( fusion_reads, null)\n  \n  \n  if(use.anomaly == 2){\n    # start prediction on BAD=Anomaly mapping\n    print (\"done with fusion normals, starting anomalies\")\n    \n    preds = predict(AnomalyGLM, newdata=anomaly_fusion_reads, type = \"link\", se.fit = TRUE)\n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n    \n    anomaly_fusion_reads[, p_predicted:= AnomalyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    anomaly_fusion_reads[, p_predicted_2:= AnomalyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    \n    linear_and_anomaly_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n    linear_and_anomaly_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_fusions$overlap))\n    linearWithAnomalyFusionPredictions = predictNewClassP(linear_and_anomaly_fusions, null)\n    \n    # start prediction on INDELS mapping\n    print (\"done with fusion anomalies starting indels\")\n  } else{\n    preds = predict(linearDecoyGLM, newdata=anomaly_fusion_reads, type = \"link\", se.fit = TRUE)\n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n    \n    anomaly_fusion_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    anomaly_fusion_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    \n    linear_and_anomaly_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n    linear_and_anomaly_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_fusions$overlap))\n    linearWithAnomalyFusionPredictions = predictNewClassP(linear_and_anomaly_fusions, null)\n  }\n}\n\nif (use.indels==1 & no.indel.classfile==0){\n  FJ_indel_reads$overlap=as.numeric(as.vector(FJ_indel_reads$overlap))\n  preds = predict(IndelGLM, newdata=FJ_indel_reads, type = \"link\", se.fit = TRUE)\n  lwr = preds$fit + (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n  lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n  \n  FJ_indel_reads[, p_predicted:= IndelGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n  FJ_indel_reads[, p_predicted_2:= IndelGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n  \n  linear_and_anomaly_and_indel_fusions=rbind(FJ_indel_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)],anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n}\n\n\n\nif (use.indels==0 & no.indel.classfile==0){\n  ## if not using indels, we assign indel reads according to the linear decoy model\n  preds = predict(linearDecoyGLM, newdata=FJ_indel_reads, type = \"link\", se.fit = TRUE)\n  lwr = preds$fit + (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n  lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n  FJ_indel_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n  FJ_indel_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n  \n  linear_and_anomaly_and_indel_fusions=rbind(FJ_indel_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)],anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n  \n}\n\nif (no.indel.classfile==1){\n  linear_and_anomaly_and_indel_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n  \n}\n\nlinear_and_anomaly_and_indel_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_and_indel_fusions$overlap))\nlinearWithAnomalyAndIndelFusionPredictions = predictNewClassP(linear_and_anomaly_and_indel_fusions, null)\n\nconsolidated_fusion=merge(fusionJunctionPredictions,linearWithAnomalyFusionPredictions , all=TRUE,by=\"junction\")\nconsolidated_fusion[,p_diff:=(p_predicted.x-p_predicted.y)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\nconsolidated_fusion=data.table(unique(consolidated_fusion))\n\n####### now add indels\n#verbose adds extra output and extra info to indel table\nverbose=0\n\nprint (\"now adding indels and changing names to reflect accurate terminology\")\nconsolidated_fusion_windel=merge(linearWithAnomalyFusionPredictions ,linearWithAnomalyAndIndelFusionPredictions, all=TRUE,by=\"junction\")\nconsolidated_fusion_windel[,p_diff_indel:=(p_predicted.y-p_predicted.x)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\nconsolidated_fusion_windel=data.table(unique(consolidated_fusion_windel))\n\nsetnames(consolidated_fusion_windel,\"p_predicted.x\", \"productPhat.x\")\nsetnames(consolidated_fusion_windel,\"p_predicted.y\", \"productPhat.y\")\nsetnames(consolidated_fusion_windel,\"p_value.x\", \"junction_cdf.x\")\nsetnames(consolidated_fusion_windel,\"p_value.y\", \"junction_cdf.y\")\n\n\nsetnames(consolidated_fusion_windel,\"p_predicted_2.x\", \"productPhat_lower.x\")\nsetnames(consolidated_fusion_windel,\"p_predicted_2.y\", \"productPhat_lower.y\")\nsetnames(consolidated_fusion_windel,\"p_value_2.x\", \"junction_cdf_lower.x\")\nsetnames(consolidated_fusion_windel,\"p_value_2.y\", \"junction_cdf_lower.y\")\n\nsetnames(consolidated_fusion_windel,\"p_diff_indel\", \"junction_cdf_windel_diff\")\nif (verbose==0){\n  consolidated_fusion_windel[,q_1.y:=NULL]\n  consolidated_fusion_windel[,q_2.y:=NULL]\n  consolidated_fusion_windel[,q_1.x:=NULL]\n  consolidated_fusion_windel[,q_2.x:=NULL]\n  consolidated_fusion_windel[,logsum.x:=NULL]\n  consolidated_fusion_windel[,logsum.y:=NULL]\n}\n\n## fusion_reads merging\n## JS ADD 8/14\nfusion_reads[strand!=0,maxNegStrandOverlap:=max(overlap),by=junction]\nfusion_reads[strand==0,maxPosStrandOverlap:=max(overlap),by=junction]\nout_fusions=merge(merge(consolidated_fusion_windel, unique(fusion_reads[strand==0,list(junction,maxPosStrandOverlap)]),by=\"junction\",add.x=TRUE), unique(fusion_reads[strand!=0,list(junction,maxNegStrandOverlap)]),by=\"junction\",add.x=TRUE)\n\nout_fusions_left_joint=merge(merge(consolidated_fusion_windel, unique(fusion_reads[strand==0,list(junction,maxPosStrandOverlap)]),by=\"junction\",all.x=TRUE), unique(fusion_reads[strand!=0,list(junction,maxNegStrandOverlap)]),by=\"junction\",all.x=TRUE)\n\nfusionwanomaly_and_indel_juncp_out_left_joint= paste(output_dir,srr,\"_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_MACHETE_LEFT_JOIN\", sep=\"\")\n\nwrite.table(unique(out_fusions)[order(-junction_cdf.y),], fusionwanomaly_and_indel_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\nwrite.table(unique(out_fusions_left_joint)[order(-junction_cdf.y),], fusionwanomaly_and_indel_juncp_out_left_joint, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\ncir.verbose=0\n####################################################################################\n####################################################################################\nif (cir.verbose==1){\n  ## write circle prediction\n  \n  setnames(circularJunctionPredictions,\"p_predicted\", \"productPhat.x\")\n  setnames(circularJunctionPredictions,\"p_predicted_2\", \"productPhat_lower.x\")\n  setnames(circularJunctionPredictions,\"p_value_2\", \"junction_cdf_lower.x\")\n  setnames(circularJunctionPredictions,\"p_value\", \"junction_cdf\")\n  \n  write.table(unique(linearJunctionPredictions), linear_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n  write.table(unique(circularJunctionPredictions), circ_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n  \n  ## with anomalies, p value should be smaller so p_diff should always be negative...\n  consolidated_linear=merge(linearWithAnomalyJunctionPredictions,linearJunctionPredictions,by=\"junction\",all=TRUE)\n  consolidated_linear[,p_diff:=(p_predicted.x-p_predicted.y)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\n  consolidated_linear=data.table(unique(consolidated_linear))\n  write.table(unique(consolidated_linear), linearwanomaly_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n  \n  ##\n  my.null.quantiles=quantile(linear_reads$p_predicted,probs=c(0:10)/10,na.rm=TRUE)\n  ## refer fusions to these quantiles; 'falsely called' vs. true will be fraction of linears (conservative estimate) ; error at this quantile can be evaluated.\n  \n  write.table(unique(fusionJunctionPredictions[order(-p_predicted),]),fusion_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n  write.table(unique(consolidated_fusion)[order(-p_predicted.y),], fusionwanomaly_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n  \n}"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "fusion_class_input": {
              "path": "/path/to/fusion_class_input.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "FJ_indel_class_input": {
              "path": "/path/to/FJ_indel_class_input.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "sample_name"
              }
            },
            "class_input": {
              "path": "/path/to/class_input.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "sample_name"
              }
            },
            "reg_indel_class_input": {
              "path": "/path/to/reg_indel_class_input.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520439271,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520439301,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 12 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522638590,
            "sbg:revision": 2,
            "sbg:revisionNotes": "added IslowQual and other new parameters to glm script",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522679431,
            "sbg:revision": 3,
            "sbg:revisionNotes": "n.row= dim(decoy_reads)[1]",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522681170,
            "sbg:revision": 4,
            "sbg:revisionNotes": "n.row= dim(linear_reads)[1] and penalize 2 times more decoy_reads",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522682050,
            "sbg:revision": 5,
            "sbg:revisionNotes": "n.row= dim(linear_reads)[1] and penalize 2 time more decoy reads",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522689184,
            "sbg:revision": 6,
            "sbg:revisionNotes": "n.row= dim(linear_reads)[1] and penalize 5 times more decoy_reads",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522702747,
            "sbg:revision": 7,
            "sbg:revisionNotes": "n.row= dim(linear_reads)[1] and penalize 10 times more decoy_reads",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522705024,
            "sbg:revision": 8,
            "sbg:revisionNotes": "IsLowQual=1 if Mqual <=3",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522715308,
            "sbg:revision": 9,
            "sbg:revisionNotes": "IsLowQual =1 if Mqual<=3",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522718522,
            "sbg:revision": 10,
            "sbg:revisionNotes": "IsLowQual: as.numeric(x[\"qual\"]) <= 5",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522723930,
            "sbg:revision": 11,
            "sbg:revisionNotes": "IsLowQual=1 if mqual<=3",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522822734,
            "sbg:revision": 12,
            "sbg:revisionNotes": "MaxOverlap_Cat is added to the GLM model and IsLowqual is removed.",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522830160,
            "sbg:revision": 13,
            "sbg:revisionNotes": "Maxoverlap <=50: MaxOverlap_Cat := 0\nMaxoverlap > 50: MaxOverlap_Cat := 1",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522851801,
            "sbg:revision": 14,
            "sbg:revisionNotes": "back to revision 1",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522890625,
            "sbg:revision": 15,
            "sbg:revisionNotes": "use model 4 only for linear, anomaly glms\nmodel 1 for indel",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522900080,
            "sbg:revision": 16,
            "sbg:revisionNotes": "add average mapping qulaity of the aligned reads to the output file",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522910255,
            "sbg:revision": 17,
            "sbg:revisionNotes": "Back to revision 1",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522912078,
            "sbg:revision": 18,
            "sbg:revisionNotes": "Add average mapping quality of the aligned reads to the output file",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1523564124,
            "sbg:revision": 19,
            "sbg:revisionNotes": "model 4 has  as.factor(MaxOverlap_Cat + 0) +IsLowQual\nMaxoverlap_cat is set based on first and third quantiles",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1524093616,
            "sbg:revision": 20,
            "sbg:revisionNotes": "Back to original GLM model with original predictors",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1524196317,
            "sbg:revision": 21,
            "sbg:revisionNotes": "Only \"as.factor(MaxOverlap_Cat + 0)\" is added to as an predictor (without Islowqual).",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1524202034,
            "sbg:revision": 22,
            "sbg:revisionNotes": "Only IsLowQual is added to GLM",
            "sbg:modifiedBy": "roozbehdn"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_LINEAR_W_ANOMALY_JUNCP_OUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#linear_w_anomaly_juncp_out"
          },
          {
            "outputBinding": {
              "glob": "*_LINEARJUNCP_UPDATED_OUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#linear_juncp_updated_out"
          },
          {
            "outputBinding": {
              "glob": "*_LINEARJUNCP_OUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#linear_juncp_out"
          },
          {
            "outputBinding": {
              "glob": "*_IndelDATAOUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#indel_data_out"
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_JUNCPOUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_w_anomaly_juncp_out"
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_MACHETE_LEFT_JOIN"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_w_anomaly_and_indel_juncp_out_lef_join"
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_w_anomaly_and_indel_juncp_out"
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_JUNCP_OUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_juncp_out"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#class_input",
              "glob": "*_DATAOUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#data_out"
          },
          {
            "outputBinding": {
              "glob": "*_CIRC_JUNCP_OUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#circ_juncp_out"
          },
          {
            "outputBinding": {
              "glob": "*_AnomalyDATAOUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#anomaly_data_out"
          }
        ],
        "label": "MACHETE_GLM_script_UseIndel",
        "sbg:latestRevision": 22,
        "sbg:revisionNotes": "Only IsLowQual is added to GLM",
        "y": 358.48640314892265,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 5
            },
            "id": "#reg_indel_class_input",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 1
            },
            "id": "#fusion_class_input",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 2
            },
            "id": "#class_input",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "loadContents": true,
              "separate": true,
              "position": 6
            },
            "id": "#FJ_indel_class_input",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "roozbehdn",
        "sbg:image_url": null,
        "sbg:contributors": [
          "roozbehdn",
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "chmod",
          "+x",
          "GLM_script_UseIndel.r",
          "&&",
          "Rscript",
          "GLM_script_UseIndel.r"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 22,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/machete_glm:r"
          }
        ],
        "sbg:createdOn": 1520439271
      },
      "inputs": [
        {
          "id": "#MACHETE_GLM_script_UseIndel.reg_indel_class_input",
          "source": [
            "#MACHETE_RegIndels_ClassIDFile.output_RegIndel"
          ]
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.fusion_class_input",
          "source": [
            "#MACHETE_FarJuncNaiveReport.IDs"
          ]
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.class_input",
          "source": [
            "#KNIFE_filterFDR.output"
          ]
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.FJ_indel_class_input",
          "source": [
            "#MACHETE_FJIndels_ClassIDFile.output_FJIndels"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_GLM_script_UseIndel.linear_w_anomaly_juncp_out"
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.linear_juncp_updated_out"
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.linear_juncp_out"
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.indel_data_out"
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.fusion_w_anomaly_juncp_out"
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.fusion_w_anomaly_and_indel_juncp_out_lef_join"
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.fusion_w_anomaly_and_indel_juncp_out"
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.fusion_juncp_out"
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.data_out"
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.circ_juncp_out"
        },
        {
          "id": "#MACHETE_GLM_script_UseIndel.anomaly_data_out"
        }
      ],
      "sbg:x": 5546.119054266362,
      "sbg:y": 358.48640314892265
    },
    {
      "id": "#GLM_script_UseIndel_MACHETE_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "chmod +x GLM_script_UseIndel.r && Rscript GLM_script_UseIndel.r  sample_name  ./",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/glm-script-useindel/22",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    \n    if($job.inputs.FJ_indel_class_input.metadata && $job.inputs.FJ_indel_class_input.metadata.sample_id)\n    \tcmd = $job.inputs.FJ_indel_class_input.metadata.sample_id\n\treturn cmd\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 3
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \"./\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 4
          }
        ],
        "x": 5145.884887576583,
        "id": "milos_jordanski/spachete-salzman-collaboration/glm-script-useindel/22",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1524202034,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "GLM_script_UseIndel.r",
                "fileContent": "########## FUNCTIONS ##########\n\nrequire(data.table)\nlibrary(base)\nset.seed(1, kind = NULL, normal.kind = NULL)\n\n# allows for variable read length (for trimmed reads)\ngetOverlapForTrimmed <- function(x, juncMidpoint=150){\n  if (as.numeric(x[\"pos\"]) > juncMidpoint){\n    overlap = 0\n  } else if (as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - 1 < juncMidpoint + 1){\n    overlap = 0\n  } else {\n    overlap = min(30,as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - juncMidpoint, juncMidpoint + 1 - as.numeric(x[\"pos\"]))\n  }\n  \n  return(overlap)\n}\n\n\n#define islowquality parameter\ngetIsLowQual <- function(x){\n  if (as.numeric(x[\"qual\"]) <= 3){\n    IsLowQual = 1\n  } else {\n    IsLowQual = 0\n  }\n  \n  return(IsLowQual)\n}\n\n\ngetMaxOverlap <- function(x, juncMidpoint=150){\n  if (as.numeric(x[\"pos\"]) > juncMidpoint){\n    overlap = 0\n  } else if (as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - 1 < juncMidpoint + 1){\n    overlap = 0\n  } else {\n    overlap = max(as.numeric(x[\"pos\"]) + as.numeric(x[\"readLen\"]) - juncMidpoint, juncMidpoint + 1 - as.numeric(x[\"pos\"]))\n  }\n  \n  return(overlap)\n}\n\n\n\nprocessScoreInput <- function(scoreFile){\n  setkey(scores, id)\n  return(scores)\n}\n\naddDerivedFields <- function(dt, useClass){\n  # correction 4/2016 of class files\n  if(nrow(dt) > 0){\n    # calculate and add on cols for junction overlap, score adjusted for N penalties,\n    ########## now, we have info for read1 and read2\n    # calculate and add on cols for junction overlap, score adjusted for N penalties,\n    dt[,`:=`(is.pos=useClass,overlap=apply(dt, 1, getOverlapForTrimmed),Maxoverlap=apply(dt, 1, getMaxOverlap))]  # syntax for multiple :=\n    dt[,IsLowQual:=apply(dt,1,getIsLowQual)]\n    # and length-adjusted alignment score (laplace smoothing so alignment score of 0 treated different for different length reads)\n    dt[, lenAdjScore:=(as.numeric(aScore) - 0.001)/as.numeric(readLen)]\n    \n    dt[Maxoverlap <= 50 ,Low_MaxOverlap := 1]\n    dt[Maxoverlap > 50 & Maxoverlap <= 70,Med_MaxOverlap := 1]\n    dt[Maxoverlap > 70,High_MaxOverlap := 1]\n    dt[is.na(Low_MaxOverlap),Low_MaxOverlap := 0]\n    dt[is.na(Med_MaxOverlap),Med_MaxOverlap := 0]\n    dt[is.na(High_MaxOverlap),High_MaxOverlap := 0]\n    \n    quantiles_overlap = quantile(dt$Maxoverlap)\n    dt[Maxoverlap <= quantiles_overlap[[2]],MaxOverlap_Cat := 0]\n    dt[Maxoverlap > quantiles_overlap[[2]] & Maxoverlap <= quantiles_overlap[[4]],MaxOverlap_Cat := 1]\n    dt[Maxoverlap > quantiles_overlap[[4]],MaxOverlap_Cat := 2]\n    \n    dt[tolower(junctionR2) %like% 'reg',is.JuncR2 := 1]\n    dt[tolower(junctionR2) %like% 'rev',is.JuncR2 := 1]\n    dt[is.na(is.JuncR2),is.JuncR2 := 0]\n    \n    dt[,`:=`(pos=NULL, aScore=NULL, numN=NULL, readLen=NULL)]\n    ################# repeat for read2\n    ## therefore, only add length adjusted alignment score for R2 !!\n    # and length-adjusted alignment score (`` smoothing\" so alignment score of 0 treated different for different length reads)\n    dt[, lenAdjScoreR2:=(aScoreR2 - 0.001)/readLenR2]\n    dt[,`:=`(pos=NULL, aScoreR2=NULL, numNR2=NULL, readLenR2=NULL, adjScoreR2=NULL, aScore=NULL, numN=NULL, readLen=NULL, adjScore=NULL)]\n  }\n  return(dt)\n}\n\n# the input file is just the file output by the circularRNApipeline under /ids\nprocessClassInput <- function(classFile,my.names){\n  \n  cats = fread(classFile,  sep=\"\\t\")\n  # cats = fread(classFile,  sep=\"\\t\")\n  ############################################################\n  if ( my.names!=\"none\"){\n    names(cats)=my.names\n  }\n  \n  # syntax for changing names setnames(cats, names(cats), c(\"id\", \"R1\", \"R2\", \"class\"))\n  setkey(cats, id)\n  return(cats)\n}\n\n# To avoid integer underflow issue when we have too many very small or very large probabilities.\n# Take inverse of posterior probability, then take log, which simplifies to sum(log(q) - /sum(log(p))\n# and then reverse operations to convert answer back to a probability.\n# param p: vector of p values for all reads aligning to junction\n# return posterior probability that this is a circular junction based on all reads aligned to it\ngetPprodByJunction <- function(p ){\n  out = tryCatch(\n    {\n      x = sum(log(p))  # use sum of logs to avoid integer underflow\n      return(exp(x))\n    },\n    error = function(cond){\n      print(cond)\n      print(p)\n      return(\"?\")\n    },\n    warning = function(cond){\n      print(cond)\n      print(p)\n      return(\"-\")\n    }\n  )\n  return(out)\n}\n\napplyToClass <- function(dt, expr) {\n  e = substitute(expr)\n  dt[,eval(e),by=is.pos]\n}\n\napplyToJunction <- function(dt, expr) {\n  e = substitute(expr)\n  dt[,eval(e),by=junction]\n}\n\n\n#######################################################################\n######################## BEGIN JS ADDITION ############################\n####################### FIRST JS FUNCTION #############################\n########################################################################\n################# JS added function to FIT the GLM using arbitrary two-classes\n\nmy.glm.model<-function(which_formula, linear_reads, decoy_reads,use_R2 , max.iter){\n  ### FUNCTION TO FIT GLM TO linear READS, returns the GLM and junction predictions,\n  saves = list()  # to hold all of the glms for future use\n  #max.iter = 2  # number of iterations updating weights and retraining glm\n  \n  # set up structure to hold per-read predictions\n  n.neg = nrow(decoy_reads)\n  n.pos = nrow(linear_reads)\n  n.reads = n.neg+n.pos\n  class.weight = min(n.pos, n.neg)\n  \n  ## note that this is coded as linear_reads and decoy_reads but applies to any pair class\n  \n  readPredictions = rbindlist(list(linear_reads, decoy_reads))\n  \n  # set initial weights uniform for class sum off all weights within any class is equal\n  if (n.pos >= n.neg){\n    readPredictions[,cur_weight:=c(rep(n.neg/n.pos, n.pos), rep(1, n.neg))]\n  } else {\n    readPredictions[,cur_weight:=c(rep(1, n.pos), rep(n.pos/n.neg, n.neg))]\n  }\n  \n  # glm\n  \n  \n  \n  \n  for(i in 1:max.iter){\n    # M step: train model based on current read assignments, down-weighting the class with more reasourcds\n    \n    if (use_R2==1){\n      \n      if (which_formula==1){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==2){\n        x=glm( is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2 + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==3){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2 + Low_MaxOverlap:Maxoverlap + Med_MaxOverlap:Maxoverlap+ High_MaxOverlap:Maxoverlap, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==4){\n        x=glm(is.pos~overlap+lenAdjScore+qual +lenAdjScoreR2 + qualR2  + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      }\n      \n    }\n    if (use_R2==0){\n      \n      if (which_formula==1){\n        x=glm(is.pos~overlap+lenAdjScore+qual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==2){\n        x=glm( is.pos~overlap+lenAdjScore+qual + IsLowQual, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==3){\n        x=glm(is.pos~overlap+lenAdjScore+qual + Low_MaxOverlap:Maxoverlap + Med_MaxOverlap:Maxoverlap+ High_MaxOverlap:Maxoverlap, data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      } else if(which_formula==4){\n        x=glm(is.pos~overlap+lenAdjScore+qual + as.factor(MaxOverlap_Cat + 0), data=readPredictions, family=binomial(link=\"logit\"), weights=readPredictions[,cur_weight])\n      }\n      \n    }\n    saves[[i]] = x\n    \n    # get CI on the output probabilities and use 95% CI\n    preds = predict(x, type = \"link\", se.fit = TRUE)\n    critval = 1.96 # ~ 95% CI\n    upr = preds$fit + (critval * preds$se.fit)\n    lwr = preds$fit - (critval * preds$se.fit)\n    upr2 = x$family$linkinv(upr)\n    lwr2 = x$family$linkinv(lwr)\n    \n    # use the upper 95% value for decoys and lower 95% for linear\n    adj_vals = c(rep(NA, n.reads))\n    adj_vals[which(readPredictions$is.pos == 1)] = lwr2[which(readPredictions$is.pos == 1)]\n    adj_vals[which(readPredictions$is.pos == 0)] = upr2[which(readPredictions$is.pos == 0)]\n    x$fitted.values = adj_vals  # so I don't have to modify below code\n    \n    # report some info about how we did on the training predictions\n    totalerr = sum(abs(readPredictions[,is.pos] - round(x$fitted.values)))\n    print (paste(i,\"total reads:\",n.reads))\n    print(paste(\"both negative\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==0), \"out of \", n.neg))\n    print(paste(\"both positive\",sum(abs(readPredictions[,is.pos]+round(x$fitted.values))==2), \"out of \", n.pos))\n    print(paste(\"classification errors\", totalerr, \"out of\", n.reads, totalerr/n.reads ))\n    #print(coef(summary(x)))\n    readPredictions[, cur_p:=x$fitted.values] # add this round of predictions to the running totals\n    \n    # calculate junction probabilities based on current read probabilities and add to junction predictions data.table\n    \n    tempDT = applyToJunction(subset(readPredictions, is.pos == 1), getPprodByJunction(cur_p))\n    setnames(tempDT, \"V1\", paste(\"iter\", i, sep=\"_\")) # iter_x is the iteration of product of ps\n    setkey(tempDT, junction)\n    junctionPredictions = junctionPredictions[tempDT]  # join junction predictions and the new posterior probabilities\n    rm(tempDT)  # clean up\n    \n    # E step: weight the reads according to how confident we are in their classification. Only if we are doing another loop\n    if(i < max.iter){\n      posScale = class.weight/applyToClass(readPredictions,sum(cur_p))[is.pos == 1,V1]\n      negScale = class.weight/(n.neg - applyToClass(readPredictions,sum(cur_p))[is.pos == 0,V1])\n      readPredictions[is.pos == 1,cur_weight:=cur_p*posScale]\n      readPredictions[is.pos == 0,cur_weight:=((1 - cur_p)*negScale)]\n    }\n    setnames(readPredictions, \"cur_p\", paste(\"iter\", i, sep=\"_\")) # update names\n  }\n  \n  # calculate mean and variance for null distribution\n  ## this uses a normal approximation which holds only in cases with large numbers of reads, ie the CLT only holds as the number of reads gets very large\n  \n  ## should be called p-predicted\n  #read_pvals = readPredictions[,max.iter]\n  \n  # rename cols to be consistent with circular glmReports, syntax below removes col. \"ITER_1\"\n  if (max.iter>1){\n    # cleaning up\n    for (myi in c(1:(max.iter-1))){\n      junctionPredictions[, paste(\"iter_\",myi,sep=\"\"):=NULL]\n    }\n  }\n  setnames(junctionPredictions, paste(\"iter_\",max.iter,sep=\"\"), \"p_predicted\")\n  list(saves, junctionPredictions) ## JS these are the outputs and done with function\n}\n\n\n########################################################################\n###################### prediction from model ##########################\n##### as a function, needs input data and model\n\npredictNewClassP <- function(my_reads, null){ ## need not be circ_reads, just easier syntax\n  ######### up until this point, every calculation is PER READ, now we want a function to collapse\n  ######### want to do hypothesis testing\n  # calculate junction probabilities based on predicted read probabilities\n  ## Use simple function-- NOTE: \"p predicted\" is a CI bound not the point estimate. It is still technically a consistent estimate of p predicted\n  ## prob of an anomaly by glm is phat/(1+phat) under 'real' 1/(1+phat) under 'decoy' junction, so the ratio of these two reduces to 1/phat. as phat -> 1, no penalty is placed on anomaly.\n  \n  #merge\n  junctionPredictions = my_reads[, .N, by = junction] # get number of reads per junction\n  setnames(junctionPredictions, \"N\", \"numReads\")\n  setkey(junctionPredictions, junction)\n  \n  my_reads[, logproduct:=sum( log (p_predicted) * (1-is.anomaly) + log( 1/(1+p_predicted) *is.anomaly)), by=junction]\n  my_reads[,means_qual:=mean(qual), by=junction]    #Roozbeh added this new column for the average of mapping qualities to the report file\n means = my_reads[,list(junction,means_qual)]\n  junctionPredictions = merge(junctionPredictions,means)\n  \n  ## is anomaly adjusted log sum scoremm\n  logsum=my_reads[,sum( log ( p_predicted / (1+p_predicted*is.anomaly))), by=junction]\n  logsum_2=my_reads[,sum( log ( p_predicted_2 / (1+p_predicted_2*is.anomaly))), by=junction]\n  print (\"Logsum is reported which is equal to the sum of the logs of phats-- if exponentiated, corresponds to product of ps\")\n  \n  ## merge these new variables to the dataframe\n  junctionPredictions=merge(junctionPredictions,logsum)\n  setnames(junctionPredictions, \"V1\", \"logsum\")\n  \n  junctionPredictions=merge(junctionPredictions,logsum_2)\n  setnames(junctionPredictions, \"V1\", \"logsum_2\")\n  \n  print (names(junctionPredictions))\n  \n  ########### adding quantiles of p_predicted\n  n.quant=2\n  for (qi in 1:n.quant){\n    my_quantiles = my_reads[,round(10*quantile(p_predicted/(1+is.anomaly* p_predicted),probs=c(0:n.quant)/n.quant,na.rm=TRUE)[qi])/10,by=junction]\n    \n    # merge into junctionPredictions\n    #print (head(my_quantiles))\n    setkey(my_quantiles,junction)\n    junctionPredictions=merge(junctionPredictions,my_quantiles)\n    setnames(junctionPredictions, \"V1\", paste(\"q_\",qi,sep=\"\"))\n  }\n  \n  ##################################\n  ##  tempDT, to collapse across junctions\n  # p_predicteds are the exponentiation\n  junctionPredictions [ ,p_predicted_2:=exp(logsum_2),by=junction]\n  junctionPredictions [ ,p_predicted:=exp(logsum),by=junction]\n  \n  #print (head(junctionPredictions[order(junction),]))\n  \n  ## NOTE: P VALUE IS probability of observing a posterior as extreme as it is, \"getPvaluebyJunction\" is a bayesian posterior\n  junctionPredictionsWP=assignP(junctionPredictions,null)\n  \n  rm(tempDT)  # clean up\n  ## adding here:\n  \n  unique(junctionPredictionsWP) ## returned\n  \n}\n########################################################################################### ASSIGN p values through permutation\n###################################\nassignP<-function(junctionPredictions,null) {\n  # logsum is the logged sum\n  # add p-value to junctionPredictions (see GB supplement with logic for this)\n  \n  lognull=log(null)\n  \n  use_mu = mean(lognull) # this is actually the mean of the read level predictions\n  use_var=var(lognull)\n  ## for large n,\n  #print (\"using cdf of null distribution as \"p_value\" which is misnomer for convenient and replaced below \")\n  n.thresh.exact=15\n  print (n.thresh.exact)\n  \n  junctionPredictions[ (numReads>n.thresh.exact) , p_value :=  pnorm((logsum - numReads*use_mu)/sqrt(numReads*use_var))]\n  \n  junctionPredictions[ (numReads>n.thresh.exact) , p_value_2 :=  pnorm((logsum_2 - numReads*use_mu)/sqrt(numReads*use_var))]\n  \n  ## make empirical distribution of posteriors:\n  \n  print (\"exact calculation through sampling 10K p predicted\")\n  my.dist=list(n.thresh.exact)\n  for ( tempN in 1:n.thresh.exact){ #### get distributions to convolve in next loop\n    n.sampled=1000 # used to compute the null distribution of posteriors\n    my.dist[[tempN]]=sample(lognull, n.sampled, replace=T)\n  }\n  \n  for ( tempN in 1:n.thresh.exact){ ## use this loop to assign jncts w/ tempN\n    sim.readps=my.dist[[1]]\n    if (tempN>1){\n      for (tj in 2: tempN){ # loop, taking products\n        sim.readps=my.dist[[tj]] +  sim.readps\n      }\n    }\n    # convert to posterior\n    ## fraction of time p_predicted is smaller than -- so if p_predicted is very large, the fraction of time it is smaller is big\n    ## use the null to compute p_vals\n    #print (head(junctionPredictions))\n    #print (paste(tempN, \"is value of readcount for exact calculation and length of sim reads is \",length(sim.readps)))\n    \n    junctionPredictions [ (numReads == tempN ), p_value:= sum( exp(sim.readps)<p_predicted)/length(sim.readps),by=junction]\n    \n    #print (\"if below table is not empty, ERROR\")\n    #print (junctionPredictions[p_value>1])\n    \n    \n    junctionPredictions [ (numReads == tempN ), p_value_2:= sum( exp(sim.readps)<p_predicted_2)/length(sim.readps), by=junction]\n    \n  }\n  return(junctionPredictions)\n}\n###########################################################################################\n###########################################################################################\n###########################################################################################\n###########################################################################################\n######## END FUNCTIONS, BEGIN WORK #########\n\n## command line inputs\nuser.input=0\n\nno.indel.classfile=0\n\nif (user.input==0){\n  args = commandArgs(trailingOnly = TRUE)\n  fusion_class_input=args[1]\n  class_input=args[2]\n  srr= args[3]\n  output_dir=args[4]\n  reg_indel_class_input = args[5]\n  FJ_indel_class_input = args[6]\n  print (paste(\"outputdir\", output_dir))\n  ## should be:\n  #FJ_indel_class_input = paste(parentdir,srr,\"_output_FJIndels.txt\",sep=\"\")\n  #reg_indel_class_input = paste(parentdir,srr,\"_output_RegIndel.txt\",sep=\"\")\n}\n\nmax.iter=2 ## iterations for glm\n\nif (user.input==1){\n  output_dir=\"\"}\n\nuse.indels=1\nuse.fusion=1\n\n## define output class files\nglm_out = paste(output_dir,srr,\"_DATAOUT\",sep=\"\")\nanomaly_glm_out = paste(output_dir,srr,\"_AnomalyDATAOUT\",sep=\"\")\n\nindel_glm_out = paste(output_dir,srr,\"_IndelDATAOUT_MACHETE\",sep=\"\")\nlinear_juncp_out = paste(output_dir,srr,\"_LINEARJUNCP_OUT_MACHETE\",sep=\"\")\ncirc_juncp_out = paste(output_dir,srr,\"_CIRC_JUNCP_OUT_MACHETE\",sep=\"\")\nfusion_juncp_out = paste(output_dir,srr,\"_FUSION_JUNCP_OUT_MACHETE\",sep=\"\")\nlinearwanomaly_juncp_out = paste(output_dir,srr,\"_LINEAR_W_ANOMALY_JUNCP_OUT_MACHETE\",sep=\"\")\nfusionwanomaly_juncp_out= paste(output_dir,srr,\"_FUSION_W_ANOM_JUNCPOUT_MACHETE\", sep=\"\")\nfusionwanomaly_and_indel_juncp_out= paste(output_dir,srr,\"_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_MACHETE\", sep=\"\")\n####### CURRENT GOAL IS TO UPDATE LINEAR pvalues w/ anomaly reads\nlinear_juncp_update_out = paste(output_dir,srr,\"_LINEARJUNCP_UPDATED_OUT_MACHETE\",sep=\"\")\n##### SINK THE SUMMARY OF THIS SCRIPT\nprint (paste(\"OUtput dir\", fusionwanomaly_and_indel_juncp_out))\n#sink(paste(output_dir,srr,\"_glmInformation_\",sep=\"\"))\n\n### DONE W/ LOOP\n\n\nmy.names=\"none\" ## this is bc Gillians fields are not names like Lindas are\nmyClasses = processClassInput(class_input, my.names)\n\nif (use.fusion==1){\n  print (paste(\"using \", fusion_class_input))\n  myClassesFusion = processClassInput(fusion_class_input,names(myClasses))\n}\nif (use.indels==1){\n  print (paste(\"using \", reg_indel_class_input,\" and \" , FJ_indel_class_input))\n  myClassesRegIndel = processClassInput(reg_indel_class_input,names(myClasses))\n  myClassesFJIndel = processClassInput(FJ_indel_class_input,names(myClasses))\n}\n\nprint(paste(\"class info processed\", dim(myClasses)))\n\ncirc_reads = myClasses[(tolower(class) %like% 'circ'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\ncirc_reads = addDerivedFields(circ_reads, 1)\ncirc_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\nprint (\"finished circ_reads\")\n\ndecoy_reads = myClasses[(tolower(class) %like% 'decoy'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\ndecoy_reads = addDerivedFields(decoy_reads, 0)\ndecoy_reads [, is.anomaly:=1] ######## this IS an anomaly type\n\nprint (\"finished decoy_reads\")\n## was\nlinear_reads = myClasses[(tolower(class) %like% 'linear'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\nlinear_reads = addDerivedFields(linear_reads, 1)\nlinear_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n\nprint (\"finished linear_reads\")\n\nanomaly_reads = myClasses[(tolower(class) %like% 'anomaly'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\nanomaly_reads [, is.anomaly:=1]\nprint (\"finished anomaly_reads\")\n\nif (use.indels==1){\n  ## in analogy, we first define all indels, then assign good and bad\n  ## we will use anomaly field as a general term for 'anomaly mapping and indel'\n  reg_indel_reads = myClassesRegIndel[, list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\n  reg_indel_reads [, is.anomaly:=1]\n  print (\"Finished reg indels\")\n  \n  compatible_indel_reads = myClassesRegIndel[(tolower(class) %like% 'good'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\n  compatible_indel_reads [, is.anomaly:=1]\n  \n  incompatible_indel_reads = myClassesRegIndel[(tolower(class) %like% 'bad'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\n  incompatible_indel_reads [, is.anomaly:=1]\n  \n  FJ_indel_reads = myClassesFJIndel[, list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]\n  FJ_indel_reads [, is.anomaly:=1]\n  \n  if (dim(FJ_indel_reads)[1]==0){\n    no.indel.classfile = 1\n  } else{\n    FJ_indel_reads = addDerivedFields(FJ_indel_reads, 1)\n    \n  }\n  \n}\n\nif (use.fusion==1){\n  \n  #was na.omit\n  fusion_reads = (myClassesFusion[(tolower(class) %like% 'fjgood'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),])\n  fusion_reads = addDerivedFields(fusion_reads, 1)\n  fusion_reads [, is.anomaly:=0] ## this is not an anomaly type so WILL NOT have p value ajustment\n  \n  print (\"ANOMALY fusions defined as FJ bad-- of any variety\")\n  anomaly_fusion_reads = (myClassesFusion[(tolower(class) %like% 'fjbad'), list(id, pos, qual, aScore, numN, readLen, junction, qualR2,aScoreR2, numNR2, readLenR2,strand,junctionR2),]) # GILLIAN, pls comment here on what FJ bad is for the sake of documentation\n  \n  anomaly_fusion_reads = addDerivedFields(anomaly_fusion_reads, 1)\n  anomaly_fusion_reads [, is.anomaly:=1] ## this is not an anomaly type so WILL NOT have p value ajustment\n}\n###############################################################################################\n## CANNOT ADD DERIVED FIELDS HERE BECAUSE WE DON'T KNOW WHICH ANOMALIES ARE GOOD AND/OR BAD\n##################### DERIVED FIELDS ADDED LATER ##############################################\n###############################################################################################\n\n# set up data structure to hold per-junction predictions\njunctionPredictions = linear_reads[, .N, by = junction] # get number of reads per junction\nsetnames(junctionPredictions, \"N\", \"numReads\")\nsetkey(junctionPredictions, junction)\n\n#### TRAIN EM ####\n## this should be a function of any two classes; and the output will be the model\n\n##\n\nn.row= dim(linear_reads)[1]\nn.sample=min(n.row,10000)\n\n#syntax example decoy_reads[,p_predicted:=NULL]\nprint (\"calling linear decoy model\")\nlinearDecoyGLMoutput = my.glm.model (4, linear_reads[ sample(n.row,n.sample,replace=FALSE),], decoy_reads, 1, max.iter) ## 0 does not use R2 info\n\nsaves = linearDecoyGLMoutput[[1]]\nlinearJunctionPredictions =  linearDecoyGLMoutput[[2]]\n#save(saves, file=glm_out)  # save models\nlinearDecoyGLM = saves[[max.iter]] ##### this is the glm model\n\n## after fitting the GLM to linear vs. decoy, we want to store linear junction predictions in order to subset anomalies\n######## JS ADDITION: NOTE- NOT stratifying on permutation p value, although could add this too\n\n\n############################################################################\n### START LINEARS\n################# predict on anomaly reads -- AND TEST HOW THIS IMPACTS LINEAR PREDICTIONS\n############################ linear predictions ONLY ON THE BASIS of anomalies...\n\npreds = predict(linearDecoyGLM, newdata=linear_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\nlinear_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\nlinear_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n## for null\nprint (\"Assigning null distribution for all linear reads\")\nnull=linear_reads$p_predicted\n\n### ASSIGN p value:\nlinearJunctionPredictionsForModels = predictNewClassP(linear_reads, null)\n\npGoodThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.8,na.rm=TRUE)\ngood.linear=linearJunctionPredictionsForModels[p_value> pGoodThresh,]\n\npBadThresh=quantile(linearJunctionPredictionsForModels$p_value,prob=.2,na.rm=TRUE)\nbad.linear=linearJunctionPredictionsForModels[p_value< pBadThresh,]\n#####################################\n\n\n############## done with linears\n\n# define two classes of anomalies: those from good vs. bad junctions\n\n\ngood_anomaly_reads= anomaly_reads[!is.na(match(junction, good.linear$junction)),]\nbad_anomaly_reads= anomaly_reads[!is.na(match(junction, bad.linear$junction)),]\n## NOW add derived fields\n\nif (use.indels==1){\n  # define two classes of regular INDELS for training: those from good vs. bad junctions\n  \n  good_indel_reads= compatible_indel_reads[!is.na(match(junction, good.linear$junction)),]\n  bad_indel_reads= incompatible_indel_reads[!is.na(match(junction, bad.linear$junction)),]\n  \n  ## if either class is empty, change use.indels to zero\n  \n  if (min(dim(good_indel_reads)[1],dim(bad_indel_reads)[1])<20){\n    print (\"CHANGING TO INDELS=0 becuase too few reads\")\n    use.indels=0\n  }\n  \n  \n}\n\n##### now, re-run script training on anomalies from good vs. bad\n\nuse.anomaly = 1\n\nif (dim(good_anomaly_reads)[1]==0 & dim(bad_anomaly_reads)[1]==0){\n  use.anomaly = 0\n}\n\nif (min(dim(good_anomaly_reads)[1], dim(bad_anomaly_reads)[1]) > 0){\n  ## The \"1\" belowneeds to be 0 and 1 for good and bad anomalies\n  good_anomaly_reads = addDerivedFields(good_anomaly_reads, 1) ####\n  bad_anomaly_reads = addDerivedFields(bad_anomaly_reads, 0) ####\n  all_anomaly_reads=rbind(good_anomaly_reads,bad_anomaly_reads)\n  \n  ######## now, RECALL GLM  FOR ANOMALY READ MAPPERS\n  print (\"calling good anomaly bad anomaly model with .8 and .2 as thresholds\")\n  AnomInfo = my.glm.model (4,good_anomaly_reads, bad_anomaly_reads,1, max.iter) ## JS these are the outputs and done with function\n  ANOMALYsaves=AnomInfo[[1]]\n  ANOMALYjunctionPredictions=AnomInfo[[2]]\n  AnomalyGLM = ANOMALYsaves[[max.iter]] ##### this is the glm model\n  \n  preds = predict(AnomalyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n  \n  lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n  lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n  \n  all_anomaly_reads[, p_predicted:= AnomalyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n  all_anomaly_reads[, p_predicted_2:= AnomalyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n  use.anomaly = 2\n  \n} else{\n  if(dim(good_anomaly_reads)[1]>0){\n    all_anomaly_reads = addDerivedFields(good_anomaly_reads, 1)\n    \n    preds = predict(linearDecoyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n    \n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n    \n    all_anomaly_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    all_anomaly_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    \n  }\n  if(dim(bad_anomaly_reads)[1]>0){\n    all_anomaly_reads = addDerivedFields(bad_anomaly_reads, 1)\n    \n    preds = predict(linearDecoyGLM, newdata=all_anomaly_reads, type = \"link\", se.fit = TRUE)\n    \n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n    \n    all_anomaly_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    all_anomaly_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    \n  }\n}\n\n## in anaolgy, same for INDELS\nif (use.indels==1){\n  good_indel_reads = addDerivedFields(good_indel_reads, 1) ####\n  bad_indel_reads = addDerivedFields(bad_indel_reads, 0) ####\n  all_indel_reads=rbind(good_indel_reads,bad_indel_reads)\n}\n\nif (use.indels==1){\n  print (\"calling INDEL model with .8 and .2 as thresholds\")\n  IndelInfo = my.glm.model (1,good_indel_reads, bad_indel_reads,1, max.iter) ## JS these are the outputs and done with function\n  INDELsaves=IndelInfo[[1]]\n  INDELjunctionPredictions=IndelInfo[[2]]\n  IndelGLM = INDELsaves[[max.iter]] ##### this is the glm model\n}\nif (use.indels==0){\n  print (\"USING GLM MODEL for INDEL MODEL\")\n  INDELsaves = linearDecoyGLMoutput[[1]]\n  INDELlinearJunctionPredictions =  linearDecoyGLMoutput[[2]]\n  IndelGLM = linearDecoyGLM\n}\n\n## save GLMS\n#save(AnomalyGLM, file=anomaly_glm_out)  # save models\nif (use.indels==1){\n  save(IndelGLM, file=indel_glm_out)  # save models\n}\n#save(linearDecoyGLM, file=glm_out)  # save models\n\npreds = predict(linearDecoyGLM, newdata=decoy_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\nlwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\ndecoy_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ndecoy_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n\n\n## need to rbind anomaly junctions\nif (use.anomaly != 0){\n  linear_and_anomaly=rbind(all_anomaly_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], linear_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n} else{\n  linear_and_anomaly = linear_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)]\n}\n\n\nlinearWithAnomalyJunctionPredictions = predictNewClassP(linear_and_anomaly, null)\n\n################# DONE WITH LINEARS\n#########################################################################\n\n#### PREDICT CIRCULAR JUNCTIONS #### SHOULD MAKE THIS MODULAR AND A FUNCTION so Farjunction and Anomalies can be used\n## SIMPLE PREDICT ON CIRCLES\npreds = predict(linearDecoyGLM, newdata=circ_reads, type = \"link\", se.fit = TRUE)\nlwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\nlwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n\ncirc_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\ncirc_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\ncircularJunctionPredictions = predictNewClassP(circ_reads, null)\n\n#########################################################################\n## start fusions ############################################################################\n############################################################################\n################# NOTE: Here, we are only using fusion reads not fusion anomaly reads and treating the prediction just like circle\n############################################################################\n############################################################################\n## start prediction on good far junctions\n\nif (use.fusion==1){\n  fusion_reads$overlap=as.numeric(as.vector(fusion_reads$overlap))\n  preds = predict(linearDecoyGLM, newdata=fusion_reads, type = \"link\", se.fit = TRUE)\n  lwr = preds$fit - (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n  lwr_2 = preds$fit - 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n  \n  fusion_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n  fusion_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n  fusionJunctionPredictions = predictNewClassP( fusion_reads, null)\n  \n  \n  if(use.anomaly == 2){\n    # start prediction on BAD=Anomaly mapping\n    print (\"done with fusion normals, starting anomalies\")\n    \n    preds = predict(AnomalyGLM, newdata=anomaly_fusion_reads, type = \"link\", se.fit = TRUE)\n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n    \n    anomaly_fusion_reads[, p_predicted:= AnomalyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    anomaly_fusion_reads[, p_predicted_2:= AnomalyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    \n    linear_and_anomaly_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n    linear_and_anomaly_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_fusions$overlap))\n    linearWithAnomalyFusionPredictions = predictNewClassP(linear_and_anomaly_fusions, null)\n    \n    # start prediction on INDELS mapping\n    print (\"done with fusion anomalies starting indels\")\n  } else{\n    preds = predict(linearDecoyGLM, newdata=anomaly_fusion_reads, type = \"link\", se.fit = TRUE)\n    lwr = preds$fit + (1.96 * preds$se.fit)  # ~ higher 95% CI to be conservative\n    lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ higher 99% CI to be conservative\n    \n    anomaly_fusion_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n    anomaly_fusion_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n    \n    linear_and_anomaly_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n    linear_and_anomaly_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_fusions$overlap))\n    linearWithAnomalyFusionPredictions = predictNewClassP(linear_and_anomaly_fusions, null)\n  }\n}\n\nif (use.indels==1 & no.indel.classfile==0){\n  FJ_indel_reads$overlap=as.numeric(as.vector(FJ_indel_reads$overlap))\n  preds = predict(IndelGLM, newdata=FJ_indel_reads, type = \"link\", se.fit = TRUE)\n  lwr = preds$fit + (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n  lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n  \n  FJ_indel_reads[, p_predicted:= IndelGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n  FJ_indel_reads[, p_predicted_2:= IndelGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n  \n  linear_and_anomaly_and_indel_fusions=rbind(FJ_indel_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)],anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n}\n\n\n\nif (use.indels==0 & no.indel.classfile==0){\n  ## if not using indels, we assign indel reads according to the linear decoy model\n  preds = predict(linearDecoyGLM, newdata=FJ_indel_reads, type = \"link\", se.fit = TRUE)\n  lwr = preds$fit + (1.96 * preds$se.fit)  # ~ lower 95% CI to be conservative\n  lwr_2 = preds$fit + 2*(1.96 * preds$se.fit)  # ~ lower 99% CI to be conservative\n  FJ_indel_reads[, p_predicted:= linearDecoyGLM$family$linkinv(lwr)] # add lower 95% CI prediction\n  FJ_indel_reads[, p_predicted_2:= linearDecoyGLM$family$linkinv(lwr_2)] # add lower 95% CI prediction\n  \n  linear_and_anomaly_and_indel_fusions=rbind(FJ_indel_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)],anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n  \n}\n\nif (no.indel.classfile==1){\n  linear_and_anomaly_and_indel_fusions=rbind(anomaly_fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)], fusion_reads[,list(qual,lenAdjScore,qualR2,lenAdjScoreR2,junction,is.pos,overlap,is.anomaly,p_predicted,p_predicted_2)])\n  \n}\n\nlinear_and_anomaly_and_indel_fusions$overlap=as.numeric(as.vector(linear_and_anomaly_and_indel_fusions$overlap))\nlinearWithAnomalyAndIndelFusionPredictions = predictNewClassP(linear_and_anomaly_and_indel_fusions, null)\n\nconsolidated_fusion=merge(fusionJunctionPredictions,linearWithAnomalyFusionPredictions , all=TRUE,by=\"junction\")\nconsolidated_fusion[,p_diff:=(p_predicted.x-p_predicted.y)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\nconsolidated_fusion=data.table(unique(consolidated_fusion))\n\n####### now add indels\n#verbose adds extra output and extra info to indel table\nverbose=0\n\nprint (\"now adding indels and changing names to reflect accurate terminology\")\nconsolidated_fusion_windel=merge(linearWithAnomalyFusionPredictions ,linearWithAnomalyAndIndelFusionPredictions, all=TRUE,by=\"junction\")\nconsolidated_fusion_windel[,p_diff_indel:=(p_predicted.y-p_predicted.x)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\nconsolidated_fusion_windel=data.table(unique(consolidated_fusion_windel))\n\nsetnames(consolidated_fusion_windel,\"p_predicted.x\", \"productPhat.x\")\nsetnames(consolidated_fusion_windel,\"p_predicted.y\", \"productPhat.y\")\nsetnames(consolidated_fusion_windel,\"p_value.x\", \"junction_cdf.x\")\nsetnames(consolidated_fusion_windel,\"p_value.y\", \"junction_cdf.y\")\n\n\nsetnames(consolidated_fusion_windel,\"p_predicted_2.x\", \"productPhat_lower.x\")\nsetnames(consolidated_fusion_windel,\"p_predicted_2.y\", \"productPhat_lower.y\")\nsetnames(consolidated_fusion_windel,\"p_value_2.x\", \"junction_cdf_lower.x\")\nsetnames(consolidated_fusion_windel,\"p_value_2.y\", \"junction_cdf_lower.y\")\n\nsetnames(consolidated_fusion_windel,\"p_diff_indel\", \"junction_cdf_windel_diff\")\nif (verbose==0){\n  consolidated_fusion_windel[,q_1.y:=NULL]\n  consolidated_fusion_windel[,q_2.y:=NULL]\n  consolidated_fusion_windel[,q_1.x:=NULL]\n  consolidated_fusion_windel[,q_2.x:=NULL]\n  consolidated_fusion_windel[,logsum.x:=NULL]\n  consolidated_fusion_windel[,logsum.y:=NULL]\n}\n\n## fusion_reads merging\n## JS ADD 8/14\nfusion_reads[strand!=0,maxNegStrandOverlap:=max(overlap),by=junction]\nfusion_reads[strand==0,maxPosStrandOverlap:=max(overlap),by=junction]\nout_fusions=merge(merge(consolidated_fusion_windel, unique(fusion_reads[strand==0,list(junction,maxPosStrandOverlap)]),by=\"junction\",add.x=TRUE), unique(fusion_reads[strand!=0,list(junction,maxNegStrandOverlap)]),by=\"junction\",add.x=TRUE)\n\nout_fusions_left_joint=merge(merge(consolidated_fusion_windel, unique(fusion_reads[strand==0,list(junction,maxPosStrandOverlap)]),by=\"junction\",all.x=TRUE), unique(fusion_reads[strand!=0,list(junction,maxNegStrandOverlap)]),by=\"junction\",all.x=TRUE)\n\nfusionwanomaly_and_indel_juncp_out_left_joint= paste(output_dir,srr,\"_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_MACHETE_LEFT_JOIN\", sep=\"\")\n\nwrite.table(unique(out_fusions)[order(-junction_cdf.y),], fusionwanomaly_and_indel_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\nwrite.table(unique(out_fusions_left_joint)[order(-junction_cdf.y),], fusionwanomaly_and_indel_juncp_out_left_joint, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n\ncir.verbose=0\n####################################################################################\n####################################################################################\nif (cir.verbose==1){\n  ## write circle prediction\n  \n  setnames(circularJunctionPredictions,\"p_predicted\", \"productPhat.x\")\n  setnames(circularJunctionPredictions,\"p_predicted_2\", \"productPhat_lower.x\")\n  setnames(circularJunctionPredictions,\"p_value_2\", \"junction_cdf_lower.x\")\n  setnames(circularJunctionPredictions,\"p_value\", \"junction_cdf\")\n  \n  write.table(unique(linearJunctionPredictions), linear_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n  write.table(unique(circularJunctionPredictions), circ_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n  \n  ## with anomalies, p value should be smaller so p_diff should always be negative...\n  consolidated_linear=merge(linearWithAnomalyJunctionPredictions,linearJunctionPredictions,by=\"junction\",all=TRUE)\n  consolidated_linear[,p_diff:=(p_predicted.x-p_predicted.y)] ## p_predicted.x should be less than p_predicted.y always so p_diff should be neegative\n  consolidated_linear=data.table(unique(consolidated_linear))\n  write.table(unique(consolidated_linear), linearwanomaly_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n  \n  ##\n  my.null.quantiles=quantile(linear_reads$p_predicted,probs=c(0:10)/10,na.rm=TRUE)\n  ## refer fusions to these quantiles; 'falsely called' vs. true will be fraction of linears (conservative estimate) ; error at this quantile can be evaluated.\n  \n  write.table(unique(fusionJunctionPredictions[order(-p_predicted),]),fusion_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n  write.table(unique(consolidated_fusion)[order(-p_predicted.y),], fusionwanomaly_juncp_out, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n  \n}"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:contributors": [
          "roozbehdn",
          "milos_jordanski"
        ],
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "fusion_class_input": {
              "path": "/path/to/fusion_class_input.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "FJ_indel_class_input": {
              "path": "/path/to/FJ_indel_class_input.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "sample_name"
              }
            },
            "class_input": {
              "path": "/path/to/class_input.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "sample_name"
              }
            },
            "reg_indel_class_input": {
              "path": "/path/to/reg_indel_class_input.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            }
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520439271,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520439301,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 12 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522638590,
            "sbg:revision": 2,
            "sbg:revisionNotes": "added IslowQual and other new parameters to glm script",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522679431,
            "sbg:revision": 3,
            "sbg:revisionNotes": "n.row= dim(decoy_reads)[1]",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522681170,
            "sbg:revision": 4,
            "sbg:revisionNotes": "n.row= dim(linear_reads)[1] and penalize 2 times more decoy_reads",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522682050,
            "sbg:revision": 5,
            "sbg:revisionNotes": "n.row= dim(linear_reads)[1] and penalize 2 time more decoy reads",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522689184,
            "sbg:revision": 6,
            "sbg:revisionNotes": "n.row= dim(linear_reads)[1] and penalize 5 times more decoy_reads",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522702747,
            "sbg:revision": 7,
            "sbg:revisionNotes": "n.row= dim(linear_reads)[1] and penalize 10 times more decoy_reads",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522705024,
            "sbg:revision": 8,
            "sbg:revisionNotes": "IsLowQual=1 if Mqual <=3",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522715308,
            "sbg:revision": 9,
            "sbg:revisionNotes": "IsLowQual =1 if Mqual<=3",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522718522,
            "sbg:revision": 10,
            "sbg:revisionNotes": "IsLowQual: as.numeric(x[\"qual\"]) <= 5",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522723930,
            "sbg:revision": 11,
            "sbg:revisionNotes": "IsLowQual=1 if mqual<=3",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522822734,
            "sbg:revision": 12,
            "sbg:revisionNotes": "MaxOverlap_Cat is added to the GLM model and IsLowqual is removed.",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522830160,
            "sbg:revision": 13,
            "sbg:revisionNotes": "Maxoverlap <=50: MaxOverlap_Cat := 0\nMaxoverlap > 50: MaxOverlap_Cat := 1",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522851801,
            "sbg:revision": 14,
            "sbg:revisionNotes": "back to revision 1",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522890625,
            "sbg:revision": 15,
            "sbg:revisionNotes": "use model 4 only for linear, anomaly glms\nmodel 1 for indel",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522900080,
            "sbg:revision": 16,
            "sbg:revisionNotes": "add average mapping qulaity of the aligned reads to the output file",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1522910255,
            "sbg:revision": 17,
            "sbg:revisionNotes": "Back to revision 1",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522912078,
            "sbg:revision": 18,
            "sbg:revisionNotes": "Add average mapping quality of the aligned reads to the output file",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1523564124,
            "sbg:revision": 19,
            "sbg:revisionNotes": "model 4 has  as.factor(MaxOverlap_Cat + 0) +IsLowQual\nMaxoverlap_cat is set based on first and third quantiles",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1524093616,
            "sbg:revision": 20,
            "sbg:revisionNotes": "Back to original GLM model with original predictors",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1524196317,
            "sbg:revision": 21,
            "sbg:revisionNotes": "Only \"as.factor(MaxOverlap_Cat + 0)\" is added to as an predictor (without Islowqual).",
            "sbg:modifiedBy": "roozbehdn"
          },
          {
            "sbg:modifiedOn": 1524202034,
            "sbg:revision": 22,
            "sbg:revisionNotes": "Only IsLowQual is added to GLM",
            "sbg:modifiedBy": "roozbehdn"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_LINEAR_W_ANOMALY_JUNCP_OUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#linear_w_anomaly_juncp_out"
          },
          {
            "outputBinding": {
              "glob": "*_LINEARJUNCP_UPDATED_OUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#linear_juncp_updated_out"
          },
          {
            "outputBinding": {
              "glob": "*_LINEARJUNCP_OUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#linear_juncp_out"
          },
          {
            "outputBinding": {
              "glob": "*_IndelDATAOUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#indel_data_out"
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_JUNCPOUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_w_anomaly_juncp_out"
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_MACHETE_LEFT_JOIN"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_w_anomaly_and_indel_juncp_out_lef_join"
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_W_ANOM_AND_INDEL_JUNCPOUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_w_anomaly_and_indel_juncp_out"
          },
          {
            "outputBinding": {
              "glob": "*_FUSION_JUNCP_OUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#fusion_juncp_out"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#class_input",
              "glob": "*_DATAOUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#data_out"
          },
          {
            "outputBinding": {
              "glob": "*_CIRC_JUNCP_OUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#circ_juncp_out"
          },
          {
            "outputBinding": {
              "glob": "*_AnomalyDATAOUT_MACHETE"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#anomaly_data_out"
          }
        ],
        "label": "GLM_script_UseIndel_MACHETE_Known",
        "sbg:latestRevision": 22,
        "sbg:revisionNotes": "Only IsLowQual is added to GLM",
        "y": 852.9604400983355,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 5
            },
            "id": "#reg_indel_class_input",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 1
            },
            "id": "#fusion_class_input",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 2
            },
            "id": "#class_input",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "loadContents": true,
              "separate": true,
              "position": 6
            },
            "id": "#FJ_indel_class_input",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "roozbehdn",
        "sbg:image_url": null,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/glm-script-useindel/22",
        "successCodes": [],
        "stdout": "",
        "sbg:createdOn": 1520439271,
        "baseCommand": [
          "chmod",
          "+x",
          "GLM_script_UseIndel.r",
          "&&",
          "Rscript",
          "GLM_script_UseIndel.r"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 22,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/machete_glm:r"
          }
        ]
      },
      "inputs": [
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.reg_indel_class_input",
          "source": [
            "#MACHETE_RegIndels_ClassIDFile.output_RegIndel"
          ]
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.fusion_class_input",
          "source": [
            "#MACHETE_FarJuncNaiveReport_Known.IDs"
          ]
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.class_input",
          "source": [
            "#KNIFE_filterFDR.output"
          ]
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.FJ_indel_class_input",
          "source": [
            "#MACHETE_FJIndels_ClassIDFile_Known.output_FJIndels"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.linear_w_anomaly_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.linear_juncp_updated_out"
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.linear_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.indel_data_out"
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.fusion_w_anomaly_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.fusion_w_anomaly_and_indel_juncp_out_lef_join"
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.fusion_w_anomaly_and_indel_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.fusion_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.data_out"
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.circ_juncp_out"
        },
        {
          "id": "#GLM_script_UseIndel_MACHETE_Known.anomaly_data_out"
        }
      ],
      "sbg:x": 5145.884887576583,
      "sbg:y": 852.9604400983355
    },
    {
      "id": "#MACHETE_PEfinder_new",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python PEfinder.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/pefinder-new/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam_sorted_files)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 1791.294433441962,
        "id": "milos_jordanski/spachete-salzman-collaboration/pefinder-new/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1522771017,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "PEfinder.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Aug 26 11:35:23 2015\n\n@author: Gillian\n\"\"\"\n\nimport os\nimport glob\nimport argparse\nimport sys\nimport utils_os\n\n\nclass ReadInfo:\n    def __init__(self, ID, Q, MAPQ, C, X, side, offset = None, numOfBases = None):\n        self.id = ID\n        self.chromosome = C\n        if side == 0:\n            self.StartPosition = max(1, int(X) - int(args.window))\n            self.StopPosition = int(X) + int(args.window)\n        if side == \"R\":\n            self.StartPosition = int(X)\n            self.StopPosition = int(X) + int(args.window)\n        if side == \"L\":\n            self.StartPosition = max(1, int(X) - int(args.window))\n            self.StopPosition = int(X)\n\n\n\n        if Q in [\"0\", \"16\"] and int(MAPQ) >= 10:\n            if offset and numOfBases:\n                if offset <= (150 - int(args.overlap)) and (offset + numOfBases) >= (150 + int(args.overlap)):\n                    self.quality = 1\n                else:\n                    self.quality = 0\n\n            else: self.quality = 1\n        else:\n            self.quality = 0\n\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\ndef comparereads(read1, read2):\n    output = str(read1.id) + \"\\t\" + str(read1.chromosome) + \":\" + str(read1.StartPosition) + \"-\" + str(\n        read1.StopPosition) + \"\\t\" + str(read2.chromosome) + \":\" + str(read2.StartPosition) + \"-\" + str(\n        read2.StopPosition) + \"\\n\"\n\n    if read1.quality == 1 and read2.quality == 1:\n        if read1.chromosome != read2.chromosome:\n            fout.write(output)\n        elif read2.StartPosition < read1.StartPosition - UserBPdistance and read2.StopPosition < read1.StartPosition - UserBPdistance:\n            fout.write(output)\n        elif read2.StartPosition > read1.StopPosition + UserBPdistance and read2.StopPosition > read1.StopPosition + UserBPdistance:\n            fout.write(output)\n\n\n##  RUN MODE\n# parser=argparse.ArgumentParser()\n# parser.add_argument(\"-i\",\"--inputDir\", required = True, help = \"path to orig directory containing genome & reg files\")\n# parser.add_argument(\"-o\", \"--outputDir\", required = True, help = \"path to output directory\")\n# parser.add_argument(\"-w\", \"--window\", required=True, help = \"size = w of window where if read occurs at X, then window starts at X-w and ends at X+w\")\n# parser.add_argument(\"-n\",\"--UserBPdistance\", required = True, help = \"looking for PE > X base pairs apart. Linda's default window is 100K.\")\n# args=parser.parse_args()\n#\n#\n#\n# if args.inputDir[-1] != \"/\":\n#    inpath = args.inputDir + \"/\"\n# else:\n#    inpath = args.inputDir\n#\n# if args.outputDir[-1] != \"/\":\n#    outpath = args.outputDir + \"/\"\n# else:\n#    outpath = args.outputDir\n#\n# utils_os.createDirectory(outpath)\n#\n# UserBPdistance = int(args.UserBPdistance)\n#\n# print \"Analyzing\" + str(args.inputDir)\n#\n#\n##TESTING MODE\n##inpath = \"/Users/Gillian/Desktop/transcriptometest/\"\n##outpath = \"/Users/Gillian/Desktop/transcriptometest/\"\n##UserBPdistance = 100000\n#\n## change the input path to the path where your file exists\n# os.chdir(inpath)\n# FileList={}\n# FileStem={}\n#\n##create file list of paired files\n# for name in glob.glob(os.path.join(inpath,\"genome/sorted*.sam\")):\n#    (inpath1,filename)=os.path.split(name)\n#    if not filename in FileList:\n#        FileList[filename] =0\n#    FileList[filename]+=1\n# print FileList\n#\n## ran into problems with that every filename had a different unique stem, sometimes occurring\n## SAMESAME_SAME_SAME_DIFFERENT_SAME_SAME.sam and if you split this string by _ then\n## the \"different\" part occurs at a variable index each time.\n# i=1\n# if len(FileList)>2:\n#    for i in range(0,len(FileList.keys()[0].split(\"_\"))):\n#        if FileList.keys()[0].split(\"_\")[i] in [\"1\",\"2\"]:\n#            continue\n#        if FileList.keys()[0].split(\"_\")[i] != FileList.keys()[1].split(\"_\")[i] or FileList.keys()[0].split(\"_\")[i] != FileList.keys()[2].split(\"_\")[i]:\n#            break\n#\n# for name in FileList:\n#    stem = name.split(\"_\")[i]\n#    if not stem in FileStem:\n#        FileStem[stem] = 0\n#    FileStem[stem] +=1\n# print FileStem\n#\n#\n## for each pair of read1 and read2 files --\n# counter =0\n# for stem in FileStem:\n#    SamFiles = []\n#    for name in glob.glob(os.path.join(inpath+\"genome/\", \"sorted*\" + stem + \"*.sam\")):\n#        SamFiles.append(name)\n#    for name in glob.glob(os.path.join(inpath+\"reg/\", \"sorted*\"+ stem+\"*.sam\")):\n#        SamFiles.append(name)\n#\n#    print SamFiles\n\n\nparser = argparse.ArgumentParser()\n#parser.add_argument(\"-o\", \"--origDir\", required=True, help=\"orig directory\")\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\n#parser.add_argument(\"-f\", \"--outputDir\", required=True, help=\"Far Junctions directory (output dir)\")\nparser.add_argument(\"-w\", \"--window\", required=True,\n                    help=\"size = w of window where if read occurs at X, then window starts at X-w and ends at X+w\")\nparser.add_argument(\"-o\", \"--overlap\", help=\"overlap\", default=8)\nparser.add_argument(\"-n\", \"--UserBPdistance\", required=True,\n                    help=\"looking for PE > X base pairs apart. Linda's default window is 100K.\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\n\nparser.add_argument(\"-gens1\", \"--genomeSAM1\", required=True, help=\"Genome SAM file of first mate\")\nparser.add_argument(\"-gens2\", \"--genomeSAM2\", required=True, help=\"Genome SAM file of second mate\")\nparser.add_argument(\"-regs1\", \"--regularSAM1\", required=True, help=\"Regular junction SAM file of first mate\")\nparser.add_argument(\"-regs2\", \"--regularSAM2\", required=True, help=\"Regular junction SAM file of second mate\")\n\n\nargs = parser.parse_args()\n\n#if args.origDir[-1] != \"/\":\n#   inpath = args.origDir + \"/\"\n#else:\n#    inpath = args.origDir\n\n#if args.outputDir[-1] != \"/\":\n#    outpath = args.outputDir + \"/DistantPEFiles/\"\n#else:\n#    outpath = args.outputDir + \"DistantPEFiles/\"\n\n#utils_os.createDirectory(outpath)\n\nUserBPdistance = int(args.UserBPdistance)\n\n# change the input path to the path where your file exists\n#os.chdir(inpath)\n\n\n#genomefiles = sorted(glob.glob(inpath + \"genome/sorted*\" + args.stem + \"*.sam\"))\n#regfiles = sorted(glob.glob(inpath + \"reg/sorted*\" + args.stem + \"*.sam\"))\n\n#print genomefiles\n#print regfiles\n\n# print SamFiles\n# opening paired files\n#g1 = open(genomefiles[0], mode=\"rU\")\n#g2 = open(genomefiles[1], mode=\"rU\")\n#r1 = open(regfiles[0], mode=\"rU\")\n#r2 = open(regfiles[1], mode=\"rU\")\n\ng1 = open(args.genomeSAM1, mode=\"rU\")\ng2 = open(args.genomeSAM2, mode=\"rU\")\nr1 = open(args.regularSAM1, mode=\"rU\")\nr2 = open(args.regularSAM2, mode=\"rU\")\n\n# creating output files\nfout = open(args.sample + \"_distant_pairs.txt\", mode=\"w\")\nprint\"writing to output file: \" + args.sample + \"_distant_pairs.txt\"\nfout.write(\"Distant pairs more than \" + str(UserBPdistance) + \"BP apart in the genome: \\n\\nID\\tposition1\\tposition2\\n\")\nsys.stdout.flush()  # force print command above to output to screen (gives user an idea of progress)\n\n# get rid of headers\n\nline_raw2 = g2.next()\nline_raw4 = r2.next()\n\nwhile line_raw2[0] == \"@\":\n    line_raw2 = g2.next()\nwhile line_raw4[0] == \"@\":\n    line_raw4 = r2.next()\n\nlineG2 = line_raw2.strip().split(\"\\t\")\nlineR2 = line_raw4.strip().split(\"\\t\")\n# looping through reads in genome file 1\n\n\n\nfor line_raw1 in g1:\n    #        print \"in genome 1\"\n    if line_raw1[0] == \"@\":\n        continue\n    lineG1 = line_raw1.strip().split(\"\\t\")\n\n    # comparing to genome file 2\n\n    while ID(lineG2[0]) < ID(lineG1[0]) and lineG2 != [\"FILE_END\"]:\n        #            print \"genome 2 < genome 1\"\n        try:\n            lineG2 = g2.next().strip().split(\"\\t\")\n        except:\n            lineG2 = [\"FILE_END\"]\n\n    if ID(lineG1[0]) == ID(lineG2[0]):\n        #            print \"genome 1 and genome 2 match\"\n        #!!!!!!!!!!!!!!!!!!!!!!\n        readG1 = ReadInfo(ID(lineG1[0]), lineG1[1], lineG1[4], lineG1[2], lineG1[3], 0)\n        readG2 = ReadInfo(ID(lineG1[0]), lineG2[1], lineG2[4], lineG2[2], lineG2[3], 0)\n\n        #            fout.write(\"genome1 - genome 2:\\n\")\n        comparereads(readG1, readG2)\n\n        try:\n            lineG2 = g2.next().strip().split(\"\\t\")\n        except:\n            lineG2 = [\"FILE_END\"]\n\n    while ID(lineR2[0]) < ID(lineG1[0]) and lineR2 != [\"FILE_END\"]:\n        #            print \"reg2 < genome 1\"\n        try:\n            lineR2 = r2.next().strip().split(\"\\t\")\n        except:\n            lineR2 = [\"FILE_END\"]\n\n    if ID(lineG1[0]) == ID(lineR2[0]):\n        readG1 = ReadInfo(ID(lineG1[0]), lineG1[1], lineG1[4], lineG1[2], lineG1[3], 0)\n        R2loc = lineR2[2].replace(\"|\", \" \").replace(\":\", \" \").split(\" \")\n        if int(R2loc[2]) >= int(R2loc[4]):\n            read1R2 = ReadInfo(ID(lineR2[0]), lineR2[1], lineR2[4], R2loc[0], R2loc[2], \"R\", int(lineR2[3]), len(lineR2[9]))\n            read2R2 = ReadInfo(ID(lineR2[0]), lineR2[1], lineR2[4], R2loc[0], R2loc[4], \"L\", int(lineR2[3]), len(lineR2[9]))\n        else:\n            read1R2 = ReadInfo(ID(lineR2[0]), lineR2[1], lineR2[4], R2loc[0], R2loc[2], \"L\", int(lineR2[3]), len(lineR2[9]))\n            read2R2 = ReadInfo(ID(lineR2[0]), lineR2[1], lineR2[4], R2loc[0], R2loc[4], \"R\", int(lineR2[3]), len(lineR2[9]))\n\n        # fout.write(\"genome1 - reg 2: \\n\")\n        comparereads(readG1, read1R2)\n        comparereads(readG1, read2R2)\n\n        try:\n            lineR2 = r2.next().strip().split(\"\\t\")\n        except:\n            lineR2 = [\"FILE_END\"]\nr2.close()\ng2.close()\n\n# ===========LOOPING THROUGH REG 1 =============\n\ng2 = open(args.genomeSAM2, mode=\"rU\")\nr2 = open(args.regularSAM2, mode=\"rU\")\n\nlineG2 = g2.next().strip().split(\"\\t\")\nlineR2 = r2.next().strip().split(\"\\t\")\n\nwhile lineG2[0][0] == \"@\":\n    lineG2 = g2.next().strip().split(\"\\t\")\nwhile lineR2[0][0] == \"@\":\n    lineR2 = r2.next().strip().split(\"\\t\")\n\nfor line_raw3 in r1:\n\n    if line_raw3[0] == \"@\":\n        continue\n\n    lineR1 = line_raw3.strip().split(\"\\t\")\n\n    while ID(lineG2[0]) < ID(lineR1[0]) and lineG2 != [\"FILE_END\"]:\n        #           print lineG2[0][:-3] + \" < \" + lineR1[0][:-3]\n        #            print \"genome2 read < reg 1 read\"\n        try:\n            lineG2 = g2.next().strip().split(\"\\t\")\n        except:\n            lineG2 = [\"FILE_END\"]\n\n    if ID(lineR1[0]) == ID(lineG2[0]):\n        #            print \"reg1 and genome2 match\"\n        R1loc = lineR1[2].replace(\"|\", \" \").replace(\":\", \" \").split(\" \")\n        # print R1loc\n\n        if int(R1loc[2]) >= int(R1loc[4]):\n            read1R1 = ReadInfo(ID(lineR1[0]), lineR1[1], lineR1[4], R1loc[0], R1loc[2], \"R\", int(lineR1[3]), len(lineR1[9]))\n            read2R1 = ReadInfo(ID(lineR1[0]), lineR1[1], lineR1[4], R1loc[0], R1loc[4], \"L\", int(lineR1[3]), len(lineR1[9]))\n        else:\n            read1R1 = ReadInfo(ID(lineR1[0]), lineR1[1], lineR1[4], R1loc[0], R1loc[2], \"L\", int(lineR1[3]), len(lineR1[9]))\n            read2R1 = ReadInfo(ID(lineR1[0]), lineR1[1], lineR1[4], R1loc[0], R1loc[4], \"R\", int(lineR1[3]), len(lineR1[9]))\n\n        readG2 = ReadInfo(ID(lineG2[0]), lineG2[1], lineG2[4], lineG2[2], lineG2[3], 0)\n        #            fout.write(\"reg1 - genome 2: \\n\")\n        comparereads(read1R1, readG2)\n        comparereads(read2R1, readG2)\n\n        try:\n            lineG2 = g2.next().strip().split(\"\\t\")\n        except:\n            lineG2 = [\"FILE_END\"]\n\n    while ID(lineR2[0]) < ID(lineR1[0]) and lineR2 != [\"FILE_END\"]:\n        #            print \"reg2 read < reg 1 read\"\n        try:\n            lineR2 = r2.next().strip().split(\"\\t\")\n        except:\n            lineR2 = [\"FILE_END\"]\n\n    if ID(lineR1[0]) == ID(lineR2[0]):\n        R1loc = lineR1[2].replace(\"|\", \" \").replace(\":\", \" \").split(\" \")\n        #           print \"reg 1 and reg 2 match\"\n        if int(R1loc[2]) >= int(R1loc[4]):\n            read1R1 = ReadInfo(ID(lineR1[0]), lineR1[1], lineR1[4], R1loc[0], R1loc[2], \"R\", int(lineR1[3]), len(lineR1[9]))\n            read2R1 = ReadInfo(ID(lineR1[0]), lineR1[1], lineR1[4], R1loc[0], R1loc[4], \"L\", int(lineR1[3]), len(lineR1[9]))\n        else:\n            read1R1 = ReadInfo(ID(lineR1[0]), lineR1[1], lineR1[4], R1loc[0], R1loc[2], \"L\", int(lineR1[3]), len(lineR1[9]))\n            read2R1 = ReadInfo(ID(lineR1[0]), lineR1[1], lineR1[4], R1loc[0], R1loc[4], \"R\", int(lineR1[3]), len(lineR1[9]))\n\n        R2loc = lineR2[2].replace(\"|\", \" \").replace(\":\", \" \").split(\" \")\n        if int(R2loc[2]) >= int(R2loc[4]):\n            read1R2 = ReadInfo(ID(lineR1[0]), lineR2[1], lineR2[4], R2loc[0], R2loc[2], \"R\", int(lineR2[3]), len(lineR2[9]))\n            read2R2 = ReadInfo(ID(lineR1[0]), lineR2[1], lineR2[4], R2loc[0], R2loc[4], \"L\", int(lineR2[3]), len(lineR2[9]))\n        else:\n            read1R2 = ReadInfo(ID(lineR1[0]), lineR2[1], lineR2[4], R2loc[0], R2loc[2], \"L\", int(lineR2[3]), len(lineR2[9]))\n            read2R2 = ReadInfo(ID(lineR1[0]), lineR2[1], lineR2[4], R2loc[0], R2loc[4], \"R\", int(lineR2[3]), len(lineR2[9]))\n\n        # fout.write(\"reg1 - reg 2: \\n\")\n        comparereads(read1R1, read1R2)\n        comparereads(read1R1, read2R2)\n        comparereads(read2R1, read1R2)\n        comparereads(read2R1, read2R2)\n\n        try:\n            lineR2 = r2.next().strip().split(\"\\t\")\n        except:\n            lineR2 = [\"FILE_END\"]\n\nfout.close()\ng1.close()\ng2.close()\nr1.close()\nr2.close()"
              },
              {
                "filename": "utils_os.py",
                "fileContent": "import os\nimport errno\nimport re\n\n\n# create directory if it does not exist\ndef createDirectory(dirPath):\n    try:\n        if not os.path.isdir(dirPath):\n            os.makedirs(dirPath)\n    except OSError, e:\n        if e.errno != errno.EEXIST:\n            raise\n\n\n# parse a string of interest out of a filename\ndef getFileId(patt, grp, filename):\n    match = patt.search(filename)\n    if match:\n        return match.group(grp)\n    else:\n        print \"filename not structured correctly: \" + str(filename)\n\n\n# good way to grep, particularly for large files\ndef grep(pattern, file_obj, include_line_nums=False):\n    grepper = re.compile(pattern)\n    for line_num, line in enumerate(file_obj):\n        if grepper.search(line):\n            if include_line_nums:\n                yield (line_num, line)\n            else:\n                yield line"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "discordant_distance": 10,
            "mode": "complete",
            "window": 6,
            "overlap": 1,
            "regular_sam_sorted_files": [
              {
                "path": "/path/to/regular_sam_sorted_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/regular_sam_sorted_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "genome_sam_sorted_files": [
              {
                "path": "/path/to/genome_sam_sorted_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/genome_sam_sorted_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520437658,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520437724,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 9 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1522771017,
            "sbg:revision": 2,
            "sbg:revisionNotes": "rev10 copied",
            "sbg:modifiedBy": "milos_jordanski"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_distant_pairs.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam_sorted_files)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n  \treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#distant_pairs"
          }
        ],
        "label": "MACHETE PEfinder new",
        "sbg:latestRevision": 2,
        "sbg:revisionNotes": "rev10 copied",
        "y": 358.01567283925107,
        "inputs": [
          {
            "label": "Size of window",
            "sbg:includeInPorts": false,
            "required": false,
            "description": "Size of window, where if read occurs at X, then window starts at X-w and ends at X+w",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.window)\n    {\n    \treturn \"-w \" + $job.inputs.window\n    }\n  \treturn \"-w 10000\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#window",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tcmd = \"\"\n  \tgenome = [].concat($job.inputs.regular_sam_sorted_files)\n   \t\n    for (i=0; i<genome.length; i++)\n    {\n    \tif(genome[i].metadata && genome[i].metadata.paired_end && genome[i].metadata.paired_end==\"1\")\n        {\n        \tcmd += \" -regs1 \" + genome[i].path\n            continue\n        }\n      \tif(genome[i].metadata && genome[i].metadata.paired_end && genome[i].metadata.paired_end==\"2\")\n        {\n        \tcmd += \" -regs2 \" + genome[i].path\n            continue\n        }\n      \t\n     }\n  \treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#regular_sam_sorted_files",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "sbg:includeInPorts": true,
            "sbg:altPrefix": "--overlap",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-o"
            },
            "id": "#overlap",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "sbg:altPrefix": "--mode",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-m"
            },
            "id": "#mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tcmd = \"\"\n  \tgenome = [].concat($job.inputs.genome_sam_sorted_files)\n   \t\n    for (i=0; i<genome.length; i++)\n    {\n    \tif(genome[i].metadata && genome[i].metadata.paired_end && genome[i].metadata.paired_end==\"1\")\n        {\n        \tcmd += \" -gens1 \" + genome[i].path\n            continue\n        }\n      \tif(genome[i].metadata && genome[i].metadata.paired_end && genome[i].metadata.paired_end==\"2\")\n        {\n        \tcmd += \" -gens2 \" + genome[i].path\n            continue\n        }\n      \t\n     }\n  \treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#genome_sam_sorted_files",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "label": "Minimal distance for paired end reads to be considered as discordant",
            "sbg:includeInPorts": false,
            "required": false,
            "description": "looking for PE > distance base pairs apart (default 100K)",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.discordant_distance)\n    {\n    \treturn \"-n \" + $job.inputs.discordant_distance\n    }\n  \treturn \"-n 100000 \"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#discordant_distance",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "milos_jordanski",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "PEfinder.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520437658
      },
      "inputs": [
        {
          "id": "#MACHETE_PEfinder_new.window",
          "default": 10000,
          "source": [
            "#window"
          ]
        },
        {
          "id": "#MACHETE_PEfinder_new.regular_sam_sorted_files",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_PEfinder_new.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#MACHETE_PEfinder_new.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#MACHETE_PEfinder_new.genome_sam_sorted_files",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_PEfinder_new.discordant_distance",
          "source": [
            "#discordant_distance"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_PEfinder_new.distant_pairs"
        }
      ],
      "sbg:x": 1791.294433441962,
      "sbg:y": 358.01567283925107
    },
    {
      "id": "#KNIFE_filterFDR",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "mkdir output && python filterFDR.py -p ./ -o output  -s sample_name_1 -q appended   -gens1 /path/to/genome_sam-1.ext -gens2 /path/to/genome_sam-2.ext   -gent1 /path/to/genome_txt-1.ext -gent2 /path/to/genome_txt-2.ext   -ribs1 /path/to/ribosomal_sam-1.ext -ribs2 /path/to/ribosomal_sam-2.ext   -ribt1 /path/to/ribosomal_txt-1.ext -ribt2 /path/to/ribosomal_txt-2.ext   -regs1 /path/to/regular_sam-1.ext -regs2 /path/to/regular_sam-2.ext   -regt1 /path/to/regular_txt-1.ext -regt2 /path/to/regular_txt-2.ext   -scrs1 /path/to/scrambled_sam-1.ext -scrs2 /path/to/scrambled_sam-2.ext   -scrt1 /path/to/scrambled_txt-1.ext -scrt2 /path/to/scrambled_txt-2.ext",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/filterfdr/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id + \"_1\"\n          break\n    }\n\treturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 1026,
        "sbg:categories": [
          "RNA-seq"
        ],
        "id": "milos_jordanski/spachete-salzman-collaboration/filterfdr/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1527007840,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "utils_os.py",
                "fileContent": "import os\nimport errno\nimport re\n\n# create directory if it does not exist\ndef createDirectory(dirPath):\n    try:\n        if not os.path.isdir(dirPath):\n            os.makedirs(dirPath)\n    except OSError, e:\n        if e.errno != errno.EEXIST:\n            raise\n        \n# parse a string of interest out of a filename\ndef getFileId(patt, grp, filename):\n    match = patt.search(filename)\n    if match:\n        return match.group(grp)\n    else:\n        print \"filename not structured correctly: \" + str(filename)\n\n# good way to grep, particularly for large files\ndef grep(pattern, file_obj, include_line_nums=False):\n    grepper = re.compile(pattern)\n    for line_num, line in enumerate(file_obj):\n        if grepper.search(line):\n            if include_line_nums:\n                yield (line_num, line)\n            else:\n                yield line"
              },
              {
                "filename": "utils_juncReads_minimal.py",
                "fileContent": "# main data structures for tracking junctions and aligned reads and their associated properties\n\nimport re\nfrom collections import namedtuple\nfrom collections import deque\nfrom numpy import mean\n\nPOS_MATCH_FLAG = 0  # value used in sam file to indicate alignment to forward strand\nREV_MATCH_FLAG = 16  # value used in sam file to indicate alignment to reverse strand\n## locations of information in the junction id when it is split using id_patt regex\nG_CHR = 1\nG_GENE1 = 2\nG_POS1 = 3\nG_GENE2 = 4\nG_POS2 = 5\nG_JUNC_TYPE = 6\nG_JUNC_STRAND = 7\nBUFFER = 15  # allow wiggle room to minimize anomalies / decoys due to sequencing errors or adaptor sequence alignment\nUNALIGNED_BUFFER = 50  # allow extra wiggle room for unaligned because the headers contain bins, not exact alignment positions\nJUNC_MIDPOINT = 150  # we take 150bp from each exon to create a junction sequence\nMIN_MAPQUAL = 0 # minimum mapping quality to consider a read as providing any info  \n\n# junction ids look like chr10|TTC40:134751179|MYC1:134722640|reg|-\n# where we are interested in chr10, TTC40, 134751179, MYC1, 134722640, reg, and -\nid_patt = re.compile(\"(.+?)\\|(.+?):(.+?)\\|(.+?):(.+?)\\|(.+?)\\|(\\-|\\+)\")\n\n# MD strings look like 0N0N0N0N0N0N35T0A0G0G0G1T1C29 or 35T0A0G0G0G1T1C29N0N0 with any number of 0N or N0 repeats\n# where we are interested in the repeats 0N0N0N0N0N0N and N0N0\nmd_patt = re.compile(\"^((?:0N)*).+?((?:N0)*)$\")\n\n# Contains read and its mates that mapped to the genome or junction database.\n# Can have mate mapping to both since the alignment of all mates is done to both\n# indexes. Also knows whether it looks like a circle or a decoy.\nclass juncReadObj:\n    \n    def __init__(self, read):\n        self.juncRead = read  # read object that aligned to junction\n        self.mateGenomic = None # read object for mate that aligned to the genome\n        self.mateJunction = None # read object for mate that aligned to the junction index\n        self.mateRegJunction = None # read object for mate that aligned to the regular-only junction index\n        self.mateDenovoJunction = None # read object for mate that aligned to the denovo junction index\n        self.readType = None # will be updated to \"c\", \"d\",\"u\", \"l\", a\", or \"i\" for circular, decoy, mate-unmapped, linear, anomaly or ignore\n        self.useMate = None # will be updated to self.mateGenomic, self.mateJunction, or self.mateRegJunction after we have all options\n        self.readStat = None # will be updated to include statistic I want to use for evaluating this read (for example avg)\n    \n    def __str__(self):\n        msg = \"juncRead: \" + str(self.juncRead)\n        msg += \"\\nmateGenomic: \" + str(self.mateGenomic)\n        msg += \"\\nmateJunction: \" + str(self.mateJunction)\n        msg += \"\\nmateRegJunction: \" + str(self.mateRegJunction)\n        msg += \"\\nmateDenovoJunction: \" + str(self.mateDenovoJunction)\n        msg += \"\\nreadType: \" + str(self.readType)\n        msg += \"\\nuseMate: \" + str(self.useMate)\n        msg += \"\\nreadStat: \" + str(self.readStat)\n        return msg        \n    \n    # param junc: juncObj\n    # param isSingleEnd: T/F since we need to know if the mate isn't there because it never existed or because it didn't align or pass quality filters\n    # param isUnalignedMode: T/F since the header info is slightly different for the index built for the denovo run (only applicable to scrambled junctions for now)\n    def updateInfo(self, junc, isSingleEnd, isUnalignedMode):\n        # if the junction-spanning read had poor mapping quality,\n        # it will end up being placed in the multi-mapped bucket\n        # so no need to take a look at mates and read types\n        # otherwise, pick a mate and calculate values based on mate selected\n        if int(self.juncRead.mapQual) >= MIN_MAPQUAL:\n            if not isSingleEnd:\n                self.useMate = self.selectMate()\n            self.readType = self.selectReadType(junc, isSingleEnd, isUnalignedMode)\n            self.readStat = self.calcReadStat()    \n    \n    # set useMate\n    # select the highest scoring alignment for Rd2. If multiple alignments have the same\n    # score, default to genome, then regular junction, then scrambled.\n    # only consider mates with good mapping quality, since poor quality reads most likely came from another location\n    def selectMate(self):\n        possibleMates = []\n        \n        \n        if self.mateGenomic and int(self.mateGenomic.mapQual) >= MIN_MAPQUAL:\n            possibleMates.append(self.mateGenomic)\n        \n        if self.mateRegJunction and int(self.mateRegJunction.mapQual) >= MIN_MAPQUAL:\n            possibleMates.append(self.mateRegJunction)\n        \n        if self.mateJunction and int(self.mateJunction.mapQual) >= MIN_MAPQUAL:\n            possibleMates.append(self.mateJunction)\n        \n        if self.mateDenovoJunction and int(self.mateDenovoJunction.mapQual) >= MIN_MAPQUAL:\n            possibleMates.append(self.mateDenovoJunction)\n        \n        # mate did not align anywhere with a good mapping quality\n        if len(possibleMates) == 0:\n            return None\n        \n        # only consider those mates with the maximum alignment score\n        maxAS = max(int(x.aScore) for x in possibleMates)\n        possibleMates = [x for x in possibleMates if int(x.aScore) == maxAS]\n        \n        # if we only have one left with the max alignment score, that's the one we want\n        if len(possibleMates) == 1:\n            return possibleMates[0]\n\n        # otherwise go through the priority ranking\n        if self.mateGenomic in possibleMates:\n            return self.mateGenomic\n        \n        if self.mateRegJunction in possibleMates:\n            return self.mateRegJunction\n        \n        if self.mateJunction in possibleMates:\n            return self.mateJunction\n        \n        if self.mateDenovoJunction in possibleMates:\n            return self.mateDenovoJunction\n    \n    def calcReadStat(self):\n        if self.juncRead:\n            # if we have a mate we are using, take the avg of the 2 reads\n            if self.useMate:\n                return mean([int(self.juncRead.aScore), int(self.useMate.aScore)])\n            # otherwise just use my score\n            else:\n                return float(self.juncRead.aScore)\n        else:\n            return None\n        \n    # have to handle reg junctions separately since they could have a rev mate\n    # that makes them circular evidence, or they need to be assigned to linear or anomaly buckets\n    # param junc: juncObj\n    def selectReadType(self, junc, isSingleEnd, isUnalignedMode):\n        \n        # if mate mapped to neither junctions nor genome, it is unmapped\n        if not isSingleEnd and not self.useMate:\n            return None\n        \n        # for single end, we can only determine read type based on alignment to reg or scrambled junction\n        if isSingleEnd:\n            if junc.juncType == \"reg\":\n                useType = \"l\"\n            else:\n                useType = \"c\"\n        else:        \n            if junc.juncType == \"reg\":\n                useType = self.selectRegReadType(junc)\n            else:\n                useType = self.selectScrambledReadType(junc, isUnalignedMode)\n        \n        return useType        \n        \n    # this junction Rd1 is either dup or rev        \n    def selectScrambledReadType(self, junc, isUnalignedMode):\n        \n        myCoord = int(junc.minPos) - JUNC_MIDPOINT + int(self.juncRead.offset)\n        myEnd = myCoord + int(self.juncRead.readLen)\n\n        # get info for mate \n        isGenomicMate = self.useMate == self.mateGenomic\n        \n        if isGenomicMate:\n            mateChr = self.useMate.refName\n            mateCoord = int(self.useMate.offset)\n        else:\n            match2 = id_patt.search(self.useMate.refName)  # rd2 junction id\n            mateChr = match2.group(G_CHR)\n            minMateJunctionPos = min(int(match2.group(G_POS1)), int(match2.group(G_POS2)))\n            maxMateJunctionPos = max(int(match2.group(G_POS1)), int(match2.group(G_POS2)))\n            mateCoord = minMateJunctionPos - JUNC_MIDPOINT + int(self.useMate.offset)\n        \n        mateEnd = mateCoord + int(self.useMate.readLen)\n        \n        if isUnalignedMode:\n            USE_BUFFER = UNALIGNED_BUFFER\n        else:\n            USE_BUFFER = BUFFER\n            \n        # all info gathered, now see if it is consistent with circle or not\n        # reads need to map in opposite orientation (have opposite flags) \n        if junc.chromosome == mateChr and int(self.juncRead.flag) != int(self.useMate.flag):\n            # read2 mapping to same scrambled junction as read1 is always evidence of circle\n            if self.useMate.refName == self.juncRead.refName: \n                return \"c\"\n            # read2 mapping between read1 scrambled junction supports circle\n            elif (mateCoord >= (int(junc.minPos) - USE_BUFFER) and mateCoord <= (int(junc.maxPos) + USE_BUFFER)\n                  and mateEnd >= (int(junc.minPos) - USE_BUFFER) and mateEnd <= (int(junc.maxPos) + USE_BUFFER)):\n                    return \"c\"\n            # or Rd1 could map between bounds of a circle defined by scrambled junction-aligned Rd2\n            # but we want to ignore these for now because they will be identified in a swapped run  \n            elif (not isGenomicMate and match2.group(G_JUNC_TYPE) != \"reg\"\n                  and myCoord >= (minMateJunctionPos - USE_BUFFER) and myCoord <= (maxMateJunctionPos + USE_BUFFER)\n                  and myEnd >= (minMateJunctionPos - USE_BUFFER) and myEnd <= (maxMateJunctionPos + USE_BUFFER)):\n                return \"i\"\n            else:\n                # out of bounds \n                return \"d\"\n                    \n        else:\n            # the mate was on a different chromosome or alignment flags didn't agree with PE read\n            return \"d\"\n    \n    # this is a reg junction. If mate maps to scrambled junction we ignore it for now,\n    # since it will be picked up and considered in a swapped run (where we treat read 2 as read 1).\n    def selectRegReadType(self, junc):\n        \n        match1 = id_patt.search(self.juncRead.refName)  # reg junction rd1 id\n        myCoord = int(junc.minPos) - JUNC_MIDPOINT + int(self.juncRead.offset)\n        myEnd = myCoord + int(self.juncRead.readLen)\n            \n        # get info for mate \n        isGenomicMate = self.useMate == self.mateGenomic\n        \n        if isGenomicMate:\n            mateChr = self.useMate.refName\n            mateCoord = int(self.useMate.offset)\n        else:\n            match2 = id_patt.search(self.useMate.refName)  # rd2 junction id\n            mateChr = match2.group(G_CHR)\n            minMateJunctionPos = min(int(match2.group(G_POS1)), int(match2.group(G_POS2)))\n            maxMateJunctionPos = max(int(match2.group(G_POS1)), int(match2.group(G_POS2)))\n            mateCoord = minMateJunctionPos - JUNC_MIDPOINT + int(self.useMate.offset)\n                \n        mateEnd = mateCoord + int(self.useMate.readLen)\n        \n        ###### all info gathered, now see if it is consistent with circle or not\n        \n        # has to be on same chromosome and mates must be aligned in opposite orientation \n        if junc.chromosome == mateChr and int(self.juncRead.flag) != int(self.useMate.flag):\n            # check for evidence of linear \n            if isGenomicMate or match2.group(G_JUNC_TYPE) == \"reg\":\n                # figure out genomic coordinate for plus and minus read\n                if int(self.juncRead.flag) == POS_MATCH_FLAG:\n                    plusMateCoord = myCoord \n                    minusMateCoord = mateCoord\n                else:\n                    plusMateCoord = mateCoord\n                    minusMateCoord = myCoord\n                    \n                # rev read needs to map downstream, or only slightly upstream to account for errors\n                if minusMateCoord >= plusMateCoord - BUFFER:\n                    return \"l\"\n                else:\n                    return \"a\"\n            else:\n                # read 2 was to a scrambled junction, need to ignore for now\n                return \"i\"\n        else:\n            # the mate was on a different chromosome or alignment directions do not support PE read\n            return \"a\"\n\nclass juncObj:\n    \n    def __init__(self, id):\n        self.id = id # junction id\n        self.chromosome, self.direction, self.juncType, self.numGenes, self.minPos, self.maxPos = self.setInfo()\n        self.circularReads = deque([]) # will hold list of all reads spanning this junction that support circle\n        self.decoyReads = deque([]) # will hold list of all reads spanning this junction that do not support circle\n        self.unmappedReads = deque([]) # will hold list of all reads spanning this junction where mate is not mapped\n        self.multimappedReads = deque([]) # will hold list of all reads spanning this junction where mate has poor mapping quality\n        self.linearReads = deque([]) # all that look like true linear reads\n        self.anomalyReads = deque([]) # all that don't look like circular or linear\n        self.unknownReads = deque([]) # will hold list of all reads initially\n        self.fdr=None # will hold FDR or p-value printed in the per-junction report file  \n        \n    def __str__(self):\n        msg = \"\\nid: \" + str(self.id)\n        msg += \"\\nchromosome: \" + str(self.chromosome)\n        msg += \" direction: \" + str(self.direction)\n        msg += \" juncType: \" + str(self.juncType)\n        msg += \" minPos: \" + str(self.minPos)\n        msg += \" maxPos: \" + str(self.maxPos)\n        msg += \"\\ncircularReads: \" + str(len(self.circularReads))\n        msg += \" decoyReads: \" + str(len(self.decoyReads))\n        msg += \" unmappedReads: \" + str(len(self.unmappedReads))\n        msg += \" multimappedReads: \" + str(len(self.multimappedReads))\n        msg += \" linearReads: \" + str(len(self.linearReads))\n        msg += \" anolmalyReads: \" + str(len(self.anomalyReads))\n        msg += \" unknownReads: \" + str(len(self.unknownReads))\n        msg += \" fdr: \" + str(self.fdr)\n        \n        return msg\n    \n    def setInfo(self):\n        match = id_patt.search(self.id)\n        if match:\n            # if the 2 genes are the same, the junction involves only 1 gene\n            if match.group(G_GENE1) == match.group(G_GENE2):\n                numGenes = 1\n            else:\n                numGenes = 2\n            \n            # chr, direction, junctionType, numGenes, minPos, maxPos\n            return match.group(G_CHR), match.group(G_JUNC_STRAND), match.group(G_JUNC_TYPE), numGenes, min(int(match.group(G_POS1)), int(match.group(G_POS2))), max(int(match.group(G_POS1)), int(match.group(G_POS2))) \n        else:\n            return None,None,None,None,0,0\n            \n\n\n\nreadObj = namedtuple('readObj', ['name', 'flag', 'refName', 'offset', 'aScore', 'nextBest', 'mapQual', 'baseName', 'readLen', 'numN'])\n\n# param vals: result of calling line.strip().split() on a non-header line from sam file.\n# param readIdStyle: for now, options are just \"appended\" or \"complete\".\n#                    \"appended\" means /1 or /2 added to read 1 or read 2 respectively\n#                    \"complete\" means same id used in read1 and read2 files \n# Need to store read length because trimming could result in different lengths of reads within a single dataset\ndef newReadObj(vals, readIdStyle):\n    numN = 0\n    mmStr = \"\"\n    myScore = None\n    myNextBest = None\n    optFields = vals[11:]  \n    \n    for x in optFields:\n        curOpt = x.split(\":\")\n        if curOpt[0] == \"AS\":\n            myScore = curOpt[2]\n        elif curOpt[0] == \"XS\":  # next best score\n            myNextBest = curOpt[2]\n        elif curOpt[0] == \"XN\":  # num N in reference\n            numN = int(curOpt[2]) \n        elif curOpt[0] == \"MD\":  # string representing mismatch locations\n            mmStr = curOpt[2]\n            \n    # correct for N-penalty in junction alignments and update alignment score as needed\n    if numN > 0:\n        match = id_patt.search(vals[2])  # if this is a junction alignment, refName will fit this pattern\n        if match:  # only want to adjust junction alignments \n            # get MD string, string representation of where the mismatches or Ns occurred\n            # if Ns are on left the pattern is 0N, if on right of match the pattern is N0\n            match_md = md_patt.search(mmStr)\n            numOinStr = match_md.group(1).count(\"0N\")\n            numNinStr = match_md.group(2).count(\"N0\")\n            # confirm agreement between XN and MD string\n            if numNinStr == numN or numOinStr == numN or numNinStr + numOinStr == numN: \n                myOrigScore = myScore\n                myScore = str(int(myScore) + numN) # 1 was deducted from score for each N matched in reference so add back, keep as string for consistency\n            #else:\n                #print \"could not update AS for\", vals[0], \"MD and XN do not agree\", mmStr, str(numN) \n                    \n    if readIdStyle == \"appended\":        \n        myBaseName = vals[0][:-1]  # name without trailing 1 or 2 so we can quickly match up paired reads\n    else:\n        myBaseName = vals[0]  # or sometimes the read ids are already the same in the 2 separate files  \n        \n    return readObj(name=vals[0], flag=int(vals[1]), refName=vals[2], offset=vals[3], aScore=myScore, nextBest=myNextBest, mapQual=vals[4], baseName=myBaseName, readLen=len(vals[9]), numN=numN)"
              },
              {
                "filename": "filterFDR.py",
                "fileContent": "# Assumes preprocessAlignedReads.sh has been called and files with read ids for genome,\n# junction, reg, ribo, and transcriptome alignments have been output.\n\n# Loops through all id files to find those Rd1 ids that are aligned to a junction and not to the ribosome\n# or genome. Then goes back to original sam files to get data for reads that aligned to each of these junctions\n# in order to create JuncObjs with all data for the reads that aligned to a junction.\n\n# Then assigns each read to a bucket based on where Rd1 and Rd2 aligned. Outputs reports based on analysis using the\n# Naive method described in the paper into the reports directory. A very early method using a hard cutoff on alignment\n# scores is still implemented here (passing alignment score thresholds for read1 as -a1 and read2 as -a2),\n# but should not be used as the naive method performs better.\n\nimport argparse\nimport os\nimport utils_os\nfrom utils_juncReads_minimal import *\nfrom scipy.stats import scoreatpercentile\nfrom scipy.stats import poisson\nfrom math import ceil\nimport sys\n\n\nlogfile = open(\"logfile_no_sym.txt\", \"w\")\n\n# look in the ribo id file for this sample, and in the associated genome id file for this\n# sample to find the read ids that aligned to the genome or the ribosome.\n# Then look in the associated regular junction overlapped read id file and select\n# only those ids that are junction overlapped and did not align to ribosome or genome.\n# Populate the global regIds with these ids. Then look in the associated all-junction\n# overlapped id file and populate the global nonRegIds variable with these read ids\n# that did not align to the ribosome, genome, or regular junctions\ndef selectCandidateIds():\n    # add the suffix if we used an alternate overlap specification and output the overlapped ids to an alternate location\n    #regIdDir = \"reg\" + args.junctionIdDirSuffix\n    #juncIdDir = useJuncStr + args.junctionIdDirSuffix\n\n    #idDir = \"/\".join([args.parentDir, \"orig\", \"ids\"])\n\n    # only need to look for ids to exclude if we are not looking at previously unaligned reads\n    if not args.unalignedMode:\n        # get ribo ids\n        try:\n            #handle = open(\"\".join([\"/\".join([idDir, \"ribo\", args.sampleId]), \"_ribo_output.txt\"]), \"rU\")\n            handle = open(args.ribosomalTXT1, \"rU\")\n            if args.fastqIdStyle == \"appended\":\n                for line in handle:\n                    ignoreIds[line.strip().split()[0][:-1]] = None\n            else:\n                for line in handle:\n                    ignoreIds[line.strip().split()[0]] = None\n            handle.close()\n        except Exception as e:\n            print \"Exception\"\n            print e\n            print \"parsing ribo ids for\", line\n\n        # load genome aligned id file for the same sample and add to ignoreIds\n\n        #handle = open(\"\".join([\"/\".join([idDir, \"genome\", args.sampleId]), \"_genome_output.txt\"]), \"rU\")\n        handle = open(args.genomeTXT1, \"rU\")\n        if args.fastqIdStyle == \"appended\":\n            for line in handle:\n                try:\n                    ignoreIds[line.strip().split()[0][:-1]] = None\n                except TypeError as e:\n                    print \"error parsing genome ids for\", line\n                    print \"Type error({0}): {1}\".format(e.errno, e.strerror)\n                    print \"error:\", sys.exc_info()[0]\n                except:\n                    print \"error parsing genome ids for\", line\n                    print \"error:\", sys.exc_info()[0]\n        else:\n            for line in handle:\n                ignoreIds[line.strip().split()[0]] = None\n        handle.close()\n\n        # load reg-junction aligned id file for same sample and load ids not in ignoreIds\n        try:\n            #handle = open(\"\".join([\"/\".join([idDir, regIdDir, args.sampleId]), \"_reg_output.txt\"]), \"rU\")\n            handle = open(args.regularTXT1, \"rU\")\n            for line in handle:\n                if args.fastqIdStyle == \"appended\":\n                    testId = line.strip().split()[0][:-1]\n                else:\n                    testId = line.strip().split()[0]\n\n                if testId not in ignoreIds:\n                    regIds[testId] = None\n            handle.close()\n        except Exception as e:\n            print \"Exception\"\n            print e\n            print \"parsing reg ids for\", line\n\n    # load junction aligned id file (or de novo aligned id file) for same sample and load ids not in ignoreIds or regJuncIds\n    try:\n        #handle = open(\"_\".join([\"/\".join([idDir, juncIdDir, args.sampleId]), useJuncStr, \"output.txt\"]), \"rU\")\n        handle = open(args.scrambledTXT1, \"rU\")\n        for line in handle:\n            if args.fastqIdStyle == \"appended\":\n                testId = line.strip().split()[0][:-1]\n            else:\n                testId = line.strip().split()[0]\n\n            if testId not in ignoreIds and testId not in regIds:\n                nonRegIds[testId] = None\n        handle.close()\n    except Exception as e:\n        print \"Exception\"\n        print e\n        print \"error parsing junction ids for\", line\n\n        # print out these ids for later debugging use\n    # try:\n    #     if args.unalignedMode:\n    #         out_handle = open(\"\".join([\"/\".join([idDir, \"denovoNonGR\", args.sampleId]), \"_output.txt\"]), \"wb\")\n    #     else:\n    #         out_handle = open(\"\".join([\"/\".join([idDir, \"juncNonGR\", args.sampleId]), \"_output.txt\"]), \"wb\")\n    #\n    #     if args.verbose:\n    #         print \"ready to write ids to\", \"\".join(\n    #             [\"/\".join([idDir, \"denovoNonGR\", args.sampleId]), \"_output.txt\"]), \"or\", \"\".join(\n    #             [\"/\".join([idDir, \"juncNonGR\", args.sampleId]), \"_output.txt\"])\n    #         print \"num nonRegIds:\", str(len(nonRegIds))\n    #         print \"num regIds:\", str(len(regIds))\n    #\n    #     for i in nonRegIds:\n    #         out_handle.write(i)\n    #         out_handle.write(\"\\n\")\n    #     for i in regIds:\n    #         out_handle.write(i)\n    #         out_handle.write(\"\\n\")\n    #     out_handle.close()\n    # except Exception as e:\n    #     print \"Exception\"\n    #     print e\n    #     print \"writing ids for\", i\n\n\n# Get mismatch rate for the decoys in this dataset. This is total_mismatches / total_bases\ndef getDecoyMismatchRate():\n    aScore = 0  # sum of all alignment scores\n    numBases = 0\n\n    for j in junctions:\n        for r in junctions[j].decoyReads:\n            aScore += r.readStat\n            numBases += r.juncRead.readLen\n            # this is average aScore, so it is aScore for read 1 or avg for read1 and read2 if mate is not None\n            if r.useMate != None:\n                aScore += r.readStat  # need to double the contribution of aScore since that was the avg of the 2 mates\n                numBases += r.useMate.readLen  # and need to add the length of the mate\n\n    if numBases == 0:\n        return None\n    else:\n        return (aScore / -6.0) / numBases  # this is the mismatch rate per base observed in the decoys\n\n\n# param alignedReads: array of juncReadObj that aligned to the junction\ndef getPval(alignedReads):\n    if len(alignedReads) > 0:\n        useMMrate = globalDecoyMMrate\n\n        # total number of mismatches observed for all reads aligning to this junction, rounded to get integer which is required for poisson.cdf\n        num_mm = int(ceil(sum([x.readStat for x in alignedReads]) / -6.0))\n        num_bases = sum([x.juncRead.readLen for x in alignedReads]) + sum(\n            [x.useMate.readLen for x in alignedReads if x.useMate != None])\n\n        return 1 - poisson.cdf(num_mm, useMMrate * num_bases)\n    else:\n        return \"-\"\n\n\ndef getReadScores(alignedReads):\n    scores = []\n    if len(alignedReads) > 0:\n        a1Scores = [int(r.juncRead.aScore) for r in alignedReads]\n        if args.singleEnd:\n            scores = a1Scores\n        else:\n            a2Scores = [int(r.useMate.aScore) for r in alignedReads]\n            scores = zip(a1Scores, a2Scores)\n\n    return scores\n\n\n# per-junction p-value is calculated assuming number of mismatches is Poisson(0.01*avg_read_length)\n# .01 is the high end of the Illumina sequencing error rate\n# prints all junctions, even those that have no circular reads\ndef reportCircularReads(cutoff):\n    if args.unalignedMode:\n        report_handle = open(\"_\".join([\"/\".join([args.parentDir, args.outDirName, \"reports\", args.sampleId]), \"denovo_report.txt\"]), \"wb\")\n    else:\n        report_handle = open(\"_\".join([\"/\".join([args.parentDir, args.outDirName, \"reports\", args.sampleId]), \"report.txt\"]), \"wb\")\n\n    if cutoff:\n        report_handle.write(\"\".join([\"@Global alignment score cutoff: \", str(cutoff), \"\\n\"]))\n    else:\n        report_handle.write(\"\".join([\"@GUsing Poisson distribution with p=: \", str(globalDecoyMMrate), \"\\n\"]))\n    report_handle.write(\"@junction\\tlinear\\tanomaly\\tunmapped\\tmultimapped\\tcirc\\tdecoy\\t\")\n\n    # if we specified a read cutoff, the value returned is an FDR, otherwise it is a p-value using naive model\n    if cutoff:\n        report_handle.write(\"FDR\")\n    else:\n        report_handle.write(\"pvalue\")\n\n    report_handle.write(\"\\tscores\\n\")\n\n    for j in junctions:\n        # print out the junction and read id for all good reads\n        # either both mates need to pass threshold, or single-end read needs to pass Rd1 threshold\n        if cutoff:\n            numGood = 0  # track any linear or circular that passed the score threshold\n            for elem in junctions[j].circularReads:\n                if int(elem.juncRead.aScore) >= int(cutoff[0]) and (\n                    args.singleEnd or int(elem.useMate.aScore) >= int(cutoff[1])):\n                    numGood += 1\n\n            for elem in junctions[j].linearReads:\n                if int(elem.juncRead.aScore) >= int(cutoff[0]) and (\n                    args.singleEnd or int(elem.useMate.aScore) >= int(cutoff[1])):\n                    numGood += 1\n\n                    # print out global junction reads stats\n            numCandidates = len(junctions[j].circularReads) + len(junctions[j].linearReads)\n            numBad = numCandidates - numGood\n            if numCandidates > 0:\n                sig_stat = float(numBad) / numCandidates\n            else:\n                sig_stat = \"-\"\n        elif \"|reg|\" not in junctions[j].id:  # if it's a circular junction\n            sig_stat = getPval(junctions[j].circularReads)  # p-value\n        elif \"|reg|\" in junctions[j].id:  # or it is a linear junction\n            sig_stat = getPval(junctions[j].linearReads)  # p-value\n        else:\n            print \"cound not get sig stat for\", junctions[j].id\n            sig_stat = \"NA\"\n\n        report_handle.write(str(j) + \"\\t\")\n        report_handle.write(str(len(junctions[j].linearReads)) + \"\\t\")\n        report_handle.write(str(len(junctions[j].anomalyReads)) + \"\\t\")\n        report_handle.write(str(len(junctions[j].unmappedReads)) + \"\\t\")\n        report_handle.write(str(len(junctions[j].multimappedReads)) + \"\\t\")\n        report_handle.write(str(len(junctions[j].circularReads)) + \"\\t\")\n        report_handle.write(str(len(junctions[j].decoyReads)) + \"\\t\")\n        report_handle.write(str(sig_stat) + \"\\t\")\n\n        if \"|reg|\" not in junctions[j].id:  # if it's a circular junction\n            scores = getReadScores(junctions[j].circularReads)\n        elif \"|reg|\" in junctions[j].id:  # or it is a linear junction\n            scores = getReadScores(junctions[j].linearReads)  # scores to print in report\n        else:\n            scores = []\n\n        if len(scores) > 10:\n            # if we have lots of scores for this junction, just write out the quantiles\n            for i in xrange(0, 101, 10):\n                if args.singleEnd:\n                    report_handle.write(str(scoreatpercentile(scores, i, interpolation_method='lower')) + \",\")\n                else:\n                    report_handle.write(\n                        str(scoreatpercentile([x[0] for x in scores], i, interpolation_method='lower')) + \":\" +\n                        str(scoreatpercentile([x[1] for x in scores], i, interpolation_method='lower')) + \",\")\n        else:\n            # otherwise we have just a few so let's just print them all out\n            for s in scores:\n                report_handle.write(str(s) + \",\")\n\n        report_handle.write(\"\\n\")\n\n        # store FDR for this junction so we can decide if we think it is an artifact or not\n        if sig_stat != \"-\" and sig_stat != \"NA\":\n            junctions[\n                j].fdr = sig_stat  # will need to update this variable name in juncObj if we are using p-values in the future instead of FDRs\n\n    report_handle.close()\n\n\ndef reportAllReadIds2(cutoff):\n    if args.unalignedMode:\n        id_handle = open(\n            \"_\".join([\"/\".join([args.parentDir, args.outDirName, \"ids\", args.sampleId]), \"denovo__output.txt\"]), \"wb\")\n    else:\n        id_handle = open(\"_\".join([\"/\".join([args.parentDir, args.outDirName, \"ids\", args.sampleId]), \"_output.txt\"]),\n                         \"wb\")\n\n    # use the column names used in R\n    id_handle.write(\"\\t\".join([\"id\", \"class\", \"pos\", \"qual\", \"aScore\", \"numN\", \"readLen\", \"junction\", \"strand\",\n                               \"posR2\", \"qualR2\", \"aScoreR2\", \"numNR2\", \"readLenR2\", \"junctionR2\", \"strandR2\"]) + \"\\n\")\n\n    for j in junctions:\n        # print circular read ids\n        for elem in junctions[j].circularReads:\n            # if we pass a cutoff for read1 and read2 scores, then we are calculating an FDR which we want to keep low\n            # otherwise we are calculating a probability of observing these reads under the null that this really is a circle and then we want to get rid of those with low p-values\n            if junctions[j].fdr and ((cutoff and float(junctions[j].fdr) > args.reportFDR)\n                                     or (not cutoff and float(junctions[j].fdr) < args.reportFDR)):\n                readClass = \"circArtifact\"\n            elif cutoff:\n                if int(elem.juncRead.aScore) >= int(cutoff[0]) and (\n                    args.singleEnd or int(elem.useMate.aScore) >= int(cutoff[1])):\n                    readClass = \"circStrong\"\n                else:\n                    readClass = \"circFailed\"\n            else:\n                readClass = \"circStrong\"\n\n            myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j), str(elem.juncRead.flag)])\n            if args.singleEnd:\n                pairInfo = \"\\t\".join([\"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\"])\n            else:\n                pairInfo = \"\\t\".join([str(elem.useMate.offset),\n                                      str(elem.useMate.mapQual), str(elem.useMate.aScore), str(elem.useMate.numN),\n                                      str(elem.useMate.readLen),\n                                      str(elem.useMate.refName), str(elem.useMate.flag)])\n\n            id_handle.write(\"\\t\".join([str(elem.juncRead.name), readClass, myInfo, pairInfo]) + \"\\n\")\n\n        # print linear read ids\n        for elem in junctions[j].linearReads:\n            if junctions[j].fdr and ((cutoff and float(junctions[j].fdr) > args.reportFDR)\n                                     or (not cutoff and float(junctions[j].fdr) < args.reportFDR)):\n                readClass = \"linearArtifact\"\n            elif cutoff:\n                if int(elem.juncRead.aScore) >= int(globalCutOff[0]) and (\n                    args.singleEnd or int(elem.useMate.aScore) >= int(globalCutOff[1])):\n                    readClass = \"linearStrong\"\n                else:\n                    readClass = \"linearFailed\"\n            else:\n                readClass = \"linearStrong\"\n\n            myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j), str(elem.juncRead.flag)])\n            if args.singleEnd:\n                pairInfo = \"\\t\".join([\"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\"])\n            else:\n                pairInfo = \"\\t\".join([str(elem.useMate.offset),\n                                      str(elem.useMate.mapQual), str(elem.useMate.aScore), str(elem.useMate.numN),\n                                      str(elem.useMate.readLen),\n                                      str(elem.useMate.refName), str(elem.useMate.flag)])\n\n            id_handle.write(\"\\t\".join([str(elem.juncRead.name), readClass, myInfo, pairInfo]) + \"\\n\")\n\n        # print multimapped read ids\n        for elem in junctions[j].multimappedReads:\n            myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j), str(elem.juncRead.flag)])\n            if args.singleEnd or not elem.useMate:\n                pairInfo = \"\\t\".join([\"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\"])\n            else:\n                pairInfo = \"\\t\".join([str(elem.useMate.offset),\n                                      str(elem.useMate.mapQual), str(elem.useMate.aScore), str(elem.useMate.numN),\n                                      str(elem.useMate.readLen),\n                                      str(elem.useMate.refName), str(elem.useMate.flag)])\n\n            id_handle.write(\"\\t\".join([str(elem.juncRead.name), \"multimapped\", myInfo, pairInfo]) + \"\\n\")\n\n        # print decoy read ids\n        if not args.singleEnd:\n            for elem in junctions[j].decoyReads:\n                myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                    str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j),\n                                    str(elem.juncRead.flag)])\n\n                pairInfo = \"\\t\".join([str(elem.useMate.offset),\n                                      str(elem.useMate.mapQual), str(elem.useMate.aScore), str(elem.useMate.numN),\n                                      str(elem.useMate.readLen),\n                                      str(elem.useMate.refName), str(elem.useMate.flag)])\n\n                id_handle.write(\"\\t\".join([str(elem.juncRead.name), \"decoy\", myInfo, pairInfo]) + \"\\n\")\n\n            # print anomaly read ids\n            for elem in junctions[j].anomalyReads:\n                myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                    str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j),\n                                    str(elem.juncRead.flag)])\n\n                pairInfo = \"\\t\".join([str(elem.useMate.offset),\n                                      str(elem.useMate.mapQual), str(elem.useMate.aScore), str(elem.useMate.numN),\n                                      str(elem.useMate.readLen),\n                                      str(elem.useMate.refName), str(elem.useMate.flag)])\n\n                id_handle.write(\"\\t\".join([str(elem.juncRead.name), \"anomaly\", myInfo, pairInfo]) + \"\\n\")\n\n            # print unmapped read ids\n            for elem in junctions[j].unmappedReads:\n                myInfo = \"\\t\".join([str(elem.juncRead.offset), str(elem.juncRead.mapQual), str(elem.juncRead.aScore),\n                                    str(elem.juncRead.numN), str(elem.juncRead.readLen), str(j),\n                                    str(elem.juncRead.flag)])\n                pairInfo = \"\\t\".join([\"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\", \"NA\"])\n                id_handle.write(\"\\t\".join([str(elem.juncRead.name), \"unmapped\", myInfo, pairInfo]) + \"\\n\")\n\n    id_handle.close()\n\n\n# loop through sam file, either creating a juncReadObj & juncObj (if this is read1s)\n# or updating mateGenome, mateJunction, or mateRegJunction if this is an alignment file from read2\n# to genome, all junctions, or regular junctions respectively.\n# The sam file may contain both aligned and unaligned reads. Only aligned reads will actually be stored.\n# param readType: \"r1rj\" is Rd1 to regular junction index, \"r1j\" is Rd1 to all junction,\n#                 \"gMate\" is Rd2 to genome, \"jMate\" is Rd2 to all junction, \"rjMate\" is Rd2 to regular junction\ndef parseSam(samFile, readType):\n    if args.verbose:\n        logfile.write(\"samFile: \" + samFile)\n        logfile.write(\"readType: \" + readType)\n\n    handle = open(samFile, \"rU\")\n\n    for line in handle:\n        if not line.startswith(\"@\"):  # ignore header lines\n            try:\n                read = newReadObj(line.strip().split(), args.fastqIdStyle)\n                # only need to store info if the read actually aligned\n                if read.aScore:\n                    readBase = read.baseName  # part of the read that is the same between Rd1 and Rd2\n                    # read1 that didn't map to genome, or ribo and then mapped to reg junctions or to all junctions and not to reg junction\n                    # since in unaligned mode we report all reads, we want to only count the first time in the file we see it (output order is highest alignment score first)\n                    if ((readType == \"r1j\" and readBase in nonRegIds and readBase not in juncReads) or\n                            (readType == \"r1rj\" and readBase in regIds and readBase not in juncReads)):\n                        curJuncReadObj = juncReadObj(\n                            read)  # create object for this read (mate info empty for now) to put in junction and juncReads dicts\n                        juncReads[readBase] = curJuncReadObj  # will look up this obj later to populate mates\n\n                        # this is first read aligning to this junction, need to create juncObj first\n                        if not read.refName in junctions:\n                            curJuncObj = juncObj(read.refName)\n                            junctions[read.refName] = curJuncObj\n                        # initially just append all reads to unknownReads, we will later remove some and move to circularReads, decoyReads, or unmappedReads\n                        junctions[read.refName].unknownReads.append(curJuncReadObj)\n                    elif readBase in juncReads:  # this is a mate so we only care about it if it's Rd1 was stored\n                        if readType == \"gMate\" and not juncReads[\n                            readBase].mateGenomic:  # only if we haven't already found the primary genomic alignment\n                            juncReads[readBase].mateGenomic = read\n                        else:\n                            # this is a junction mate, need to check offset\n                            if (int(read.offset) >= (JUNC_MIDPOINT - int(read.readLen) + args.overhang + 1) and\n                                        int(read.offset) <= (JUNC_MIDPOINT - args.overhang + 1)):\n                                # if it overlaps the junction, add it to the appropriate mate field\n                                if readType == \"jMate\" and not juncReads[\n                                    readBase].mateJunction:  # only if we haven't already found the primary junction alignment\n                                    juncReads[readBase].mateJunction = read\n                                elif readType == \"rjMate\" and not juncReads[\n                                    readBase].mateRegJunction:  # only if we haven't already found the primary reg junction alignment\n                                    juncReads[readBase].mateRegJunction = read\n                                elif readType == \"dMate\" and not juncReads[\n                                    readBase].mateDenovoJunction:  # only if we haven't already found the primary denovo junction alignment\n                                    juncReads[readBase].mateDenovoJunction = read\n            except Exception as e:\n                logfile.write(\"Exception\")\n                logfile.write(e)\n                logfile.write(\"parsing sam output for \" + line)\n\n    handle.close()\n\n\ndef updateReads():\n    # for each junction\n    for j in junctions:\n        # all reads were initially assigned to unknownReads, need to see which are circular,etc\n        while len(junctions[j].unknownReads) > 0:\n            r = junctions[j].unknownReads.pop()\n            r.updateInfo(junctions[j], args.singleEnd, args.unalignedMode)  # figure out which mate is best, whether this means it is decoy or not\n\n            # assign read to correct bucket\n            if r.readType == \"c\":\n                junctions[j].circularReads.append(r)\n            elif r.readType == \"d\":\n                junctions[j].decoyReads.append(r)\n            elif r.readType == \"l\":\n                junctions[j].linearReads.append(r)\n            elif r.readType == \"a\":\n                junctions[j].anomalyReads.append(r)\n            elif r.readType == \"i\":\n                # we are ignoring this read because Rd1 aligned to reg and Rd2 aligned to scrambled\n                pass\n            else:\n                if r.mateGenomic or r.mateJunction or r.mateRegJunction or r.mateDenovoJunction:\n                    # the mate did map, but had very poor mapping quality so we are discarding it\n                    junctions[j].multimappedReads.append(r)\n                else:\n                    # either mate was not in the file or did not align to either genome or junction index\n                    junctions[j].unmappedReads.append(r)\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-p', '--parentDir', help='path to alignment parent directory for this dataset', required=True)\n    parser.add_argument('-s', '--sampleId', help='string used to identify this sample', required=True)\n    parser.add_argument('-o', '--outDirName', help='name of directory to output files under parentDir, created if does not exist', required=True)\n    parser.add_argument('-q', '--fastqIdStyle', help='type of read ids used', required=True, choices=['appended', 'complete'])\n    parser.add_argument('-f', '--reportFDR', help='FDR to select circular artifacts in report', type=float, default=0.9)\n    parser.add_argument('-e', '--seqErrorRate', help='per base sequencing error rate', type=float, default=0.01)\n    parser.add_argument('-a1', '--aScore1', help='specify bowtie min AS for read1 instead of using global FDR cutoff',type=int)\n    parser.add_argument('-a2', '--aScore2', help='specify bowtie min AS for read1 instead of using global FDR cutoff', type=int)\n    parser.add_argument('-oh', '--overhang', help='how much you want the read to overlap a junction to be considered aligned to junction', type=int, required=True)\n    parser.add_argument('-j', '--junctionIdDirSuffix', help='suffix appended to junc and reg to find overlapped reads for this run', default='')\n    parser.add_argument('-se', '--singleEnd', help='is this single end read data', action='store_true')\n    parser.add_argument('-u', '--unalignedMode', help='is this an unaligned mode run', action='store_true')\n    parser.add_argument('-v', '--verbose', help='print extra debugging info', action='store_true')\n\n    parser.add_argument('-gens1', '--genomeSAM1', help='path to the alignment of read1 to genome', required=True)\n    parser.add_argument('-gens2', '--genomeSAM2', help='path to the alignment of read2 to genome', required=True)\n    parser.add_argument('-gent1', '--genomeTXT1', help='path to the alignment of read1 to genome (txt file)', required=True)\n    parser.add_argument('-gent2', '--genomeTXT2', help='path to the alignment of read2 to genome (txt file)', required=True)\n\n    parser.add_argument('-ribs1', '--ribosomalSAM1', help='path to the alignment of read1 to ribosomal', required=True)\n    parser.add_argument('-ribs2', '--ribosomalSAM2', help='path to the alignment of read2 to ribosomal', required=True)\n    parser.add_argument('-ribt1', '--ribosomalTXT1', help='path to the alignment of read1 to ribosomal (txt file)', required=True)\n    parser.add_argument('-ribt2', '--ribosomalTXT2', help='path to the alignment of read2 to ribosomal (txt file)', required=True)\n\n    parser.add_argument('-regs1', '--regularSAM1', help='path to the alignment of read1 to regular junction', required=True)\n    parser.add_argument('-regs2', '--regularSAM2', help='path to the alignment of read2 to regular junction', required=True)\n    parser.add_argument('-regt1', '--regularTXT1', help='path to the alignment of read1 to regular junction (txt file)', required=True)\n    parser.add_argument('-regt2', '--regularTXT2', help='path to the alignment of read2 to regular junction (txt file)', required=True)\n\n    parser.add_argument('-scrs1', '--scrambledSAM1', help='path to the alignment of read1 to scrambled junction', required=True)\n    parser.add_argument('-scrs2', '--scrambledSAM2', help='path to the alignment of read2 to scrambled junction', required=True)\n    parser.add_argument('-scrt1', '--scrambledTXT1', help='path to the alignment of read1 to scrambled junction (txt file)', required=True)\n    parser.add_argument('-scrt2', '--scrambledTXT2', help='path to the alignment of read2 to scrambled junction (txt file)', required=True)\n\n    parser.add_argument('-jm', '--junctionMidpoint', help = 'Junction midpoint', type=int, default=150)\n\n    args = parser.parse_args()\n\n    if args.verbose:\n        logfile.write(\"parentDir: \" + args.parentDir + \"\\n\")\n        logfile.write(\"sampleId: \" + args.sampleId + \"\\n\")\n        logfile.write(\"outDirName: \" + args.outDirName + \"\\n\")\n        logfile.write(\"style: \" + args.fastqIdStyle + \"\\n\")\n        logfile.write(\"a1: \" + args.aScore1 + \"\\n\")\n        logfile.write(\"a2: \" + args.aScore2 + \"\\n\")\n        logfile.write(\"overhang: \" + args.overhang + \"\\n\")\n        logfile.write(\"id dir suffix: \" + args.junctionIdDirSuffix + \"\\n\")\n        logfile.write(\"unaligned: \" + args.unalignedMode + \"\\n\")\n\n    # make output dirs if they don't exist\n    utils_os.createDirectory(\"/\".join([args.parentDir, args.outDirName]))\n    utils_os.createDirectory(\"/\".join([args.parentDir, args.outDirName, \"reports\"]))  # these are the reports using the naive method\n    #utils_os.createDirectory(\"/\".join([args.parentDir, args.outDirName, \"glmReports\"]))  # GLM will be run later and those reports will be stored here\n    #utils_os.createDirectory(\"/\".join([args.parentDir, args.outDirName, \"glmModels\"]))  # GLM will be run later and those models will be stored here\n    utils_os.createDirectory(\"/\".join([args.parentDir, args.outDirName, \"ids\"]))  # txt files of read ids assigned to circular or linear category\n    # just doing read1s\n    if args.sampleId.endswith(\"1\"):\n\n        try:\n            # populate the ignoreIds, regIds, nonRegIds for this file and also print out regIds and nonRegIds to juncNonGR file\n            ignoreIds = {}  # ribo and genome aligned\n            regIds = {}  # regular junction overlapped and not ribo or genome aligned (aligned to reg-only index)\n            nonRegIds = {}  # junction overlapped and not ribo or genome aligned or regular-junction aligned\n\n            # we treat denovo reads as the equivalent of the junction reads in unalignedMode\n            if args.unalignedMode:\n                useJuncStr = \"denovo\"\n            else:\n                useJuncStr = \"junction\"\n            logfile.write(\"Start log file\\n\")\n            selectCandidateIds()\n            logfile.write(\"SelectCandidateIds finished\\n\")\n\n            #if args.verbose:\n            #    print \"ignoreIds (aligned to genome):\", str(len(ignoreIds))\n            #    print \"linearIds:\", str(len(regIds))\n            #    print \"scrambledIds:\", str(len(nonRegIds))\n\n            logfile.write(\"ignoreIds (aligned to genome):\" + str(len(ignoreIds)) + \"\\n\")\n            logfile.write(\"linearIds:\" + str(len(regIds)) + \"\\n\")\n            logfile.write(\"scrambledIds:\" + str(len(nonRegIds)) + \"\\n\")\n\n            juncReads = {}  # base read id: juncReadObj\n            junctions = {}  # junction id: list of juncObjs mapping to this junction\n\n            if not args.unalignedMode:\n                # make a pass through the sam file for read 1 to regular junctions to populate dict with juncReadObjs (key is portion of read id shared by Rd1 and Rd2)\n                #     and at the same time create entry in junction dictionary and add this read obj to the junction list of reads\n                #parseSam(\"\".join([\"/\".join([args.parentDir, \"orig\", \"reg\", args.sampleId]), \"_reg_output.sam\"]), \"r1rj\")\n                parseSam(args.regularSAM1, \"r1rj\")\n                logfile.write(\"RegularSAM1 processed\\n\")\n                total_sum = 0\n                for j in junctions:\n                    total_sum += len(junctions[j].unknownReads)\n                logfile.write(\"Len: \" + str(total_sum) + \"\\n\")\n                logfile.write(\"Len reads: \" + str(len(juncReads)) + \"\\n\")\n\n            # make a pass through the sam for read 1 to all junctions file to populate dict with juncReadObjs (key is portion of read id shared by Rd1 and Rd2)\n            #     and at the same time create entry in junction dictionary and add this read obj to the junction list of reads\n            #parseSam(\"_\".join([\"/\".join([args.parentDir, \"orig\", useJuncStr, args.sampleId]), useJuncStr, \"output.sam\"]), \"r1j\")\n                parseSam(args.scrambledSAM1, \"r1j\")\n                logfile.write(\"ScrambledSAM1 processed\\n\")\n                total_sum = 0\n                for j in junctions:\n                    total_sum += len(junctions[j].unknownReads)\n                logfile.write(\"Len: \" + str(total_sum) + \"\\n\")\n                logfile.write(\"Len reads: \" + str(len(juncReads)) + \"\\n\")\n\n            # get mate alignment data if this is from paired end sequencing\n            if not args.singleEnd:\n                if args.unalignedMode:\n                    alignedMateId = args.sampleId[10:-1] + \"2\"  # trim off unaligned_ from start of id, change 1 to 2\n                else:\n                    alignedMateId = args.sampleId[:-1] + \"2\"\n\n                # make a pass through Rd2 to genome sam file to update mateGenomic in each juncReadObj\n                #parseSam(\"\".join([\"/\".join([args.parentDir, \"orig\", \"genome\", alignedMateId]), \"_genome_output.sam\"]), \"gMate\")\n                parseSam(args.genomeSAM2, \"gMate\")\n                logfile.write(\"GenomeSAM2 processed\\n\")\n                total_sum = 0\n                for j in junctions:\n                    total_sum += len(junctions[j].unknownReads)\n                logfile.write(\"Len: \" + str(total_sum) + \"\\n\")\n                logfile.write(\"Len reads: \" + str(len(juncReads)) + \"\\n\")\n\n                # make a pass through Rd2 to junction sam file to update mateRegJunction in each juncReadObj\n                #parseSam(\"\".join([\"/\".join([args.parentDir, \"orig\", \"reg\", alignedMateId]), \"_reg_output.sam\"]), \"rjMate\")\n                parseSam(args.regularSAM2, \"rjMate\")\n                logfile.write(\"RegularSAM2 processed\\n\")\n                total_sum = 0\n                for j in junctions:\n                    total_sum += len(junctions[j].unknownReads)\n                logfile.write(\"Len: \" + str(total_sum) + \"\\n\")\n                logfile.write(\"Len reads: \" + str(len(juncReads)) + \"\\n\")\n\n                # make a pass through Rd2 to junction sam file to update mateJunction in each juncReadObj\n                #parseSam(\"\".join([\"/\".join([args.parentDir, \"orig\", \"junction\", alignedMateId]), \"_junction_output.sam\"]), \"jMate\")\n                parseSam(args.scrambledSAM2, \"rjMate\")\n                logfile.write(\"ScrambledSAM2 processed\\n\")\n                total_sum = 0\n                for j in junctions:\n                    total_sum += len(junctions[j].unknownReads)\n                logfile.write(\"Len: \" + str(total_sum) + \"\\n\")\n                logfile.write(\"Len reads: \" + str(len(juncReads)) + \"\\n\")\n\n                # make a pass through Rd2 to de novo sam file to update mateDenovo in each juncReadObj\n                #if args.unalignedMode:\n                #    parseSam(\"\".join(\n                #        [\"/\".join([args.parentDir, \"orig\", \"denovo\", args.sampleId[:-1]]), \"2_denovo_output.sam\"]),\n                #             \"dMate\")\n\n            if args.verbose:\n                logfile.write(\"sample id: \" + str(args.sampleId))\n                logfile.write(\"single end? \" + str(args.singleEnd))\n                logfile.write(\"num junctions with aligned reads: \" + str(len(junctions)))\n                logfile.write(\"num reads: \" + str(len(juncReads)))\n\n            logfile.write(\"Num junctions with aligned reads: \" + str(len(junctions)))\n            logfile.write(\"Num reads: \" + str(len(juncReads)))\n\n            updateReads()  # assign reads to categories based on alignment data (circular, linear, decoy, etc)\n\n            # print out some alignment statistics after reads have all been assigned to a category\n            if args.verbose:\n                numCirc = numDecoy = numLinear = numAnomaly = numUnmapped = numMultimapped = numUnknown = 0\n                for j in junctions:\n                    numCirc = numCirc + len(junctions[j].circularReads)\n                    numDecoy = numDecoy + len(junctions[j].decoyReads)\n                    numLinear = numLinear + len(junctions[j].linearReads)\n                    numAnomaly = numAnomaly + len(junctions[j].anomalyReads)\n                    numUnmapped = numUnmapped + len(junctions[j].unmappedReads)\n                    numMultimapped = numMultimapped + len(junctions[j].multimappedReads)\n                    numUnknown = numUnknown + len(junctions[j].unknownReads)\n                logfile.write(\"number of reads kept in each category after update (multimapped & unknown should be 0, anomaly & decoy should be 0 for SE data):\\n\")\n                logfile.write(\"circ: \" + str(numCirc) + \", decoy: \" + str(numDecoy) + \", linear: \" + str(\n                    numLinear) + \", anomaly: \" + str(numAnomaly) + \", unmapped: \" + str(\n                    numUnmapped) + \", multimapped: \" + str(numMultimapped) + \", unknown: \" + str(numUnknown) + \"\\n\")\n                logfile.write(str(sum([numCirc, numDecoy, numLinear, numAnomaly, numUnmapped, numMultimapped, numUnknown])) + \"\\n\")\n\n            numCirc = numDecoy = numLinear = numAnomaly = numUnmapped = numMultimapped = numUnknown = 0\n            for j in junctions:\n                numCirc = numCirc + len(junctions[j].circularReads)\n                numDecoy = numDecoy + len(junctions[j].decoyReads)\n                numLinear = numLinear + len(junctions[j].linearReads)\n                numAnomaly = numAnomaly + len(junctions[j].anomalyReads)\n                numUnmapped = numUnmapped + len(junctions[j].unmappedReads)\n                numMultimapped = numMultimapped + len(junctions[j].multimappedReads)\n                numUnknown = numUnknown + len(junctions[j].unknownReads)\n            logfile.write(\"number of reads kept in each category after update (multimapped & unknown should be 0, anomaly & decoy should be 0 for SE data):\\n\")\n            logfile.write(\"circ: \" + str(numCirc) + \", decoy: \" + str(numDecoy) + \", linear: \" + str(numLinear) + \", anomaly: \" + str(numAnomaly) + \", unmapped: \" + str(numUnmapped) + \", multimapped: \" + str(numMultimapped) + \", unknown: \" + str(numUnknown) + \"\\n\")\n            logfile.write(str(sum([numCirc, numDecoy, numLinear, numAnomaly, numUnmapped, numMultimapped, numUnknown])) + \"\\n\")\n\n\n            if args.aScore1 and args.aScore2:\n                globalCutOff = (args.aScore1, args.aScore2)\n                globalDecoyMMrate = None\n                if args.verbose:\n                    logfile.write(\"globalCutOff specified: \" + str(globalCutOff) + \"\\n\")\n            else:\n                # use decoy distribution\n                globalCutOff = None\n                globalDecoyMMrate = getDecoyMismatchRate()\n\n                # if there were no decoys, use the default seqErrorRate\n                if globalDecoyMMrate == None:\n                    globalDecoyMMrate = args.seqErrorRate\n\n                if args.verbose:\n                    logfile.write(\"using decoy rate: \" + str(globalDecoyMMrate) + \"\\n\")\n\n            logfile.write(\"using decoy rate: \" + str(globalDecoyMMrate) + \"\\n\")\n            reportCircularReads(globalCutOff)  # output reports\n            reportAllReadIds2(globalCutOff)  # output ids used in the reports for further manual investigation if desired + GLM uses these category assignments\n\n        except Exception as e:\n            logfile.write(\"Exception\\n\")\n            logfile.write(e)"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 59000
          },
          "inputs": {
            "mode": "appended",
            "overlap": 5,
            "regular_txt": [
              {
                "path": "/path/to/regular_txt-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/regular_txt-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "regular_sam": [
              {
                "path": "/path/to/regular_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/regular_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "ribosomal_sam": [
              {
                "path": "/path/to/ribosomal_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/ribosomal_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "ribosomal_txt": [
              {
                "path": "/path/to/ribosomal_txt-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/ribosomal_txt-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "genome_sam": [
              {
                "path": "/path/to/genome_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/genome_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "genome_txt": [
              {
                "path": "/path/to/genome_txt-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/genome_txt-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "scrambled_sam": [
              {
                "path": "/path/to/scrambled_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/scrambled_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "scrambled_txt": [
              {
                "path": "/path/to/scrambled_txt-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/scrambled_txt-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520432529,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520432567,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 21 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1527007840,
            "sbg:revision": 2,
            "sbg:revisionNotes": "logfile instead of print",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Publication (KNIFE)",
            "id": "https://www.ncbi.nlm.nih.gov/pubmed/26076956"
          }
        ],
        "label": "KNIFE filterFDR",
        "sbg:latestRevision": 2,
        "sbg:revisionNotes": "logfile instead of print",
        "y": 182.01562499999991,
        "inputs": [
          {
            "label": "Scrambled txt files",
            "sbg:category": "Input",
            "sbg:fileTypes": "TXT",
            "description": "Txt files which contain information about all reads aligned to the scrambled junction.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_txt)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrt1 \" + inputs[i].path\n        else\n          cmd += \" -scrt2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 12,
              "itemSeparator": null
            },
            "id": "#scrambled_txt",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "label": "Scrambled SAM files",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM",
            "description": "Sam files obtained by aligning paired_end fastq files as single-end files to the scrambled junction.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrs1 \" + inputs[i].path\n        else\n          cmd += \" -scrs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 11,
              "itemSeparator": null
            },
            "id": "#scrambled_sam",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "label": "Ribosomal txt files",
            "sbg:category": "Input",
            "sbg:fileTypes": "TXT",
            "description": "Txt files which contain information about all reads aligned to the ribosomal reference.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.ribosomal_txt)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -ribt1 \" + inputs[i].path\n        else\n          cmd += \" -ribt2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 8,
              "itemSeparator": null
            },
            "id": "#ribosomal_txt",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "label": "Ribosomal sam files",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM",
            "description": "Sam files obtained by aligning paired_end fastq files as single-end files to the ribosomal reference.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.ribosomal_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -ribs1 \" + inputs[i].path\n        else\n          cmd += \" -ribs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 7,
              "itemSeparator": null
            },
            "id": "#ribosomal_sam",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "label": "Regular txt files",
            "sbg:category": "Input",
            "sbg:fileTypes": "TXT",
            "description": "Txt files which contain information about all reads aligned to the regular junction.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_txt)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regt1 \" + inputs[i].path\n        else\n          cmd += \" -regt2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 10,
              "itemSeparator": null
            },
            "id": "#regular_txt",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "label": "Regular SAM files",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM",
            "description": "Sam files obtained by aligning paired_end fastq files as single-end files to the regular junction.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regs1 \" + inputs[i].path\n        else\n          cmd += \" -regs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 9,
              "itemSeparator": null
            },
            "id": "#regular_sam",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "label": "Overlap",
            "sbg:includeInPorts": true,
            "sbg:toolDefaultValue": "8",
            "sbg:category": "Input",
            "description": "Number of bases the read needs to overlap a junction to be considered aligned to junction",
            "sbg:altPrefix": "--overhang",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "$job.inputs.overlap|8",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true,
              "position": 2,
              "prefix": "-oh"
            },
            "id": "#overlap",
            "type": [
              "null",
              "int"
            ],
            "required": false
          },
          {
            "label": "Mode",
            "sbg:includeInPorts": true,
            "sbg:altPrefix": "--fastqIdStyle",
            "required": true,
            "description": "\"Appended\" mode should be selected if read_ids in first mate ends with 1 and in the second. If reads have the same read_id in both paired_end files, \"complete\" should be selected.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-q",
              "position": 3
            },
            "id": "#mode",
            "type": [
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "appended",
                  "complete"
                ]
              }
            ]
          },
          {
            "label": "Genome txt file",
            "sbg:category": "Input",
            "sbg:fileTypes": "TXT",
            "description": "Txt files which contain information about all reads aligned to the genome reference.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_txt)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gent1 \" + inputs[i].path\n        else\n          cmd += \" -gent2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 6,
              "itemSeparator": null
            },
            "id": "#genome_txt",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          },
          {
            "label": "Genome sam files",
            "sbg:category": "Input",
            "sbg:fileTypes": "SAM",
            "description": "Sam files obtained by aligning paired_end fastq files as single-end files to the genome reference.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gens1 \" + inputs[i].path\n        else\n          cmd += \" -gens2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "position": 5,
              "itemSeparator": null
            },
            "id": "#genome_sam",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": true
          }
        ],
        "description": "FilterFDR takes alignments to the ribosomal, genome, regular and scrambled junctions and assigns paired-end reads to the junctions. In addition it determines a type of paired-end reads. Paired-end reads might be:\n\n1. \"linear\" : paired-end read is a \"linear\" if first mate is aligned to a regular junction (and not aligned neither to ribosomal and genome reference) and second mate is aligned to the same chromosome in opposite orientation and downstream or slightly upstream (to account for errors).\n\n2. \"decoy\": paired-end read is a \"decoy\" if first mate is aligned to a scrambled junction (and not aligned neither to ribosomal, genome or regular junction) and second mate is aligned to:\na. different chromosome\nb. same chromosome, but in same orientation\nc. same chromosome, opposite orientation, but out of bound defined by scrambled junction on which mate1 is aligned\n\n3. \"anomaly\": paired-end read is a \"anomaly\" if first mate is aligned to a regular junction (and not aligned neither to ribosomal, genome nor regular junction) and second mate is aligned to:\n1. different chromosome\n2. same chromosome, but in same orientation\nc. same chromosome, opposite orientation, and far away upstream\n\n4. \"circular\" paired-end read is a \"circular\" if first mate is aligned to a scrambled junction (and not aligned neither to ribosomal, genome, nor regular junction) and second mate is aligned either to the same chromosome, in opposite orientation and either to or near by the same scrambled junction.\n\n5. \"multimapped\": paired-end read is a \"multimapped\" if fist mate is aligned either to a regular junction (and not aligned neither to ribosomal, genome nor regular junction) or a scrambled junction (and not aligned neither to ribosomal, genome nor regular junction) and second mate is aligned to either genome, regular or scrambled junction with poor quality.\n\n6. \"unmapped\": otherwise\n\nfilterFDR outputs two files:\n1. report: Report contains information about junctions.\n2. output: Output contains information about reads. This file is an input to the GLM model.",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "glob": "./output/reports/*",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "label": "Report",
            "sbg:fileTypes": "TXT",
            "description": "Report contains information about junctions",
            "type": [
              "null",
              "File"
            ],
            "id": "#report"
          },
          {
            "outputBinding": {
              "glob": "./output/ids/*",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "label": "Output",
            "sbg:fileTypes": "TXT",
            "description": "Output contains information about reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#output"
          },
          {
            "outputBinding": {
              "glob": "logfile_no_sym.txt"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#logfile_no_sym"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "jordanski.milos",
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "mkdir",
          "output",
          "&&",
          "python",
          "filterFDR.py",
          "-p",
          "./",
          "-o",
          "output"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 59000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "c4.8xlarge;ebs-gp2;1024"
          }
        ],
        "sbg:createdOn": 1520432529
      },
      "inputs": [
        {
          "id": "#KNIFE_filterFDR.scrambled_txt",
          "source": [
            "#Knife_Preprocess_Aligned_Reads_3.aligned_reads"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.scrambled_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.result_sam_file"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.ribosomal_txt",
          "source": [
            "#Knife_Preprocess_Aligned_Reads_1.aligned_reads"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.ribosomal_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.result_sam_file"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.regular_txt",
          "source": [
            "#Knife_Preprocess_Aligned_Reads_2.aligned_reads"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.regular_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.result_sam_file"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.genome_txt",
          "source": [
            "#Knife_Preprocess_Aligned_Reads.aligned_reads"
          ]
        },
        {
          "id": "#KNIFE_filterFDR.genome_sam",
          "source": [
            "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#KNIFE_filterFDR.report"
        },
        {
          "id": "#KNIFE_filterFDR.output"
        },
        {
          "id": "#KNIFE_filterFDR.logfile_no_sym"
        }
      ],
      "sbg:x": 1026,
      "sbg:y": 182.01562499999991
    },
    {
      "id": "#MACHETE_combine_fasta_files",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python combine_fastas.py  -s sample1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/combine-fasta-files/3",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\t\n  if ([].concat($job.inputs.fasta_files)[0].metadata && [].concat($job.inputs.fasta_files)[0].metadata.sample_id)\n\treturn \"-s \" + [].concat($job.inputs.fasta_files)[0].metadata.sample_id\n\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 2255.7844238281255,
        "id": "milos_jordanski/spachete-salzman-collaboration/combine-fasta-files/3",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1527283178,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "combine_fastas.py",
                "fileContent": "import argparse\nimport pickle\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument('-f', '--fasta_files', nargs = '+', required=True, help='path to known fusions fasta file')\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"unique identifying of sample\")\nparser.add_argument(\"-nf\", \"--number_of_files\", required=True, help=\"number of files to split combined fasta file\")\n\nargs = parser.parse_args()\n\nnumber_of_files = int(args.number_of_files)\nunique_id = {}\nduplicate_id = {}\nid_to_line = {}\n\nfasta_files = args.fasta_files\n\nfor fasta in fasta_files:\n    with open(fasta, \"r\") as f:\n        while True:\n            line1 = f.readline()\n            if not line1:\n                break\n\n            line2 = f.readline()\n            if not line2:\n                break\n\n            split_fusion_junc_left = line1.split(\"|\")[0]\n            split_fusion_junc_right = line1.split(\"|\")[1]\n            junc_chroms_coords = split_fusion_junc_left.split(\":\")[0] + \":\" + split_fusion_junc_left.split(\":\")[\n                2] + \":\" + split_fusion_junc_left.split(\":\")[3] + \":\" + split_fusion_junc_right.split(\":\")[0] + \":\" + \\\n                                 split_fusion_junc_right.split(\":\")[2] + \":\" + split_fusion_junc_right.split(\":\")[3]\n            #value = remove_n(line2)\n            if junc_chroms_coords not in unique_id:\n                unique_id[junc_chroms_coords] = line2\n                id_to_line[junc_chroms_coords] = line1\n            else:\n                if line1 != id_to_line[junc_chroms_coords]:\n                    duplicate_id[line1] = id_to_line[junc_chroms_coords]\n            #else:\n            #\nnumber_of_lines = len(unique_id)/number_of_files\noutput_files = {}\nfor i in range(number_of_files):\n    output_files[i] = open(args.sample + \"_filtered_\" + str(i) + \".fa\", \"w\")\n\nfile_num = 0\ncount = 0\nwith open(args.sample + \"_FarJunctions.fa\", \"w\") as f:\n    for key, value in unique_id.iteritems():\n        f.write(id_to_line[key])\n        f.write(value)\n\n        count+=1\n        output_files[file_num].write(id_to_line[key])\n        output_files[file_num].write(value)\n\n        if count == number_of_lines and file_num < number_of_files - 1:\n            output_files[file_num].close()\n            count = 0\n            file_num +=1\n\noutput_files[file_num].close()\n\npickle.dump(duplicate_id, open(args.sample + \"_duplicate_FarJunctions.pickle\", \"wb\"))"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "fasta_files": [
              {
                "path": "/path/to/fasta_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample1"
                }
              },
              {
                "path": "/path/to/fasta_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "num_files": 2
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520438195,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520438214,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 15 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1527164850,
            "sbg:revision": 2,
            "sbg:revisionNotes": "duplicate_junction added",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1527283178,
            "sbg:revision": 3,
            "sbg:revisionNotes": "combine_fastas.py: duplicate_junctions modified",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_filtered_*.fa",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.fasta_files)\n\tif(input_files[0].metadata && input_files[0].metadata.sample_id)\n    {\n    \treturn input_files[0].metadata.sample_id\n    }\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#splitted_files"
          },
          {
            "outputBinding": {
              "glob": "*FarJunctions.fa",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  if ([].concat($job.inputs.fasta_files)[0].metadata && [].concat($job.inputs.fasta_files)[0].metadata.sample_id)\n\treturn [].concat($job.inputs.fasta_files)[0].metadata.sample_id\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#far_junctions"
          },
          {
            "outputBinding": {
              "glob": "*_duplicate_FarJunctions.pickle",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  if ([].concat($job.inputs.fasta_files)[0].metadata && [].concat($job.inputs.fasta_files)[0].metadata.sample_id)\n\treturn [].concat($job.inputs.fasta_files)[0].metadata.sample_id\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#duplicate_junction"
          }
        ],
        "label": "MACHETE_combine_fasta_files",
        "sbg:latestRevision": 3,
        "sbg:revisionNotes": "combine_fastas.py: duplicate_junctions modified",
        "y": 373.5842793782553,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-nf"
            },
            "id": "#num_files",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f",
              "itemSeparator": " "
            },
            "id": "#fasta_files",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "jordanski.milos",
          "milos_jordanski"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "combine_fastas.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 3,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          },
          {
            "class": "sbg:AWSInstanceType",
            "value": "r3.8xlarge"
          }
        ],
        "sbg:createdOn": 1520438195
      },
      "inputs": [
        {
          "id": "#MACHETE_combine_fasta_files.num_files",
          "default": 26
        },
        {
          "id": "#MACHETE_combine_fasta_files.fasta_files",
          "source": [
            "#MACHETE_makeJunctions_new.far_junctions"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_combine_fasta_files.splitted_files"
        },
        {
          "id": "#MACHETE_combine_fasta_files.far_junctions"
        },
        {
          "id": "#MACHETE_combine_fasta_files.duplicate_junction"
        }
      ],
      "sbg:x": 2255.7844238281255,
      "sbg:y": 373.5842793782553
    },
    {
      "id": "#MACHETE_combine_fasta_files_by_coordinate",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python combine_fastas.py  -s SAMPLE",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/combine-fasta-files-by-coordinate/9",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\t\n  if ([].concat($job.inputs.fasta_files)[0].metadata && [].concat($job.inputs.fasta_files)[0].metadata.sample_id)\n\treturn \"-s \" + [].concat($job.inputs.fasta_files)[0].metadata.sample_id\n\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 3053.9929565758675,
        "id": "milos_jordanski/spachete-salzman-collaboration/combine-fasta-files-by-coordinate/9",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1527260600,
        "sbg:createdBy": "jordanski.milos",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "combine_fastas.py",
                "fileContent": "import argparse\nimport pickle\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument('-f', '--fasta_files', nargs = '+', required=True, help='path to known fusions fasta file')\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"unique identifying of sample\")\nparser.add_argument(\"-sf\", \"--suffix\", required=True, help=\"suffix\")\n#parser.add_argument(\"-nf\", \"--number_of_files\", required=True, help=\"number of files to split combined fasta file\")\n\nargs = parser.parse_args()\n\n#number_of_files = int(args.number_of_files)\n#unique_id = {}\n#duplicate_id = {}\nchr_pos_unique = {}\nchr_pos_duplicate = {}\n\nfasta_files = args.fasta_files\n\nfor fasta in fasta_files:\n    with open(fasta, \"r\") as f:\n        while True:\n            line1 = f.readline()\n            if not line1:\n                break\n\n            line2 = f.readline()\n            if not line2:\n                break\n\n            #value = remove_n(line2)\n            #if line1 not in unique_id:\n            #    unique_id[line1] = line2\n\n            split_fusion_junc_left = line1.split(\"|\")[0]\n            split_fusion_junc_right = line1.split(\"|\")[1]\n            junc_chroms_coords = split_fusion_junc_left.split(\":\")[0] + \":\" + split_fusion_junc_left.split(\":\")[2] + \":\" + split_fusion_junc_left.split(\":\")[3] + \":\" + split_fusion_junc_right.split(\":\")[0] + \":\" + split_fusion_junc_right.split(\":\")[2] + \":\" + split_fusion_junc_right.split(\":\")[3]\n            if junc_chroms_coords not in chr_pos_unique:\n                chr_pos_unique[junc_chroms_coords] = {line1: line2}\n            elif line1 != chr_pos_unique[junc_chroms_coords].keys()[0]:\n                chr_pos_duplicate[line1] = chr_pos_unique[junc_chroms_coords].keys()[0]\n\nwith open(args.sample + \"_FarJunctions.fa\", \"w\") as f:\n    for key, value in chr_pos_unique.iteritems():\n        #f.write(key)\n        f.write(value.keys()[0])\n        f.write(value.values()[0])\n\n# number_of_lines = len(chr_pos_unique)/number_of_files\n# output_files = {}\n# for i in range(number_of_files):\n#     output_files[i] = open(args.sample + \"_filtered_\" + str(i) + \".fa\", \"w\")\n#\n# file_num = 0\n# count = 0\n# with open(args.sample + \"_FarJunctions.fa\", \"w\") as f:\n#     for key, value in chr_pos_unique.iteritems():\n#         #f.write(key)\n#         f.write(value.keys()[0])\n#         f.write(value.values()[0])\n#\n#         count+=1\n#         output_files[file_num].write(value.keys()[0])\n#         output_files[file_num].write(value.values()[0])\n#\n#         if count == number_of_lines and file_num < number_of_files - 1:\n#             output_files[file_num].close()\n#             count = 0\n#             file_num +=1\n\npickle.dump(chr_pos_duplicate, open(args.sample + \"_duplicate_\" + args.suffix + \".pickle\", \"wb\"))\n#output_files[file_num].close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "fasta_files": [
              {
                "path": "/path/to/fasta_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "SAMPLE"
                }
              },
              {
                "path": "/path/to/fasta_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "suffix": "suffix-string-value"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1525968381,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1525968830,
            "sbg:revision": 1,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1525990500,
            "sbg:revision": 2,
            "sbg:revisionNotes": "do not split output file",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1525991414,
            "sbg:revision": 3,
            "sbg:revisionNotes": "docker changed",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1525991709,
            "sbg:revision": 4,
            "sbg:revisionNotes": "write FarJunctions.fa file",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1525993902,
            "sbg:revision": 5,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1527165197,
            "sbg:revision": 6,
            "sbg:revisionNotes": "duplicate_filtered_far_junctions",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1527199960,
            "sbg:revision": 7,
            "sbg:revisionNotes": "duplicate_junctions: no seq info",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1527200432,
            "sbg:revision": 8,
            "sbg:revisionNotes": ".pickle added",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1527260600,
            "sbg:revision": 9,
            "sbg:revisionNotes": "combine_fastas.py updated",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*FarJunctions.fa",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  if ([].concat($job.inputs.fasta_files)[0].metadata && [].concat($job.inputs.fasta_files)[0].metadata.sample_id)\n\treturn [].concat($job.inputs.fasta_files)[0].metadata.sample_id\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#far_junctions"
          },
          {
            "outputBinding": {
              "glob": "*_duplicate*.pickle",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.fasta_files)\n\tif(input_files[0].metadata && input_files[0].metadata.sample_id)\n    {\n    \treturn input_files[0].metadata.sample_id\n    }\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#duplicate_filtered_far_junctions"
          }
        ],
        "label": "MACHETE_combine_fasta_files_by_coordinate",
        "sbg:latestRevision": 9,
        "sbg:revisionNotes": "combine_fastas.py updated",
        "y": 377.1167810027469,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-sf"
            },
            "id": "#suffix",
            "type": [
              "null",
              "string"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f",
              "itemSeparator": " "
            },
            "id": "#fasta_files",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "combine_fastas.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 9,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1525968381
      },
      "inputs": [
        {
          "id": "#MACHETE_combine_fasta_files_by_coordinate.suffix",
          "default": "FilteredFarJunctions"
        },
        {
          "id": "#MACHETE_combine_fasta_files_by_coordinate.fasta_files",
          "source": [
            "#MACHETE_parse_to_remove_FJ.chr_filtered_fusion_junction"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_combine_fasta_files_by_coordinate.far_junctions"
        },
        {
          "id": "#MACHETE_combine_fasta_files_by_coordinate.duplicate_filtered_far_junctions"
        }
      ],
      "sbg:x": 3053.9929565758675,
      "sbg:y": 377.1167810027469
    },
    {
      "id": "#MACHETE_combine_fasta_files_by_coordinate_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python combine_fastas.py  -s SAMPLE",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/combine-fasta-files-by-coordinate/9",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\t\n  if ([].concat($job.inputs.fasta_files)[0].metadata && [].concat($job.inputs.fasta_files)[0].metadata.sample_id)\n\treturn \"-s \" + [].concat($job.inputs.fasta_files)[0].metadata.sample_id\n\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 3037.8050130208344,
        "id": "milos_jordanski/spachete-salzman-collaboration/combine-fasta-files-by-coordinate/9",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1527260600,
        "sbg:createdBy": "jordanski.milos",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "combine_fastas.py",
                "fileContent": "import argparse\nimport pickle\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument('-f', '--fasta_files', nargs = '+', required=True, help='path to known fusions fasta file')\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"unique identifying of sample\")\nparser.add_argument(\"-sf\", \"--suffix\", required=True, help=\"suffix\")\n#parser.add_argument(\"-nf\", \"--number_of_files\", required=True, help=\"number of files to split combined fasta file\")\n\nargs = parser.parse_args()\n\n#number_of_files = int(args.number_of_files)\n#unique_id = {}\n#duplicate_id = {}\nchr_pos_unique = {}\nchr_pos_duplicate = {}\n\nfasta_files = args.fasta_files\n\nfor fasta in fasta_files:\n    with open(fasta, \"r\") as f:\n        while True:\n            line1 = f.readline()\n            if not line1:\n                break\n\n            line2 = f.readline()\n            if not line2:\n                break\n\n            #value = remove_n(line2)\n            #if line1 not in unique_id:\n            #    unique_id[line1] = line2\n\n            split_fusion_junc_left = line1.split(\"|\")[0]\n            split_fusion_junc_right = line1.split(\"|\")[1]\n            junc_chroms_coords = split_fusion_junc_left.split(\":\")[0] + \":\" + split_fusion_junc_left.split(\":\")[2] + \":\" + split_fusion_junc_left.split(\":\")[3] + \":\" + split_fusion_junc_right.split(\":\")[0] + \":\" + split_fusion_junc_right.split(\":\")[2] + \":\" + split_fusion_junc_right.split(\":\")[3]\n            if junc_chroms_coords not in chr_pos_unique:\n                chr_pos_unique[junc_chroms_coords] = {line1: line2}\n            elif line1 != chr_pos_unique[junc_chroms_coords].keys()[0]:\n                chr_pos_duplicate[line1] = chr_pos_unique[junc_chroms_coords].keys()[0]\n\nwith open(args.sample + \"_FarJunctions.fa\", \"w\") as f:\n    for key, value in chr_pos_unique.iteritems():\n        #f.write(key)\n        f.write(value.keys()[0])\n        f.write(value.values()[0])\n\n# number_of_lines = len(chr_pos_unique)/number_of_files\n# output_files = {}\n# for i in range(number_of_files):\n#     output_files[i] = open(args.sample + \"_filtered_\" + str(i) + \".fa\", \"w\")\n#\n# file_num = 0\n# count = 0\n# with open(args.sample + \"_FarJunctions.fa\", \"w\") as f:\n#     for key, value in chr_pos_unique.iteritems():\n#         #f.write(key)\n#         f.write(value.keys()[0])\n#         f.write(value.values()[0])\n#\n#         count+=1\n#         output_files[file_num].write(value.keys()[0])\n#         output_files[file_num].write(value.values()[0])\n#\n#         if count == number_of_lines and file_num < number_of_files - 1:\n#             output_files[file_num].close()\n#             count = 0\n#             file_num +=1\n\npickle.dump(chr_pos_duplicate, open(args.sample + \"_duplicate_\" + args.suffix + \".pickle\", \"wb\"))\n#output_files[file_num].close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "fasta_files": [
              {
                "path": "/path/to/fasta_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "SAMPLE"
                }
              },
              {
                "path": "/path/to/fasta_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "suffix": "suffix-string-value"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1525968381,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1525968830,
            "sbg:revision": 1,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1525990500,
            "sbg:revision": 2,
            "sbg:revisionNotes": "do not split output file",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1525991414,
            "sbg:revision": 3,
            "sbg:revisionNotes": "docker changed",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1525991709,
            "sbg:revision": 4,
            "sbg:revisionNotes": "write FarJunctions.fa file",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1525993902,
            "sbg:revision": 5,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1527165197,
            "sbg:revision": 6,
            "sbg:revisionNotes": "duplicate_filtered_far_junctions",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1527199960,
            "sbg:revision": 7,
            "sbg:revisionNotes": "duplicate_junctions: no seq info",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1527200432,
            "sbg:revision": 8,
            "sbg:revisionNotes": ".pickle added",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1527260600,
            "sbg:revision": 9,
            "sbg:revisionNotes": "combine_fastas.py updated",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*FarJunctions.fa",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  if ([].concat($job.inputs.fasta_files)[0].metadata && [].concat($job.inputs.fasta_files)[0].metadata.sample_id)\n\treturn [].concat($job.inputs.fasta_files)[0].metadata.sample_id\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#far_junctions"
          },
          {
            "outputBinding": {
              "glob": "*_duplicate*.pickle",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  input_files = [].concat($job.inputs.fasta_files)\n\tif(input_files[0].metadata && input_files[0].metadata.sample_id)\n    {\n    \treturn input_files[0].metadata.sample_id\n    }\n}",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#duplicate_filtered_far_junctions"
          }
        ],
        "label": "MACHETE_combine_fasta_files_by_coordinate_Known",
        "sbg:latestRevision": 9,
        "sbg:revisionNotes": "combine_fastas.py updated",
        "y": 867.5482177734377,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-sf"
            },
            "id": "#suffix",
            "type": [
              "null",
              "string"
            ]
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-f",
              "itemSeparator": " "
            },
            "id": "#fasta_files",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "combine_fastas.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 9,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1525968381
      },
      "inputs": [
        {
          "id": "#MACHETE_combine_fasta_files_by_coordinate_Known.suffix",
          "default": "FarJunctions_Known"
        },
        {
          "id": "#MACHETE_combine_fasta_files_by_coordinate_Known.fasta_files",
          "source": [
            "#MACHETE_parse_to_remove_known_fusions.filtered_known_fusion_junction"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_combine_fasta_files_by_coordinate_Known.far_junctions"
        },
        {
          "id": "#MACHETE_combine_fasta_files_by_coordinate_Known.duplicate_filtered_far_junctions"
        }
      ],
      "sbg:x": 3037.8050130208344,
      "sbg:y": 867.5482177734377
    },
    {
      "id": "#Trim_Galore_Skip_New",
      "run": {
        "sbg:validationErrors": [],
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/trim-galore-skip-new/2",
        "x": 358.8235700270718,
        "cwlVersion": "sbg:draft-2",
        "id": "milos_jordanski/spachete-salzman-collaboration/trim-galore-skip-new/2",
        "sbg:modifiedOn": 1527685692,
        "sbg:createdBy": "milos_jordanski",
        "sbg:canvas_y": 8,
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "steps": [
          {
            "outputs": [
              {
                "id": "#SBG_FASTQ_Split_new.results"
              }
            ],
            "sbg:x": 363,
            "inputs": [
              {
                "id": "#SBG_FASTQ_Split_new.threads"
              },
              {
                "default": {
                  "files": 30
                },
                "id": "#SBG_FASTQ_Split_new.split_by",
                "source": [
                  "#split_by"
                ]
              },
              {
                "id": "#SBG_FASTQ_Split_new.skip",
                "source": [
                  "#skip_trimming"
                ]
              },
              {
                "id": "#SBG_FASTQ_Split_new.mem"
              },
              {
                "id": "#SBG_FASTQ_Split_new.fastq",
                "source": [
                  "#fastq"
                ]
              },
              {
                "id": "#SBG_FASTQ_Split_new.cpu"
              }
            ],
            "run": {
              "sbg:validationErrors": [],
              "sbg:cmdPreview": "python3 sbg_fastq_split.py 2>>split.log 1>>split.log",
              "sbg:id": "milos_jordanski/spachete-salzman-collaboration/sbg-fastq-split-new/1",
              "arguments": [
                {
                  "valueFrom": {
                    "class": "Expression",
                    "script": "{\n  ext = [].concat($job.inputs.fastq)[0].path.split('.').pop()\n  if($job.inputs.skip && ext != 'gz' && ext != 'GZ')\n  \treturn \"\\\"\"\n}",
                    "engine": "#cwl-js-engine"
                  },
                  "separate": true,
                  "position": 100
                }
              ],
              "x": 363,
              "sbg:categories": [
                "FASTQ-Processing"
              ],
              "sbg:toolAuthor": "Seven Bridges Genomics",
              "id": "milos_jordanski/spachete-salzman-collaboration/sbg-fastq-split-new/1",
              "temporaryFailCodes": [],
              "stdin": "",
              "sbg:modifiedOn": 1524401754,
              "sbg:createdBy": "milos_jordanski",
              "requirements": [
                {
                  "class": "ExpressionEngineRequirement",
                  "requirements": [
                    {
                      "class": "DockerRequirement",
                      "dockerPull": "rabix/js-engine"
                    }
                  ],
                  "id": "#cwl-js-engine"
                },
                {
                  "class": "CreateFileRequirement",
                  "fileDef": [
                    {
                      "filename": "sbg_fastq_split.py",
                      "fileContent": "\"\"\"\nUsage:\n    sbg_fastq_split.py [--job_json FILE]\n\nOptions:\n    -h, --help          Show this message.\n\n    -j, --job_json FILE A job.json file location \n                        [default: job.json]\n\n\"\"\"\n\nfrom docopt import docopt\nimport os\nimport math\nimport subprocess\nimport multiprocessing\nfrom copy import deepcopy\nfrom CWL import CWL\nfrom Compressor import PigzCompressor\nargs = docopt(__doc__, version='1.0')\n\nnumber_of_files = 0\n\nSPLIT_BY_KEY = 'split_by'\nREADS_KEY = 'reads'\nFILES_KEY = 'files'\nFILE_SEGMENT_KEY = 'file_segment_number'\nFASTQ_KEY = 'fastq'\nOUTPUT_KEY = 'results'\nMETADATA_KEY = 'metadata'\nPATH_KEY = 'path'\nTHREADS_KEY = 'threads'\nFASTQ_OUT_EXT = '.fastq'\n\n\ndef is_gz(path):\n    with open(path, 'rb') as f:\n        r = f.read(2)\n    return r == b'\\x1f\\x8b'\n\n\ndef get_suffix_len(n):\n    return len(str(n)) if n else 1\n\n\ndef get_prefix(path):\n    name = os.path.split(path)[1]\n    return os.path.splitext(name[:-3] if name.lower().endswith('.gz') else name)[0] + '.'\n\n\ndef split_file(fq, args):\n    global number_of_files\n    results = []\n    done = []\n\n    tmp = '5'\n    print(tmp)\n    def output_chunk(chunk_path):\n        \n        gz_path = chunk_path[1:-1] + '.gz'\n        results.append(gz_path)\n\n    def line_processor(line):\n        if done:\n            output_chunk(done.pop())\n        res = line[line.find(\"=\") + 1:]\n        done.append(res.strip())\n\n    path = fq\n    gz = is_gz(path)\n    prefix = get_prefix(path)\n    uncompressed_input = path\n    if gz:\n        pipe = prefix + 'pipe'\n        if os.path.exists(pipe):\n            os.remove(pipe)\n        ziper = PigzCompressor()\n        with open(pipe, 'w') as fpipe:\n            with open(path, 'r') as fin:\n                ziper.decompress(stdin=fin, stdout=fpipe)\n        uncompressed_input = pipe\n\n    try:\n        cmd = ['wc', '-l', uncompressed_input]\n        line_count = subprocess.check_output(cmd).decode('UTF-8').strip()\n        line_count = int(line_count[:line_count.index(' ')])\n        if line_count % 4 not in (0, 1):\n            raise Exception('Invalid FASTQ file \"%s\", line count is not a multiple of 4' % path)\n        if line_count % 4 == 1:\n            line_count -= 1\n        total_reads = line_count / 4\n\n        reads_per_file = \\\n            int(math.ceil(total_reads / float(number_of_files))) if number_of_files else args[SPLIT_BY_KEY][READS_KEY]\n        number_of_files = int(math.ceil(total_reads / float(reads_per_file)))\n        suffix_length = get_suffix_len(number_of_files)\n        split_filter = 'pigz -p ' + str(args[THREADS_KEY]) \\\n            if THREADS_KEY in args and args[THREADS_KEY] and isinstance(args[THREADS_KEY], int) \\\n            else 'pigz'\n        split_filter += ' > $FILE.gz'\n        cmd = ['split', '--verbose', '-a', str(suffix_length), '-l', str(4 * reads_per_file), '--numeric-suffixes=1',\n               '-d', '--filter', split_filter, str(uncompressed_input), prefix]\n\n        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)\n        for line in iter(proc.stdout.readline, ''):\n            line = line.decode('UTF-8').strip()\n            print(line)\n            if not line:\n                break\n            line_processor(line)\n        proc.wait()\n\n        chunk = done.pop()\n        output_chunk(chunk)\n    finally:\n        if gz:\n            os.remove(uncompressed_input)\n    return results\n\n\ndef work_per_file(file, args):\n    results = split_file(file, args)\n    print(results)\n    for res in results:\n        print(res)\n        final_name = \"{}{}.gz\".format(str(res[:res.rfind(\".\")]), FASTQ_OUT_EXT)\n        print(res[:res.rfind(\".\")])\n        print(FASTQ_OUT_EXT)\n        os.rename(res, final_name)\n\n\ndef get_cwl_file(name, i, file, cwl):\n    if is_gz(name):\n        basename = name.rsplit('.', 2)[0]\n    else:\n        basename = name.rsplit('.', 1)[0]\n\n    i = str(i + 1)\n    suffix_len = len(str(number_of_files))\n    while len(i) != suffix_len:\n        i = '0' + i\n    fullname = basename + '.' + str(i) + FASTQ_OUT_EXT + '.gz'\n    metadata = deepcopy(file[METADATA_KEY])\n    metadata[FILE_SEGMENT_KEY] = int(i)\n    cwl_file = cwl.create_cwl_file(fullname, metadata)\n    return cwl_file\n\n\ndef handle_single_out_file(file, cwl_files, cwl):\n    name = file[PATH_KEY]\n    for i in range(0, number_of_files):\n        cwl_files[OUTPUT_KEY].append(get_cwl_file(name, i, file, cwl))\n\n\ndef main():\n    global number_of_files\n\n    cwl = CWL(job_json=args['--job_json'])\n\n    if READS_KEY in cwl.inputs[SPLIT_BY_KEY] and cwl.inputs[SPLIT_BY_KEY][READS_KEY]:\n        cwl.inputs[SPLIT_BY_KEY][READS_KEY] = int(cwl.inputs[SPLIT_BY_KEY][READS_KEY])\n    if FILES_KEY in cwl.inputs[SPLIT_BY_KEY] and cwl.inputs[SPLIT_BY_KEY][FILES_KEY]:\n        cwl.inputs[SPLIT_BY_KEY][FILES_KEY] = int(cwl.inputs[SPLIT_BY_KEY][FILES_KEY])\n\n    number_of_files = cwl.inputs[SPLIT_BY_KEY][FILES_KEY]\n\n    if number_of_files and number_of_files < 2:\n        raise Exception('Number of files must be 2 or more!')\n\n    if isinstance(cwl.inputs[FASTQ_KEY], list) and len(cwl.inputs[FASTQ_KEY]) > 2:\n        raise Exception('Invalid number of fastq files. Max 2 fastq/fastq.gz files can be processed.')\n\n    p = None\n    if isinstance(cwl.inputs[FASTQ_KEY], list):\n        if len(cwl.inputs[FASTQ_KEY]) == 2:\n            p = multiprocessing.Process(target=work_per_file, args=(cwl.inputs[FASTQ_KEY][1][PATH_KEY], cwl.inputs,))\n            p.start()\n        work_per_file(cwl.inputs[FASTQ_KEY][0][PATH_KEY], cwl.inputs)\n    elif isinstance(cwl.inputs[FASTQ_KEY], dict):\n        work_per_file(cwl.inputs[FASTQ_KEY][PATH_KEY], cwl.inputs)\n    else:\n        raise Exception('Input fastq is neither dict or list')\n\n    if p:\n        p.join()\n\n    cwl_files = {OUTPUT_KEY: list()}\n    if not isinstance(cwl.inputs[FASTQ_KEY], list):\n        file = cwl.inputs[FASTQ_KEY]\n        handle_single_out_file(file, cwl_files, cwl)\n    else:\n        if len(cwl.inputs[FASTQ_KEY]) == 1:\n            file = cwl.inputs[FASTQ_KEY][0]\n            handle_single_out_file(file, cwl_files, cwl)\n        elif len(cwl.inputs[FASTQ_KEY]) == 2:\n            for i in range(0, number_of_files):\n                pair = list()\n                for file in cwl.inputs[FASTQ_KEY]:\n                    name = file[PATH_KEY]\n                    pair.append(get_cwl_file(name, i, file, cwl))\n                cwl_files[OUTPUT_KEY].append(pair)\n        else:\n            raise Exception(\"Invalid number of fastq files. Max 2 fastq/fastq.gz files can be processed.\")\n\n    cwl.make_cwl_output_json(out_path='cwl.output.json', cwl_files=cwl_files)\n\nif __name__ == '__main__':\n    main()"
                    },
                    {
                      "filename": "CWL.py",
                      "fileContent": "import json\nfrom collections import defaultdict\nfrom copy import deepcopy\nfrom os.path import basename, abspath\n\n# constants\nINPUTS_KEY = 'inputs'\nMETADATA_KEY = 'metadata'\nNAME_KEY = 'name'\nPATH_KEY = 'path'\nCLASS_KEY = 'class'\nLOCATION_KEY = 'location'\nUNCATEGORIZED = 'uncategorized'\n\nclass CWLFile(object):\n    _metadata = None\n    _path = None\n\n    @property\n    def metadata(self):\n        return self._metadata\n\n    @metadata.setter\n    def metadata(self, value):\n        self._metadata = value\n\n    @metadata.deleter\n    def metadata(self):\n        del self._metadata\n\n    @property\n    def path(self):\n        return self._path\n\n    @path.setter\n    def path(self, value):\n        self._path = value\n\n    @path.deleter\n    def path(self):\n        del self._path\n\n    def __str__(self):\n        return self.path if self.path else ''\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __init_str__(self, file: str):\n        self.metadata = {}\n        self.path = abspath(file)\n\n    def __init_dict__(self, file: dict):\n        self.metadata = deepcopy(file['metadata']) if file['metadata'] else {}\n        self.path = file['path'] if file['path'] else ''\n\n    def __init__(self, *args, **kwargs):\n        if (len(args) > 0):\n            if isinstance(args[0], str):\n                self.__init_str__(args[0])\n            elif isinstance(args[0], dict):\n                self.__init_dict__(args[0])\n            else:\n                raise Exception(\"Can\\'t make instance of class CWLFile. \"\n                                \"Argument have to be either instance of type str or dict. \")\n\n\n    def intersect_metadata(self, m2: dict):\n        \"\"\"\n        :param m2: Metadata dictionary\n        :return: None\n        \"\"\"\n        self.metadata = {k: v for k, v in self.metadata.items() if v == m2.get(k)}\n\n    def toJSON(self):\n        dict = {\n            CLASS_KEY: 'File',\n            PATH_KEY: self.__str__(),\n            NAME_KEY: basename(self.__str__()),\n            METADATA_KEY: self.metadata\n        }\n        return dict\n\nclass CWLGroup(dict):\n\n    def _leafs(self, obj, out: list):\n        \"\"\"\n        :param obj: CWLGroup node\n        :param out: Reference of output list\n        :return: None\n        \"\"\"\n        if isinstance(obj, list):\n            out.append(obj)\n        elif isinstance(obj, dict):\n            for _,value in obj.items():\n                self._leafs(value, out)\n        else:\n            raise Exception('Unexpected type to be flatten.')\n\n    def leafs(self):\n        \"\"\"\n        :return: List of groups located on leafs of grouped tree.\n        \"\"\"\n        out = list()\n        self._leafs(self, out)\n        return out\n\n\nclass CWL(object):\n\n    #private\n    _inputs = None\n    _job_json_path = ''\n    _cwl_output_json_path = ''\n\n    #properties\n    @property\n    def inputs(self):\n        return self._inputs\n\n    @property\n    def job_json_path(self):\n        return self._job_json_path\n\n    @job_json_path.setter\n    def job_json_path(self, value):\n        self._job_json_path = value\n\n    @job_json_path.deleter\n    def job_json_path(self):\n        del self._job_json_path\n\n    @property\n    def cwl_output_json_path(self):\n        return self._cwl_output_json_path\n\n    @cwl_output_json_path.setter\n    def cwl_output_json_path(self, value):\n        self._cwl_output_json_path = value\n\n    @cwl_output_json_path.deleter\n    def cwl_output_json_path(self):\n        del self._cwl_output_json_path\n\n\n    #methods\n    def __init__(self, job_json: str='job.json'):\n        self._inputs = dict()\n        self.parse_job_json(job_json_path=job_json)\n\n    def parse_job_json(self, job_json_path='job.json', key: str=None):\n        \"\"\"\n        :param job_json_path: Location of job.json file\n        :param key: Extract only specific key from job.json inputs\n        :return: None\n        \"\"\"\n        self.job_json_path = job_json_path\n        try:\n            with open(self.job_json_path) as job_json_file:\n                job_json = json.load(job_json_file)\n                if job_json and INPUTS_KEY in job_json:\n                    if key is None:\n                        for key in job_json[INPUTS_KEY]:\n                            self._inputs[key] = job_json[INPUTS_KEY][key]\n                    elif key in job_json[INPUTS_KEY]:\n                        inputs = job_json[INPUTS_KEY][key]\n                        self._inputs = inputs\n                    else:\n                        raise Exception('Key '+ key +' is not member of inputs property.')\n        except IOError:\n            raise Exception('ERROR parse_fastq: job.json file doesn\\'t exists')\n\n\n\n    def full_group_by(self, l, key=lambda x: x):\n        \"\"\"\n        :param l: List that will be grouped\n        :param key: Function used for creating keys in new Group \n        :return: Key, Value pairs\n        \"\"\"\n        d = defaultdict(list)\n        for item in l:\n            k = key(item)\n            if k is not None:\n                d[k].append(item)\n            else:\n                d[UNCATEGORIZED].append(item)\n        return d.items()\n\n    def group_by_metadata_key(self, metadata_key: str, inputs: list) -> CWLGroup:\n        \"\"\"\n        :param metadata_key: Key that is used for grouping\n        :param inputs: List of inputs that will be grouped\n        :return: Instance of CWLGroup after grouping by metadata_key\n        \"\"\"\n        return CWLGroup({key: [f for f in val]\n                for key, val in self.full_group_by(inputs, key=lambda x: x[METADATA_KEY][metadata_key]\n                                                                        if metadata_key in x[METADATA_KEY]\n                                                                        else None)})\n    def group_by(self, metadata_keys: list, input_key, sort_by_metadata_key: str=None) -> CWLGroup:\n        \"\"\"\n        :param metadata_keys: The keys that are used for grouping\n        :param input_key: input key in job.json inputs field\n        :param sort_by_metadata_key: Key used for sorting leafs\n        :return: Instance of CWLGroup after grouping by metadata_keys\n        \"\"\"\n        if isinstance(metadata_keys,list) and len(metadata_keys) > 0:\n            if input_key in self._inputs:\n                groups = self.group_by_metadata_key(metadata_key=metadata_keys[0],\n                                                    inputs=deepcopy(self._inputs)[input_key])\n                last_groups = [groups]\n                for i in range(1, len(metadata_keys)):\n                    metadata_key = metadata_keys[i]\n                    newGroups = list()\n                    for group in last_groups:\n                        for group_key in group:\n                            g = self.group_by_metadata_key(metadata_key=metadata_key, inputs=group[group_key])\n                            group[group_key] = g\n                            newGroups.append(group[group_key])\n                    last_groups = newGroups\n\n                if sort_by_metadata_key:\n                    for group in last_groups:\n                        for key in group:\n                            group[key].sort(key=lambda x: x[METADATA_KEY][sort_by_metadata_key])\n                return groups\n            else:\n                raise Exception('Error: ' + input_key + ' not member of ', self._inputs)\n        else:\n            raise Exception('Error: metadata_keys argument have to be non empty list.')\n\n    def create_out_json(self, file: CWLFile) -> dict:\n        \"\"\"\n        :param file: CWLFile object \n        :return: JSON representation of file \n        \"\"\"\n        out = {}\n        out[CLASS_KEY] = 'File'\n        out[PATH_KEY] = file.__str__()\n        out[NAME_KEY] = basename(file.__str__())\n        out[METADATA_KEY] = file.metadata\n        return out\n\n    def create_cwl_file(self, path: str, metadata: dict):\n        \"\"\"\n        :param path: Path to cwl file \n        :param metadata: Metadata information about file\n        :return: CWLFile\n        \"\"\"\n        cwl_file = CWLFile(path)\n        cwl_file.metadata = metadata\n        return cwl_file\n    def make_cwl_output_json(self, out_path: str, cwl_files: dict):\n        \"\"\"\n        :param out_path: Location where cwl.output.json will be created.\n        :param cwl_files: Files with metadata that will be written into cwl.output.json in the header field.\n        :param output_id: Output id in cwl.output.json\n        :return: None\n        \"\"\"\n        try:\n\n            with open(out_path, 'w') as out:\n                json.dump(cwl_files, out, default=lambda o: o.toJSON(), sort_keys=True, indent=4, separators=(',', ': '))\n\n        except Exception as e:\n            print ('Error: ' + str(e))"
                    },
                    {
                      "filename": "Compressor.py",
                      "fileContent": "from abc import ABCMeta, abstractmethod\nfrom typing import List\nimport subprocess\n\nclass Compressor(metaclass=ABCMeta):\n\n    @abstractmethod\n    def get_compress_cmd(self, params: dict = None) -> List[str]:\n        pass\n\n    @abstractmethod\n    def get_decompress_cmd(self, params: dict = None) -> List[str]:\n        pass\n\n    def compress(self, stdin, stdout, params: dict=None):\n        if not stdout:\n            raise Exception('Need to specify stdout stream')\n        subprocess.call(self.get_compress_cmd(params), stdin=stdin, stdout=stdout)\n\n    def decompress(self, stdin, stdout, params: dict=None):\n        if not stdout:\n            raise Exception('Need to specify stdout stream')\n        subprocess.call(self.get_decompress_cmd(params), stdin=stdin, stdout=stdout)\n\nclass GzipCompressor(Compressor):\n    def get_compress_cmd(self, params: dict= None) -> List[str]:\n        return ['gzip', '--force', '-c']\n\n    def get_decompress_cmd (self, params: dict= None) -> List[str]:\n        return ['gzip', '--decompress', '--force', '-c']\n\nclass PigzCompressor(Compressor):\n    def get_compress_cmd(self, params: dict = None) -> List[str]:\n        cmd = ['pigz', '--force', '--keep']\n        if params and params['threads'] and isinstance(params['threads'], int):\n            cmd.extend(['-p', str(params['threads'])])\n        return cmd\n\n    def get_decompress_cmd (self, params: dict = None) -> List[str]:\n        return ['pigz', '--decompress', '--force', '--keep']"
                    }
                  ]
                }
              ],
              "sbg:appVersion": [
                "sbg:draft-2"
              ],
              "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "cwlVersion": "sbg:draft-2",
              "sbg:job": {
                "allocatedResources": {
                  "cpu": 1,
                  "mem": 2000
                },
                "inputs": {
                  "split_by": {
                    "reads": null,
                    "files": 4
                  },
                  "cpu": 0,
                  "skip": false,
                  "mem": 0,
                  "threads": 0,
                  "fastq": [
                    {
                      "path": "/path/to/fastq-1.fastq.gz",
                      "class": "File",
                      "size": 0,
                      "secondaryFiles": []
                    },
                    {
                      "path": "/path/to/fastq-2.fastq.gz",
                      "class": "File",
                      "size": 0,
                      "secondaryFiles": []
                    }
                  ]
                }
              },
              "sbg:revisionsInfo": [
                {
                  "sbg:modifiedOn": 1524401484,
                  "sbg:revision": 0,
                  "sbg:revisionNotes": null,
                  "sbg:modifiedBy": "milos_jordanski"
                },
                {
                  "sbg:modifiedOn": 1524401754,
                  "sbg:revision": 1,
                  "sbg:revisionNotes": "rev: 22 copied",
                  "sbg:modifiedBy": "milos_jordanski"
                }
              ],
              "outputs": [
                {
                  "outputBinding": {
                    "glob": {
                      "class": "Expression",
                      "script": "{\n  return '*.f*q*'\n}",
                      "engine": "#cwl-js-engine"
                    },
                    "sbg:metadata": {
                      "sample_id": {
                        "class": "Expression",
                        "script": "{\n\tinput_file = [].concat($job.inputs.fastq)[0]\n    if (input_file.metadata && input_file.metadata.sample_id)\n      return input_file.metadata.sample_id\n}",
                        "engine": "#cwl-js-engine"
                      },
                      "paired_end": {
                        "class": "Expression",
                        "script": "{\n \toutput_name = $self.path.split('/').pop() \t\n    input_files = [].concat($job.inputs.fastq)\n    \n    for(i=0; i < input_files.length; i++)\n    {\n      ext = input_files[i].path.split('/').pop().split('.').pop()\n      if (ext == 'gz' || ext == 'GZ')\n    \tfile_name = input_files[i].path.split('/').pop().slice(0, -3)\n      else\n        file_name = input_files[i].path.split('/').pop()\n      \n      if (file_name==output_name && input_files[i].metadata && input_files[i].metadata.paired_end)\n        return input_files[i].metadata.paired_end\n    }\n}",
                        "engine": "#cwl-js-engine"
                      }
                    }
                  },
                  "label": "Results",
                  "sbg:fileTypes": "FASTQ",
                  "description": "Resulting FASTQ files",
                  "type": [
                    "null",
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "id": "#results"
                }
              ],
              "label": "SBG FASTQ Split new",
              "sbg:publisher": "sbg",
              "sbg:revisionNotes": "rev: 22 copied",
              "y": 253.015625,
              "inputs": [
                {
                  "description": "Number of threads used for compression",
                  "label": "Threads",
                  "type": [
                    "null",
                    "int"
                  ],
                  "id": "#threads"
                },
                {
                  "description": "Define splitting by number of files or by number of reads per file.",
                  "label": "Split by",
                  "type": [
                    {
                      "fields": [
                        {
                          "description": "Number of parts to split the FASTQ into.",
                          "label": "Files",
                          "type": [
                            "null",
                            "int"
                          ],
                          "name": "files"
                        },
                        {
                          "description": "Number of reads per resulting FASTQ part.",
                          "label": "Reads",
                          "type": [
                            "null",
                            "int"
                          ],
                          "name": "reads"
                        }
                      ],
                      "type": "record",
                      "name": "split_by"
                    }
                  ],
                  "id": "#split_by"
                },
                {
                  "sbg:includeInPorts": true,
                  "id": "#skip",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "required": false
                },
                {
                  "description": "Size of memory used for the tool",
                  "label": "Memory",
                  "type": [
                    "null",
                    "int"
                  ],
                  "id": "#mem"
                },
                {
                  "label": "Fastq",
                  "required": true,
                  "sbg:fileTypes": "FQ,FASTQ,FQ.GZ,FASTQ.GZ",
                  "description": "A FASTQ file.",
                  "type": [
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "id": "#fastq",
                  "sbg:stageInput": "link"
                },
                {
                  "description": "Number of CPUs used for the tool",
                  "label": "CPU",
                  "type": [
                    "null",
                    "int"
                  ],
                  "id": "#cpu"
                }
              ],
              "description": "FASTQ Splitter is a tool that can split FASTQ files into smaller chunks. Chunks can be defined either by number of new files or by number of reads per new file. If both files and reads parameters are set, fastq will be split based on selected number of files. Tool can process either one or two fastq input files. if two files are specified (eg. both paired-ends), tool will group outputs based on file segment metadata field (eg. every nth chunk from paired-end 1 is grouped with nth chunk from paired-end 2).",
              "class": "CommandLineTool",
              "sbg:license": "Apache License 2.0",
              "sbg:modifiedBy": "milos_jordanski",
              "sbg:image_url": null,
              "sbg:contributors": [
                "milos_jordanski"
              ],
              "stdout": "",
              "successCodes": [],
              "baseCommand": [
                {
                  "class": "Expression",
                  "script": "{\n  \text = [].concat($job.inputs.fastq)[0].path.split('.').pop()\n\tif($job.inputs.skip && (ext == 'gz' || ext == 'GZ'))\n    {\t\n      \tfastq_list = [].concat($job.inputs.fastq)\n      \toutput = \"gunzip -f \" \n        for(i=0; i < fastq_list.length; i++)\n        \toutput += fastq_list[i].path.split('/').pop() + \" \"\n        return output\n    }\t\n  \telse if($job.inputs.skip)\n    \t{\n        \treturn \"echo \\\"Skip\"\n        }\n  \treturn \"python3 sbg_fastq_split.py 2>>split.log 1>>split.log\"\n}",
                  "engine": "#cwl-js-engine"
                }
              ],
              "sbg:sbgMaintained": false,
              "sbg:projectName": "SPACHETE Salzman Collaboration ",
              "sbg:latestRevision": 1,
              "sbg:revision": 1,
              "sbg:toolkit": "SBGTools",
              "hints": [
                {
                  "class": "DockerRequirement",
                  "dockerImageId": "",
                  "dockerPull": "images.sbgenomics.com/milos_jordanski/python3:3.4"
                },
                {
                  "class": "sbg:CPURequirement",
                  "value": {
                    "class": "Expression",
                    "script": "{\n  if ($job.inputs.cpu){\n    return $job.inputs.cpu\n  }\n  else return 1\n}",
                    "engine": "#cwl-js-engine"
                  }
                },
                {
                  "class": "sbg:MemRequirement",
                  "value": {
                    "class": "Expression",
                    "script": "{\n  if ($job.inputs.mem){\n    return $job.inputs.mem\n  }\n  else return 2000\n}",
                    "engine": "#cwl-js-engine"
                  }
                },
                {
                  "class": "sbg:SaveLogs",
                  "value": "split.log"
                }
              ],
              "sbg:createdOn": 1524401484
            },
            "sbg:y": 253.015625,
            "id": "#SBG_FASTQ_Split_new"
          },
          {
            "outputs": [
              {
                "id": "#Trim_Galore_.unpaired_reads"
              },
              {
                "id": "#Trim_Galore_.trimming_report"
              },
              {
                "id": "#Trim_Galore_.trimmed_reads"
              },
              {
                "id": "#Trim_Galore_.fastqc_report_zip"
              },
              {
                "id": "#Trim_Galore_.fastqc_report_html"
              }
            ],
            "run": {
              "sbg:validationErrors": [],
              "sbg:cmdPreview": "echo \"Skip trimming  --fastqc_args \"-t 2 --noextract \"  /path/to/input_1.fq /path/to/input_2.fq  ; sh run_sbg_html_to_b64.sh  \"",
              "sbg:toolkitVersion": "0.4.4",
              "sbg:id": "milos_jordanski/spachete-salzman-collaboration/trim-galore/1",
              "arguments": [
                {
                  "valueFrom": {
                    "class": "Expression",
                    "script": "{\n  inputs = $job.inputs\n  fastqc = $job.inputs.fastqc\n  threads = Math.min(inputs.reads.length, 7)\n//  fastqc_args = '-t ' + threads\n  fastqc_args = \"\"\n  fastqc_pfx = 'fastqc_'\n  Object.keys(inputs).forEach(function(key) {\n    if (key.startsWith(fastqc_pfx)) {\n      type = typeof inputs[key]\n      value = inputs[key]\n      if (value) {\n        if (type === 'boolean' && value === true) {\n          fastqc_args += ' --' + key.replace(fastqc_pfx, '')\n        } else if (type === 'object' && value.class === 'File') {\n          fastqc_args += ' --' + key.replace(fastqc_pfx, '')\n          fastqc_args += ' ' + value.path\n        } else {\n          fastqc_args += ' --' + key.replace(fastqc_pfx, '')\n          if (key.replace(fastqc_pfx, '') == \"kmers\") {\n            value = Math.max(2, value)\n            value = Math.min(value, 10)\n          }\n          fastqc_args += ' ' + value\n        }\n      }\n    }\n  })\n  if (fastqc)\n    return '--fastqc_args \"' + '-t ' + threads + ' --noextract ' + fastqc_args.trim() + '\"'\n  return ''\n}",
                    "engine": "#cwl-js-engine"
                  },
                  "separate": false,
                  "position": 4,
                  "prefix": ""
                },
                {
                  "valueFrom": {
                    "class": "Expression",
                    "script": "{\n  if ($job.inputs.fastqc) \n\treturn \"; sh run_sbg_html_to_b64.sh\"\n  else\n    return \"\"\n}",
                    "engine": "#cwl-js-engine"
                  },
                  "separate": true,
                  "position": 100
                },
                {
                  "valueFrom": {
                    "class": "Expression",
                    "script": "{\n  if($job.inputs.skip_trimming)\n\treturn \"\\\"\"\n}",
                    "engine": "#cwl-js-engine"
                  },
                  "separate": true,
                  "position": 101
                }
              ],
              "x": 573,
              "sbg:categories": [
                "FASTQ-Processing",
                "Quality-Control"
              ],
              "sbg:toolAuthor": "Felix Krueger / Babraham Bioinformatics",
              "id": "milos_jordanski/spachete-salzman-collaboration/trim-galore/1",
              "temporaryFailCodes": [],
              "stdin": "",
              "sbg:modifiedOn": 1520428069,
              "sbg:createdBy": "milos_jordanski",
              "requirements": [
                {
                  "class": "ExpressionEngineRequirement",
                  "requirements": [
                    {
                      "class": "DockerRequirement",
                      "dockerPull": "rabix/js-engine"
                    }
                  ],
                  "id": "#cwl-js-engine"
                },
                {
                  "class": "CreateFileRequirement",
                  "fileDef": [
                    {
                      "filename": "sbg_html_to_b64.py",
                      "fileContent": "\"\"\"\nUsage:\n    sbg_html_to_b64.py --input FILE [--select FILE]\n\nDescription:\n    This tool is used for conversion of html file to b64 html file so it can be easily displayed in browsers.\n\nOptions:\n    -h, --help      Show this help message and exit. (For third class of tools it's required to put\n                    this option).\n\n    -v, --version   Show version and exit.\n\n    --input FILE    Input file is archive containing html and all other files included in the html file(images, etc).\n\n    --select FILE If we wish to select specific html file from folder that we wish to parse.\n\nExamples:\n    python sbg_html_to_b64.py --input sample_fastqc.zip\n\"\"\"\n\nimport os\nfrom docopt import docopt\nimport os.path\nimport base64\nimport mimetypes\nfrom bs4 import BeautifulSoup\nfrom path import Path\nfrom subprocess import call, check_output\nimport re\n\n\ndef dataurl(data, mime=None):\n    isfile = os.path.isfile(data)\n    if not isfile and not mime:\n        raise Exception('Mimetype must be provided when encoding data is not a valid file path.')\n    if not mime:\n        mimetypes.init()\n        mime, enc = mimetypes.guess_type(os.path.join('file://', data))\n        if mime is None:\n            raise Exception('rfc2397: failed to determine file type')\n    if isfile:\n        with open(data, 'r') as fpp:\n            data = fpp.read()\n    return 'data:%s;base64,%s' % (mime, base64.b64encode(data))\n\n\ndef compact_html(html_file):\n    with open(html_file) as f:\n        html = f.read()\n\n    if 'snpEff_summary' in html_file:\n        for l in html.split('\\n'):\n            if str(l).startswith('<a name'):\n                html = html.replace(str(l), str(l) + '</a>')\n        html = html.replace('<p>', '<p></p>')\n        html = html[:-358]\n        soup = BeautifulSoup(html, \"html5lib\")\n\n        js = \"javascript: void(0); document.getElementById('%s').scrollIntoView(true);\"\n        for anchor in soup.findAll('a'):\n            if 'href' in str(anchor):\n                if anchor['href'].startswith('#'):\n                    anchor['href'] = js % anchor['href'][1:]\n                else:\n                    anchor.decompose()\n            else:\n                anchor['id'] = anchor['name']\n\n        return soup.prettify()\n\n    else:\n        html = html.replace('&ge;', '>=')\n        html = html.replace('&gt;', '>')\n        html = html.replace('&lt;', '<')\n        html = html.replace('&le;', '<=')\n        html = re.sub(re.compile(\"/\\*(\\*(?!\\/)|[^*])*\\*/\", re.DOTALL), \"\", html)\n        base_dir = os.path.split(html_file)[0]\n        soup = BeautifulSoup(html, \"html5lib\")\n        for img in soup.findAll('img'):\n            if img['src'].find('data:') == 0:\n                durl_img = img['src']\n            else:\n                durl_img = dataurl(os.path.join(base_dir, img['src']))\n            img['src'] = durl_img\n        return soup.prettify()\n\n\ndef html_to_dataurl(html_file):\n    return dataurl(compact_html(html_file), mime='text/html')\n\nif __name__ == \"__main__\":\n    args = docopt(__doc__, version='1.0')\n    filename = args.get('--input')\n\n    # unzipping the archive\n    if Path(filename).ext == '.zip':\n        cmd = [\"unzip\", filename, \"-d\", \"./unzip\"]\n        call(cmd)\n\n        if args.get('--select'):\n            selected_file = args.get('--select')\n            filepath = \"./unzip/\" + args.get('--select')\n            if os.path.isfile(filepath):\n                html_file = filepath\n                b64_html = selected_file + '.b64html'\n            else:\n                raise Exception(\"File not present!\")\n        else:\n            html_file = check_output([\"find\", \"./unzip\", \"-iname\", \"*.html\"]).split('\\n')[:-1]\n            if len(html_file) == 1:\n                b64_html = Path(filename).namebase + '.b64html'\n                html_file = html_file[0]                                # conversion from list to string\n            else:\n                b64_html = [x.split('/')[-1] + '.b64html' for x in html_file]\n    else:\n        html_file = filename\n        b64_html = Path(filename).namebase + '.b64html'\n\n    # check if we need to process single or list of html files. if it is a single file then html_file is type string\n    if type(html_file) is str:\n        with open(b64_html, 'wa') as fp:\n            fp.write(html_to_dataurl(html_file))\n    elif type(b64_html) is list:\n        for i, elem in enumerate(b64_html):\n            with open(elem, 'wa') as fp:\n                print html_file[i]\n                fp.write(html_to_dataurl(html_file[i]))\n    else:\n        raise Exception('This is not good.')"
                    },
                    {
                      "filename": "run_sbg_html_to_b64.sh",
                      "fileContent": "#!/bin/bash\n\nfor i in *_fastqc.html; do\n    python sbg_html_to_b64.py --input $i\ndone"
                    }
                  ]
                }
              ],
              "sbg:appVersion": [
                "sbg:draft-2"
              ],
              "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "cwlVersion": "sbg:draft-2",
              "sbg:job": {
                "allocatedResources": {
                  "cpu": 1,
                  "mem": 1000
                },
                "inputs": {
                  "adapter": "",
                  "fastqc_casava": false,
                  "suppress_warn": false,
                  "phred64": false,
                  "three_clip_r1": null,
                  "keep": false,
                  "max_length": null,
                  "non_directional": false,
                  "no_report_file": false,
                  "quality": null,
                  "fastqc_kmers": 0,
                  "three_clip_r2": null,
                  "trim_n": false,
                  "fastqc_nofilter": false,
                  "error_rate": null,
                  "retain_unpaired": false,
                  "adapter2": "",
                  "skip_trimming": true,
                  "paired": true,
                  "predefined_adapter": null,
                  "reads": [
                    {
                      "path": "/path/to/input_2.fq",
                      "class": "File",
                      "size": 0,
                      "secondaryFiles": [],
                      "metadata": {
                        "paired_end": "2"
                      }
                    },
                    {
                      "path": "/path/to/input_1.fq",
                      "class": "File",
                      "size": 0,
                      "secondaryFiles": [],
                      "metadata": {
                        "paired_end": "1"
                      }
                    }
                  ],
                  "length": null,
                  "rrbs": false,
                  "max_n": null,
                  "length_r1": null,
                  "length_r2": null,
                  "fastqc_nogroup": false,
                  "fastqc_nano": false,
                  "fastqc": true,
                  "trim_1": false,
                  "five_clip_r1": null,
                  "five_clip_r2": null,
                  "gzip": false,
                  "stringency": null
                }
              },
              "sbg:revisionsInfo": [
                {
                  "sbg:modifiedOn": 1520428046,
                  "sbg:revision": 0,
                  "sbg:revisionNotes": null,
                  "sbg:modifiedBy": "milos_jordanski"
                },
                {
                  "sbg:modifiedOn": 1520428069,
                  "sbg:revision": 1,
                  "sbg:revisionNotes": "revision 7 copied",
                  "sbg:modifiedBy": "milos_jordanski"
                }
              ],
              "sbg:links": [
                {
                  "label": "Home page",
                  "id": "http://www.bioinformatics.babraham.ac.uk/projects/trim_galore/"
                },
                {
                  "label": "User guide",
                  "id": "https://github.com/FelixKrueger/TrimGalore/blob/master/Docs/Trim_Galore_User_Guide.md"
                }
              ],
              "label": "Trim Galore!",
              "sbg:publisher": "sbg",
              "sbg:revisionNotes": "revision 7 copied",
              "y": 258.015625,
              "inputs": [
                {
                  "label": "Trim N",
                  "sbg:toolDefaultValue": "False",
                  "description": "Removes Ns from either side of the read. This option does currently not work in RRBS mode.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "prefix": "--trim-n",
                    "position": 1
                  },
                  "id": "#trim_n",
                  "type": [
                    "null",
                    "boolean"
                  ]
                },
                {
                  "label": "Trim 1",
                  "sbg:toolDefaultValue": "False",
                  "sbg:category": "Paired-end specific",
                  "description": "Trims 1 bp off every read from its 3' end. This may be needed for FastQ files that are to be aligned as paired-end data with Bowtie. This is because Bowtie (1) regards alignments where a start/end coordinate is contained within the other read as invalid. If you are planning to use Bowtie2, BWA etc. you don't need to specify this option.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "prefix": "--trim1",
                    "position": 3
                  },
                  "id": "#trim_1",
                  "type": [
                    "null",
                    "boolean"
                  ]
                },
                {
                  "label": "3' clip read 2",
                  "sbg:toolDefaultValue": "0",
                  "description": "Instructs Trim Galore to remove <int> bp from the 3' end of read 2 AFTER adapter/quality trimming has been performed. This may remove some unwanted bias from the 3' end that is not directly related to adapter sequence or basecall quality. Default: OFF.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "--three_prime_clip_R2",
                    "position": 1
                  },
                  "id": "#three_clip_r2",
                  "type": [
                    "null",
                    "int"
                  ]
                },
                {
                  "label": "3' clip read 1",
                  "sbg:toolDefaultValue": "0",
                  "description": "Instructs Trim Galore to remove <int> bp from the 3' end of read 1 (or single-end reads) AFTER adapter/quality trimming has been performed. This may remove some unwanted bias from the 3' end that is not directly related to adapter sequence or basecall quality. Default: OFF.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "--three_prime_clip_R1",
                    "position": 1
                  },
                  "id": "#three_clip_r1",
                  "type": [
                    "null",
                    "int"
                  ]
                },
                {
                  "label": "Suppress warnings",
                  "sbg:toolDefaultValue": "False",
                  "description": "If specified any output to STDOUT or STDERR will be suppressed.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "prefix": "--suppress_warn",
                    "position": 1
                  },
                  "id": "#suppress_warn",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "sbg:stageInput": null
                },
                {
                  "label": "Stringency",
                  "sbg:toolDefaultValue": "1",
                  "description": "Overlap with adapter sequence required to trim a sequence. Defaults to a very stringent setting of 1, i.e. even a single bp of overlapping sequence will be trimmed off from the 3' end of any read.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "--stringency",
                    "position": 1
                  },
                  "id": "#stringency",
                  "type": [
                    "null",
                    "int"
                  ]
                },
                {
                  "sbg:includeInPorts": true,
                  "id": "#skip_trimming",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "sbg:stageInput": null,
                  "required": false
                },
                {
                  "label": "RRBS",
                  "sbg:toolDefaultValue": "False",
                  "sbg:category": "RRBS-specific",
                  "description": "Specifies that the input file was an MspI digested RRBS sample (recognition site: CCGG). Single-end or Read 1 sequences (paired-end) which were adapter-trimmed will have a further 2 bp removed from their 3' end. Sequences which were merely trimmed because of poor quality will not be shortened further. Read 2 of paired-end libraries will in addition have the first 2 bp removed from the 5' end (by setting '--clip_r2 2'). This is to avoid using artificial methylation calls from the filled-in cytosine positions close to the 3' MspI site in sequenced fragments. This option is not recommended for users of the NuGEN ovation RRBS System 1-16 kit.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "prefix": "--rrbs",
                    "position": 2
                  },
                  "id": "#rrbs",
                  "type": [
                    "null",
                    "boolean"
                  ]
                },
                {
                  "label": "Retain unpaired",
                  "sbg:toolDefaultValue": "False",
                  "sbg:category": "Paired-end specific",
                  "description": "If only one of the two paired-end reads became too short, the longer read will be written to either '.unpaired_1.fq' or '.unpaired_2.fq' output files. The length cutoff for unpaired single-end reads is governed by the parameters -r1/--length_1 and -r2/--length_2. Default: OFF.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "prefix": "--retain_unpaired",
                    "position": 3
                  },
                  "id": "#retain_unpaired",
                  "type": [
                    "null",
                    "boolean"
                  ]
                },
                {
                  "label": "Reads",
                  "required": true,
                  "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ",
                  "description": "Input FASTQ or Gzipped FASTQ sequencing files. Trim Galore! expects paired-end files to be supplied in a pairwise fashion, e.g. file1_1.fq file1_2.fq SRR2_1.fq.gz SRR2_2.fq.gz ... .",
                  "inputBinding": {
                    "valueFrom": {
                      "class": "Expression",
                      "script": "cmd = \"\"\nreads = [].concat($job.inputs.reads)\npaired_end = $job.inputs.paired\nreads1 = [];\nreads2 = [];\nu_reads = [];\nfor (var i = 0; i < reads.length; i++){\n    if (reads[i].metadata && reads[i].metadata.paired_end == 1){\n      reads1.push(reads[i].path);\n    }\n    else if (reads[i].metadata && reads[i].metadata.paired_end == 2){\n      reads2.push(reads[i].path);\n    }\n  else {\n  \tu_reads.push(reads[i].path);\n   }\n  }\n\nif (reads1.length > 0 && reads1.length == reads2.length && paired_end){\n\tcmd = \" \" + reads1 + \" \" + reads2;\n}\nif (u_reads.length > 0 && !paired_end){\n\tcmd =  \" \" + u_reads;\n}\ncmd\n",
                      "engine": "#cwl-js-engine"
                    },
                    "separate": false,
                    "sbg:cmdInclude": true,
                    "position": 5,
                    "itemSeparator": " "
                  },
                  "id": "#reads",
                  "type": [
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "sbg:stageInput": "link"
                },
                {
                  "label": "Quality",
                  "sbg:altPrefix": "--quality",
                  "description": "Trim low-quality ends from reads in addition to adapter removal. For RRBS samples, quality trimming will be performed first, and adapter trimming is carried in a second round. Other files are quality and adapter trimmed in a single pass. The algorithm is the same as the one used by BWA (Subtract INT from all qualities; compute partial sums from all indices to the end of the sequence; cut sequence at the index at which the sum is minimal). Default Phred score: 20.",
                  "sbg:toolDefaultValue": "20",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "-q",
                    "position": 1
                  },
                  "id": "#quality",
                  "type": [
                    "null",
                    "int"
                  ],
                  "sbg:stageInput": null
                },
                {
                  "label": "Predefined adapter",
                  "sbg:toolDefaultValue": "Auto-detection of adapter sequence",
                  "description": "Illumina - Adapter sequence to be trimmed is the first 13bp of the Illumina universal adapter 'AGATCGGAAGAGC' instead of the default auto-detection of adapter sequence. Nextera - Adapter sequence to be trimmed is the first 12bp of the Nextera adapter CTGTCTCTTATA instead of the default auto-detection of adapter sequence. Small-RNA - Adapter sequence to be trimmed is the first 12bp of the Illumina Small RNA 3' Adapter TGGAATTCTCGG instead of the default auto-detection of adapter sequence.",
                  "inputBinding": {
                    "valueFrom": {
                      "class": "Expression",
                      "script": "{\n  if (!$job.inputs.adapter) {\n    if ($job.inputs.predefined_adapter === \"illumina\")\n      return \"--illumina\"\n    else if ($job.inputs.predefined_adapter === \"nextera\")\n      return \"--nextera\"\n    else if ($job.inputs.predefined_adapter === \"small_rna\")\n      return \"--small_rna\"\n    else\n      return \"\"\n      }    \n}",
                      "engine": "#cwl-js-engine"
                    },
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "position": 1
                  },
                  "id": "#predefined_adapter",
                  "type": [
                    "null",
                    {
                      "type": "enum",
                      "name": "predefined_adapter",
                      "symbols": [
                        "illumina",
                        "nextera",
                        "small_rna"
                      ]
                    }
                  ]
                },
                {
                  "label": "Phred64",
                  "sbg:toolDefaultValue": "phred33",
                  "description": "Instructs Cutadapt to use ASCII+64 quality scores as Phred scores (Illumina 1.5 encoding) for quality trimming.",
                  "inputBinding": {
                    "valueFrom": {
                      "class": "Expression",
                      "script": "{\n  if ($job.inputs.phred64) \n    return \"--phred64\"\n  else\n    return \"--phred33\"\n}",
                      "engine": "#cwl-js-engine"
                    },
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "position": 1
                  },
                  "id": "#phred64",
                  "type": [
                    "null",
                    "boolean"
                  ]
                },
                {
                  "label": "Paired",
                  "sbg:toolDefaultValue": "False",
                  "sbg:category": "Paired-end specific",
                  "description": "This option performs length trimming of quality/adapter/RRBS trimmed reads for paired-end files. To pass the validation test, both sequences of a sequence pair are required to have a certain minimum length which is governed by the option --length (see above). If only one read passes this length threshold the other read can be rescued (see option --retain_unpaired). Using this option lets you discard too short read pairs without disturbing the sequence-by-sequence order of FastQ files which is required by many aligners. Trim Galore! expects paired-end files to be supplied in a pairwise fashion, e.g. file1_1.fq file1_2.fq SRR2_1.fq.gz SRR2_2.fq.gz ... .",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "prefix": "--paired",
                    "position": 3
                  },
                  "id": "#paired",
                  "type": [
                    "null",
                    "boolean"
                  ]
                },
                {
                  "label": "Non-directional",
                  "sbg:toolDefaultValue": "False",
                  "sbg:category": "RRBS-specific",
                  "description": "Selecting this option for non-directional RRBS libraries will screen quality-trimmed sequences for 'CAA' or 'CGA' at the start of the read and, if found, removes the first two basepairs. Like with the option '--rrbs' this avoids using cytosine positions that were filled-in during the end-repair step. '--non_directional' requires '--rrbs' to be specified as well. Note that this option does not set '--clip_r2 2' in paired-end mode.",
                  "inputBinding": {
                    "valueFrom": {
                      "class": "Expression",
                      "script": "{\n  if ($job.inputs.non_directional) {\n    if (!$job.inputs.rrbs)\n      return \"--rrbs --non_directional\"\n    else return \"--non_directional\"\n  }\n  else return \"\"\n}",
                      "engine": "#cwl-js-engine"
                    },
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "position": 2
                  },
                  "id": "#non_directional",
                  "type": [
                    "null",
                    "boolean"
                  ]
                },
                {
                  "label": "No report file",
                  "sbg:toolDefaultValue": "False",
                  "description": "If specified no report file will be generated.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "prefix": "--no_report_file",
                    "position": 1
                  },
                  "id": "#no_report_file",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "sbg:stageInput": null
                },
                {
                  "description": "The total number of Ns (as integer) a read may contain before it will be removed altogether. In a paired-end setting, either read exceeding this limit will result in the entire pair being removed from the trimmed output files.",
                  "label": "Max N",
                  "type": [
                    "null",
                    "int"
                  ],
                  "id": "#max_n",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "--max_n",
                    "position": 1
                  }
                },
                {
                  "description": "Discard reads that are longer than <INT> bp after trimming. This is only advised for smallRNA sequencing to remove non-small RNA sequences.",
                  "label": "Max length",
                  "type": [
                    "null",
                    "int"
                  ],
                  "id": "#max_length",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "--max_length",
                    "position": 1
                  }
                },
                {
                  "label": "Length read 2",
                  "sbg:altPrefix": "--length_2",
                  "sbg:category": "Paired-end specific",
                  "description": "Unpaired single-end read length cutoff needed for read 2 to be written to '.unpaired_2.fq' output file. These reads may be mapped in single-end mode. Default: 35 bp.",
                  "sbg:toolDefaultValue": "35",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "-r2",
                    "position": 3
                  },
                  "id": "#length_r2",
                  "type": [
                    "null",
                    "int"
                  ]
                },
                {
                  "label": "Length read 1",
                  "sbg:altPrefix": "--length_1",
                  "sbg:category": "Paired-end specific",
                  "description": "Unpaired single-end read length cutoff needed for read 1 to be written to '.unpaired_1.fq' output file. These reads may be mapped in single-end mode. Default: 35 bp.",
                  "sbg:toolDefaultValue": "35",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "-r1",
                    "position": 3
                  },
                  "id": "#length_r1",
                  "type": [
                    "null",
                    "int"
                  ]
                },
                {
                  "label": "Length",
                  "sbg:toolDefaultValue": "20",
                  "description": "Discard reads that became shorter than length INT because of either quality or adapter trimming. A value of '0' effectively disables this behaviour. Default: 20 bp. For paired-end files, both reads of a read-pair need to be longer than <INT> bp to be printed out to validated paired-end files (see option --paired). If only one read became too short there is the possibility of keeping such unpaired single-end reads (see --retain_unpaired). Default pair-cutoff: 20 bp.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "--length",
                    "position": 1
                  },
                  "id": "#length",
                  "type": [
                    "null",
                    "int"
                  ]
                },
                {
                  "label": "Keep",
                  "sbg:toolDefaultValue": "False",
                  "sbg:category": "RRBS-specific",
                  "description": "Keep the quality trimmed intermediate file. Default: off, which means the temporary file is being deleted after adapter trimming. Only has an effect for RRBS samples since other FastQ files are not trimmed for poor qualities separately.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "prefix": "--keep",
                    "position": 2
                  },
                  "id": "#keep",
                  "type": [
                    "null",
                    "boolean"
                  ]
                },
                {
                  "label": "Gzip",
                  "sbg:toolDefaultValue": "Decompressed file",
                  "description": "Compress the output file with GZIP. If the input files are GZIP-compressed the output files will automatically be GZIP compressed as well. As of v0.2.8 the compression will take place on the fly.",
                  "inputBinding": {
                    "valueFrom": {
                      "class": "Expression",
                      "script": "{\n  if ($job.inputs.gzip) \n    return \"--gzip\"\n  else return \"--dont_gzip\"\n\n}",
                      "engine": "#cwl-js-engine"
                    },
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "position": 1
                  },
                  "id": "#gzip",
                  "type": [
                    "null",
                    "boolean"
                  ]
                },
                {
                  "label": "5' clip read 2",
                  "sbg:toolDefaultValue": "0",
                  "description": "Instructs Trim Galore to remove <int> bp from the 5' end of read 2 (paired-end reads only). This may be useful if the qualities were very poor, or if there is some sort of unwanted bias at the 5' end. For paired-end BS-Seq, it is recommended to remove the first few bp because the end-repair reaction may introduce a bias towards low methylation. Please refer to the M-bias plot section in the Bismark User Guide for some examples. Default: OFF.",
                  "inputBinding": {
                    "valueFrom": {
                      "class": "Expression",
                      "script": "{\n  if ($job.inputs.five_clip_r2) {\n  \tif ($job.inputs.paired)\n    \treturn $job.inputs.five_clip_r2\n  \telse\n    \treturn \"\"\n      }\n}",
                      "engine": "#cwl-js-engine"
                    },
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "position": 1,
                    "prefix": "--clip_R2"
                  },
                  "id": "#five_clip_r2",
                  "type": [
                    "null",
                    "int"
                  ]
                },
                {
                  "label": "5' clip read 1",
                  "sbg:toolDefaultValue": "0",
                  "description": "Instructs Trim Galore to remove <int> bp from the 5' end of read 1 (or single-end reads). This may be useful if the qualities were very poor, or if there is some sort of unwanted bias at the 5' end. Default: OFF.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "--clip_R1",
                    "position": 1
                  },
                  "id": "#five_clip_r1",
                  "type": [
                    "null",
                    "int"
                  ]
                },
                {
                  "label": "FastQC no group",
                  "sbg:toolDefaultValue": "False",
                  "sbg:category": "FastQC Arguments",
                  "description": "Disable grouping of bases for reads >50bp. All reports will show data for every base in the read.  WARNING: Using this option will cause fastqc to crash and burn if you use it on really long reads, and your plots may end up a ridiculous size. You have been warned!",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "id": "#fastqc_nogroup",
                  "sbg:stageInput": null
                },
                {
                  "label": "FastQC no filter",
                  "sbg:toolDefaultValue": "False",
                  "sbg:category": "FastQC Arguments",
                  "description": "If running with --casava then don't remove read flagged by casava as poor quality when performing the QC analysis.",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "id": "#fastqc_nofilter"
                },
                {
                  "label": "FastQC nano",
                  "sbg:toolDefaultValue": "False",
                  "sbg:category": "FastQC Arguments",
                  "description": "Files come from Nanopore sequences and are in fast5 format. In this mode you can pass in directories to process and the program will take in all fast5 files within those directories and produce a single output file from the sequences found in all files.",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "id": "#fastqc_nano"
                },
                {
                  "label": "FastQC limits",
                  "sbg:category": "FastQC Arguments",
                  "description": "Specifies a non-default file which contains a set of criteria which will be used to determine the warn/error limits for the various modules.  This file can also be used to selectively remove some modules from the output all together.  The format needs to mirror the default limits.txt file found in the Configuration folder.",
                  "type": [
                    "null",
                    "File"
                  ],
                  "id": "#fastqc_limits",
                  "required": false
                },
                {
                  "label": "FastQC kmers",
                  "sbg:toolDefaultValue": "7",
                  "sbg:category": "FastQC Arguments",
                  "description": "Specifies the length of Kmer to look for in the Kmer content module. Specified Kmer length must be between 2 and 10. Default length is 7 if not specified.",
                  "type": [
                    "null",
                    "int"
                  ],
                  "id": "#fastqc_kmers",
                  "sbg:stageInput": null
                },
                {
                  "label": "FastQC contaminants",
                  "sbg:category": "FastQC Arguments",
                  "description": "Specifies a non-default file which contains the list of contaminants to screen overrepresented sequences against. The file must contain sets of named contaminants in the form name[tab]sequence.  Lines prefixed with a hash will be ignored.",
                  "type": [
                    "null",
                    "File"
                  ],
                  "id": "#fastqc_contaminants",
                  "required": false
                },
                {
                  "label": "FastQC casava",
                  "sbg:toolDefaultValue": "False",
                  "sbg:category": "FastQC Arguments",
                  "description": "Files come from raw CASAVA output. Files in the same sample group (differing only by the group number) will be analysed as a set rather than individually. Sequences with the filter flag set in the header will be excluded from the analysis. Files must have the same names given to them by casava (including being gzipped and ending with .gz) otherwise they won't be grouped together correctly.",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "id": "#fastqc_casava"
                },
                {
                  "label": "FastQC adapters",
                  "sbg:category": "FastQC Arguments",
                  "description": "Specifies a non-default file which contains the list of adapter sequences which will be explicity searched against the library. The file must contain sets of named adapters in the form name[tab]sequence. Lines prefixed with a hash will be ignored.",
                  "type": [
                    "null",
                    "File"
                  ],
                  "id": "#fastqc_adapters",
                  "required": false
                },
                {
                  "label": "FastQC",
                  "sbg:toolDefaultValue": "False",
                  "description": "Run FastQC in the default mode on the FastQ file once trimming is complete. Passing extra FastQC arguments will automatically invoke FastQC, so --fastqc does not have to be specified separately.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": false,
                    "prefix": "--fastqc",
                    "position": 1
                  },
                  "id": "#fastqc",
                  "type": [
                    "null",
                    "boolean"
                  ]
                },
                {
                  "label": "Error rate",
                  "sbg:altPrefix": "--error_rate",
                  "description": "Maximum allowed error rate (no. of errors divided by the length of the matching region). Error rate should be between 0 and 1.",
                  "sbg:toolDefaultValue": "0.1",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "-e",
                    "position": 1
                  },
                  "id": "#error_rate",
                  "type": [
                    "null",
                    "float"
                  ]
                },
                {
                  "label": "Adapter 2",
                  "sbg:altPrefix": "--adapter2",
                  "description": "Optional adapter sequence to be trimmed off read 2 of paired-end files. This option requires paired-end to be selected as well. If the libraries to be trimmed are smallRNA then a2 will be set to the Illumina small RNA 5' adapter automatically (GATCGTCGGACT).",
                  "inputBinding": {
                    "valueFrom": {
                      "class": "Expression",
                      "script": "{\n  if (($job.inputs.paired) && ($job.inputs.adapter2))\n  \treturn \"-a2 \" + $job.inputs.adapter2\n  else return \"\"\n}",
                      "engine": "#cwl-js-engine"
                    },
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "position": 1
                  },
                  "id": "#adapter2",
                  "type": [
                    "null",
                    "string"
                  ]
                },
                {
                  "label": "Adapter",
                  "sbg:altPrefix": "--adapter",
                  "description": "Adapter sequence to be trimmed. If not specified explicitly, Trim Galore will try to auto-detect whether the Illumina universal, Nextera transposase or Illumina small RNA adapter sequence was used. Also see '--illumina', '--nextera' and '--small_rna'. If no adapter can be detected within the first 1 million sequences of the first file specified Trim Galore defaults to '--illumina'.",
                  "inputBinding": {
                    "sbg:cmdInclude": true,
                    "separate": true,
                    "prefix": "-a",
                    "position": 1
                  },
                  "id": "#adapter",
                  "type": [
                    "null",
                    "string"
                  ]
                }
              ],
              "description": "A wrapper tool around Cutadapt and FastQC to consistently apply quality and adapter trimming to FastQ files, with some extra functionality for MspI-digested RRBS-type (Reduced Representation Bisufite-Seq) libraries.\n\nNote for RRBS using the NuGEN Ovation RRBS System 1-16 kit:\nOwing to the fact that the NuGEN Ovation kit attaches a varying number of nucleotides (0-3) after each MspI site Trim Galore should be run WITHOUT the option --rrbs. This trimming is accomplished in a subsequent diversity trimming step afterwards (see their manual).\n\nNote for RRBS using MseI:\nIf your DNA material was digested with MseI (recognition motif: TTAA) instead of MspI it is NOT necessary to specify --rrbs or --non_directional since virtually all reads should start with the sequence 'TAA', and this holds true for both directional and non-directional libraries. As the end-repair of 'TAA' restricted sites does not involve any cytosines it does not need to be treated especially. Instead, simply run Trim Galore! in the standard (i.e. non-RRBS) mode",
              "class": "CommandLineTool",
              "sbg:license": "GNU General Public License v3.0 only",
              "sbg:modifiedBy": "milos_jordanski",
              "outputs": [
                {
                  "outputBinding": {
                    "sbg:inheritMetadataFrom": "#input_files",
                    "glob": "*_unpaired_*.fq*"
                  },
                  "label": "Unpaired reads files",
                  "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ",
                  "description": "If only one of the two paired-end reads became too short, the longer read will be written to either '.unpaired_1.fq' or '.unpaired_2.fq' when --retain_unpaired is set to True. The length cutoff for unpaired single-end reads is governed by the parameters -r1/--length_1 and -r2/--length_2.",
                  "type": [
                    "null",
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "id": "#unpaired_reads"
                },
                {
                  "outputBinding": {
                    "sbg:inheritMetadataFrom": "#input_files",
                    "glob": "*_trimming_report.txt"
                  },
                  "label": "Trimming report files",
                  "sbg:fileTypes": "TXT",
                  "description": "Trimming report files.",
                  "type": [
                    "null",
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "id": "#trimming_report"
                },
                {
                  "outputBinding": {
                    "sbg:inheritMetadataFrom": "#reads",
                    "glob": {
                      "class": "Expression",
                      "script": "{\n  if($job.inputs.skip_trimming)\n    return \"*.f*q*\"\n  if ($job.inputs.paired) {\n    return \"*_val_*.fq*\"\n  } else {\n    return \"*_trimmed.fq*\"\n  }\n}",
                      "engine": "#cwl-js-engine"
                    },
                    "outputEval": {
                      "class": "Expression",
                      "script": "{\n  if ($job.inputs.skip_trimming)\n    return $self\n  outputs = $self\n  if ($job.inputs.paired) {\n    for (var key in outputs) {\n      read_no = outputs[key]['name'].split('_val_').slice(-1)[0][0]\n      if (outputs[key]['metadata']) {\n        outputs[key]['metadata']['paired_end'] = read_no\n      } else {\n        outputs[key]['metadata'] = {\n          paired_end: read_no\n        }\n      }  \n    }\n  }\n  return outputs\n}",
                      "engine": "#cwl-js-engine"
                    }
                  },
                  "label": "Trimmed reads",
                  "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ",
                  "description": "Output trimmed (and validated for paired-end mode) FASTQ or Gzipped FASTQ sequencing files. When --keep is set to True, trimmed reads files are also kept together with validated reads files.",
                  "type": [
                    "null",
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "id": "#trimmed_reads"
                },
                {
                  "outputBinding": {
                    "sbg:inheritMetadataFrom": "#input_files",
                    "glob": "*_fastqc.zip"
                  },
                  "label": "FastQC report zip files",
                  "sbg:fileTypes": "ZIP",
                  "description": "FastQC report zip files.",
                  "type": [
                    "null",
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "id": "#fastqc_report_zip"
                },
                {
                  "outputBinding": {
                    "sbg:inheritMetadataFrom": "#input_files",
                    "glob": "*_fastqc.b64html"
                  },
                  "label": "FastQC report HTML files",
                  "sbg:fileTypes": "HTML",
                  "description": "FastQC report HTML files.",
                  "type": [
                    "null",
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "id": "#fastqc_report_html"
                }
              ],
              "sbg:image_url": null,
              "sbg:contributors": [
                "milos_jordanski"
              ],
              "stdout": "",
              "successCodes": [],
              "baseCommand": [
                {
                  "class": "Expression",
                  "script": "{\n\tif($job.inputs.skip_trimming)\n    {\n    \treturn \"echo \\\"Skip trimming \"\n    }\n  \treturn \"trim_galore \"\n}",
                  "engine": "#cwl-js-engine"
                }
              ],
              "sbg:sbgMaintained": false,
              "sbg:projectName": "SPACHETE Salzman Collaboration ",
              "sbg:latestRevision": 1,
              "sbg:revision": 1,
              "sbg:toolkit": "Trim Galore!",
              "hints": [
                {
                  "class": "sbg:CPURequirement",
                  "value": 1
                },
                {
                  "class": "sbg:MemRequirement",
                  "value": 1000
                },
                {
                  "class": "DockerRequirement",
                  "dockerImageId": "",
                  "dockerPull": "images.sbgenomics.com/tamara_jovanovic/trim-galore:0.4.4"
                }
              ],
              "sbg:createdOn": 1520428046
            },
            "sbg:x": 573,
            "inputs": [
              {
                "id": "#Trim_Galore_.trim_n"
              },
              {
                "id": "#Trim_Galore_.trim_1"
              },
              {
                "id": "#Trim_Galore_.three_clip_r2"
              },
              {
                "id": "#Trim_Galore_.three_clip_r1",
                "source": [
                  "#three_clip_r1"
                ]
              },
              {
                "id": "#Trim_Galore_.suppress_warn",
                "source": [
                  "#suppress_warn"
                ]
              },
              {
                "id": "#Trim_Galore_.stringency"
              },
              {
                "id": "#Trim_Galore_.skip_trimming",
                "source": [
                  "#skip_trimming"
                ]
              },
              {
                "id": "#Trim_Galore_.rrbs"
              },
              {
                "id": "#Trim_Galore_.retain_unpaired"
              },
              {
                "id": "#Trim_Galore_.reads",
                "source": [
                  "#SBG_FASTQ_Split_new.results"
                ]
              },
              {
                "id": "#Trim_Galore_.quality"
              },
              {
                "id": "#Trim_Galore_.predefined_adapter"
              },
              {
                "id": "#Trim_Galore_.phred64"
              },
              {
                "default": true,
                "id": "#Trim_Galore_.paired",
                "source": [
                  "#paired"
                ]
              },
              {
                "id": "#Trim_Galore_.non_directional"
              },
              {
                "id": "#Trim_Galore_.no_report_file"
              },
              {
                "id": "#Trim_Galore_.max_n"
              },
              {
                "id": "#Trim_Galore_.max_length"
              },
              {
                "id": "#Trim_Galore_.length_r2"
              },
              {
                "id": "#Trim_Galore_.length_r1"
              },
              {
                "id": "#Trim_Galore_.length"
              },
              {
                "id": "#Trim_Galore_.keep"
              },
              {
                "id": "#Trim_Galore_.gzip"
              },
              {
                "id": "#Trim_Galore_.five_clip_r2",
                "source": [
                  "#five_clip_r2"
                ]
              },
              {
                "id": "#Trim_Galore_.five_clip_r1",
                "source": [
                  "#five_clip_r1"
                ]
              },
              {
                "id": "#Trim_Galore_.fastqc_nogroup"
              },
              {
                "id": "#Trim_Galore_.fastqc_nofilter"
              },
              {
                "id": "#Trim_Galore_.fastqc_nano"
              },
              {
                "id": "#Trim_Galore_.fastqc_limits"
              },
              {
                "id": "#Trim_Galore_.fastqc_kmers"
              },
              {
                "id": "#Trim_Galore_.fastqc_contaminants"
              },
              {
                "id": "#Trim_Galore_.fastqc_casava"
              },
              {
                "id": "#Trim_Galore_.fastqc_adapters"
              },
              {
                "id": "#Trim_Galore_.fastqc"
              },
              {
                "id": "#Trim_Galore_.error_rate"
              },
              {
                "id": "#Trim_Galore_.adapter2"
              },
              {
                "id": "#Trim_Galore_.adapter"
              }
            ],
            "scatter": "#Trim_Galore_.reads",
            "sbg:y": 258.015625,
            "id": "#Trim_Galore_"
          },
          {
            "outputs": [
              {
                "id": "#SBG_Flatten.flat"
              }
            ],
            "sbg:x": 776,
            "inputs": [
              {
                "id": "#SBG_Flatten.nested",
                "source": [
                  "#Trim_Galore_.trimmed_reads"
                ]
              }
            ],
            "run": {
              "sbg:validationErrors": [],
              "sbg:toolkitVersion": "1.0",
              "sbg:id": "milos_jordanski/spachete-salzman-collaboration/sbg-flatten/2",
              "arguments": [],
              "sbg:categories": [
                "Other"
              ],
              "sbg:toolAuthor": "Ana Damljanovic/ Seven Bridges Genomics",
              "id": "https://cgc-api.sbgenomics.com/v2/apps/milos_jordanski/spachete-salzman-collaboration/sbg-flatten/2/raw/",
              "temporaryFailCodes": [],
              "stdin": "",
              "sbg:modifiedOn": 1527685522,
              "sbg:createdBy": "milos_jordanski",
              "requirements": [
                {
                  "class": "CreateFileRequirement",
                  "fileDef": [
                    {
                      "filename": "sbg-flatten.py",
                      "fileContent": "\"\"\"Usage: sbg-flatten.py [--injson STR] [--outjson STR]\n\nOptions:\n  -v, --version             Show version of the script\n  -h, --help                Show this help message and exit\n  --injson STR              Path to input json file [default: job.json]\n  --outjson STR             Path to output json file [default: cwl.output.json]\n\"\"\"\nimport json\nimport os\nimport docopt\n\n\ndef flatten(my_list):\n    flat_list = []\n    for i in my_list:\n        if i is None:\n            continue\n        elif type(i) != list:\n            flat_list.append(i)\n        else:\n            flat_list.extend(flatten(i))\n    return flat_list\n\nif __name__ == '__main__':\n\n    arguments = docopt.docopt(__doc__, version=1.0)\n\n    in_json = arguments['--injson']\n    out_json = arguments['--outjson']\n    \n    with open(in_json) as fp:\n        job = json.load(fp)\n\n    nested = job['inputs']['nested']\n    flat = flatten(nested)\n    #print flat\n\n    new_flat = []\n    for idx, flat_file in enumerate(flat):\n        source_path = flat_file['path']\n        dest_path = os.path.join(os.curdir, os.path.basename(source_path))\n        new_flat.append(flat_file)\n        new_flat[idx]['path'] = os.path.abspath(dest_path)\n        #print dest_path\n\n    with open(out_json, 'w') as fp:\n        json.dump({'flat': new_flat}, fp)"
                    }
                  ]
                }
              ],
              "sbg:appVersion": [
                "sbg:draft-2"
              ],
              "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "cwlVersion": "sbg:draft-2",
              "sbg:job": {
                "allocatedResources": {
                  "cpu": 1,
                  "mem": 1000
                },
                "inputs": {
                  "nested": "nested"
                }
              },
              "sbg:revisionsInfo": [
                {
                  "sbg:modifiedOn": 1520428109,
                  "sbg:revision": 0,
                  "sbg:revisionNotes": null,
                  "sbg:modifiedBy": "milos_jordanski"
                },
                {
                  "sbg:modifiedOn": 1520428135,
                  "sbg:revision": 1,
                  "sbg:revisionNotes": "revision 4 copied",
                  "sbg:modifiedBy": "milos_jordanski"
                },
                {
                  "sbg:modifiedOn": 1527685522,
                  "sbg:revision": 2,
                  "sbg:revisionNotes": "print removed",
                  "sbg:modifiedBy": "jordanski.milos"
                }
              ],
              "outputs": [
                {
                  "description": "All grouped files as one list.",
                  "outputBinding": {
                    "sbg:metadata": {}
                  },
                  "type": [
                    "null",
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "label": "All grouped files",
                  "id": "#flat"
                }
              ],
              "label": "SBG Flatten",
              "sbg:publisher": "sbg",
              "sbg:revisionNotes": "print removed",
              "sbg:cmdPreview": "python sbg-flatten.py",
              "inputs": [
                {
                  "label": "Nested",
                  "sbg:category": "Input files",
                  "description": "Files from all SBG Group Input outputs should be provided.",
                  "type": [
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "id": "#nested",
                  "sbg:stageInput": "link"
                }
              ],
              "description": "SBG Flatten is initially wrapped for usage together with SBG Group Input app. It is now updated to support any number of nested lists as well as any number of inputs (connections from the previous apps). All connections of interest should be passed to the \"Nested\" SBG Flatten input in order to produce the output as one, flattened list of files.\n\n***Example***:\n\n`output_app1` - [file1, file2]\n\n`output_app2` - [[file3, null], [null, file4]] - which can happen in some cases if the app was scattered\n\n\n`nested` - [[file1, file2], [[file3, null], [null, file4]]]\n\n`flatten` - [file1, file2, file3, file4]",
              "class": "CommandLineTool",
              "sbg:license": "Apache License 2.0",
              "sbg:modifiedBy": "jordanski.milos",
              "sbg:image_url": null,
              "sbg:contributors": [
                "milos_jordanski",
                "jordanski.milos"
              ],
              "stdout": "",
              "successCodes": [],
              "baseCommand": [
                "python",
                "sbg-flatten.py"
              ],
              "sbg:sbgMaintained": false,
              "sbg:projectName": "SPACHETE Salzman Collaboration ",
              "sbg:latestRevision": 2,
              "sbg:revision": 2,
              "sbg:toolkit": "SBGTools",
              "hints": [
                {
                  "class": "DockerRequirement",
                  "dockerImageId": "c0e1d93b3d76",
                  "dockerPull": "images.sbgenomics.com/ana_d/sbg-flatten:2.0"
                },
                {
                  "class": "sbg:CPURequirement",
                  "value": 1
                },
                {
                  "class": "sbg:MemRequirement",
                  "value": 1000
                }
              ],
              "sbg:createdOn": 1520428109
            },
            "sbg:y": 257.015625,
            "id": "#SBG_Flatten"
          },
          {
            "outputs": [
              {
                "id": "#SBG_FASTQ_Merge_new.merged"
              }
            ],
            "sbg:x": 976,
            "inputs": [
              {
                "id": "#SBG_FASTQ_Merge_new.fastq",
                "source": [
                  "#SBG_Flatten.flat"
                ]
              },
              {
                "default": "Sample",
                "id": "#SBG_FASTQ_Merge_new.group_by"
              },
              {
                "id": "#SBG_FASTQ_Merge_new.out_compress",
                "source": [
                  "#out_compress"
                ]
              },
              {
                "id": "#SBG_FASTQ_Merge_new.cpu"
              },
              {
                "id": "#SBG_FASTQ_Merge_new.mem"
              },
              {
                "id": "#SBG_FASTQ_Merge_new.skip",
                "source": [
                  "#skip_trimming"
                ]
              }
            ],
            "run": {
              "sbg:validationErrors": [],
              "sbg:id": "milos_jordanski/spachete-salzman-collaboration/sbg-fastq-merge-new/2",
              "arguments": [
                {
                  "valueFrom": {
                    "class": "Expression",
                    "script": "{\n  if($job.inputs.skip)\n\treturn \"\\\"\"\n}",
                    "engine": "#cwl-js-engine"
                  },
                  "separate": true,
                  "position": 100
                }
              ],
              "sbg:categories": [
                "FASTQ-Processing"
              ],
              "sbg:toolAuthor": "Seven Bridges Genomics",
              "id": "https://cgc-api.sbgenomics.com/v2/apps/milos_jordanski/spachete-salzman-collaboration/sbg-fastq-merge-new/2/raw/",
              "temporaryFailCodes": [],
              "stdin": "",
              "sbg:modifiedOn": 1527685627,
              "sbg:createdBy": "milos_jordanski",
              "requirements": [
                {
                  "class": "CreateFileRequirement",
                  "fileDef": [
                    {
                      "filename": "main.py",
                      "fileContent": "\"\"\"\nUsage:\n    main.py (--group_by STR...) [--job_json FILE]\n\nArguments:\n    -g, --group_by STR       Group by level\n\nOptions:\n    -h, --help              Show this message.\n    -j, --job_json FILE     Path to job.json file.\n                            [default: job.json]\n\n\"\"\"\nfrom docopt import docopt\nfrom CWL import CWL\nfrom Merger import FASTQMerger\nargs = docopt(__doc__, version='1.0')\n\n\ndef main():\n    cwl = CWL(job_json=args['--job_json'])\n    merger = FASTQMerger()\n    group_by = args['--group_by']\n    sort_by = ['sample_id', 'library_id', 'platform_unit_id', 'paired_end', 'file_segment_number']\n    data = cwl.group_by(metadata_keys=group_by,\n                        input_key='fastq',\n                        sort_by_metadata_keys=sort_by)\n    files_out = []\n    files_location = str(cwl.inputs['fastq'][0]['path'])\n    files_location = files_location[:files_location.rfind('/')+1]\n    for group in data.leafs():\n        files_out.append(merger.merge(file_list=group,\n                                      out_path=files_location,\n                                      compress=cwl.inputs['out_compress'] if 'out_compress' in cwl.inputs else False))\n    cwl.make_cwl_output_json(out_path='cwl.output.json', cwl_files={'merged': files_out})\n    #print(files_out)\n\nif __name__ == '__main__':\n    main()"
                    },
                    {
                      "filename": "CWL.py",
                      "fileContent": "import json\nfrom collections import defaultdict\nfrom copy import deepcopy\nfrom os.path import basename, abspath\nimport typing\n\n# constants\nINPUTS_KEY = 'inputs'\nMETADATA_KEY = 'metadata'\nNAME_KEY = 'name'\nPATH_KEY = 'path'\nCLASS_KEY = 'class'\nLOCATION_KEY = 'location'\nUNCATEGORIZED = 'uncategorized'\n\nclass CWLFile(object):\n    _metadata = None\n    _path = None\n\n    @property\n    def metadata(self):\n        return self._metadata\n\n    @metadata.setter\n    def metadata(self, value):\n        self._metadata = value\n\n    @metadata.deleter\n    def metadata(self):\n        del self._metadata\n\n    @property\n    def path(self):\n        return self._path\n\n    @path.setter\n    def path(self, value):\n        self._path = value\n\n    @path.deleter\n    def path(self):\n        del self._path\n\n    def __str__(self):\n        return self.path if self.path else ''\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __init_str__(self, file: str):\n        self.metadata = {}\n        self.path = abspath(file)\n\n    def __init_dict__(self, file: dict):\n        self.metadata = deepcopy(file['metadata']) if file['metadata'] else {}\n        self.path = file['path'] if file['path'] else ''\n    def __init__(self, *args, **kwargs):\n        if (len(args) > 0):\n            if isinstance(args[0], str):\n                self.__init_str__(args[0])\n            elif isinstance(args[0], dict):\n                self.__init_dict__(args[0])\n            else:\n                raise Exception(\"Can\\'t make instance of class CWLFile. \"\n                                \"Argument have to be either instance of type str or dict. \")\n\n\n    def intersect_metadata(self, m2: dict):\n        \"\"\"\n        :param m2: Metadata dictionary\n        :return: None\n        \"\"\"\n        self.metadata = {k: v for k, v in self.metadata.items() if v == m2.get(k)}\n\n    def toJSON(self):\n        dict = {\n            CLASS_KEY: 'File',\n            PATH_KEY: self.__str__(),\n            NAME_KEY: basename(self.__str__()),\n            METADATA_KEY: self.metadata\n        }\n        return dict\n\nclass CWLGroup(dict):\n\n    def _leafs(self, obj, out: list):\n        \"\"\"\n        :param obj: CWLGroup node\n        :param out: Reference of output list\n        :return: None\n        \"\"\"\n        if isinstance(obj, list):\n            out.append(obj)\n        elif isinstance(obj, dict):\n            for _,value in obj.items():\n                self._leafs(value, out)\n        else:\n            raise Exception('Unexpected type to be flatten.')\n\n    def leafs(self):\n        \"\"\"\n        :return: List of groups located on leafs of grouped tree.\n        \"\"\"\n        out = list()\n        self._leafs(self, out)\n        return out\n\nclass CWL(object):\n\n    #private\n    _inputs = None\n    _job_json_path = ''\n    _cwl_output_json_path = ''\n\n    #properties\n    @property\n    def inputs(self):\n        return self._inputs\n\n    @property\n    def job_json_path(self):\n        return self._job_json_path\n\n    @job_json_path.setter\n    def job_json_path(self, value):\n        self._job_json_path = value\n\n    @job_json_path.deleter\n    def job_json_path(self):\n        del self._job_json_path\n\n    @property\n    def cwl_output_json_path(self):\n        return self._cwl_output_json_path\n\n    @cwl_output_json_path.setter\n    def cwl_output_json_path(self, value):\n        self._cwl_output_json_path = value\n\n    @cwl_output_json_path.deleter\n    def cwl_output_json_path(self):\n        del self._cwl_output_json_path\n\n    #methods\n    def __init__(self, job_json: str='job.json'):\n        self._inputs = dict()\n        self.parse_job_json(job_json_path=job_json)\n\n    def parse_job_json(self, job_json_path='job.json', key: str=None):\n        \"\"\"\n        :param job_json_path: Location of job.json file\n        :param key: Extract only specific key from job.json inputs\n        :return: None\n        \"\"\"\n        self.job_json_path = job_json_path\n        try:\n            with open(self.job_json_path) as job_json_file:\n                job_json = json.load(job_json_file)\n                if job_json and INPUTS_KEY in job_json:\n                    if key is None:\n                        for key in job_json[INPUTS_KEY]:\n                            self._inputs[key] = job_json[INPUTS_KEY][key]\n                    elif key in job_json[INPUTS_KEY]:\n                        inputs = job_json[INPUTS_KEY][key]\n                        self._inputs = inputs\n                    else:\n                        raise Exception('Key '+ key +' is not member of inputs property.')\n        except IOError:\n            raise Exception('ERROR parse_fastq: job.json file doesn\\'t exists')\n\n    def full_group_by(self, l, key=lambda x: x):\n        \"\"\"\n        :param l: List that will be grouped\n        :param key: Function used for creating keys in new Group \n        :return: Key, Value pairs\n        \"\"\"\n        d = defaultdict(list)\n        for item in l:\n            k = key(item)\n            if k is not None:\n                d[k].append(item)\n            else:\n                d[UNCATEGORIZED].append(item)\n        return d.items()\n\n    def group_by_metadata_key(self, metadata_key: str, inputs: list) -> CWLGroup:\n        \"\"\"\n        :param metadata_key: Key that is used for grouping\n        :param inputs: List of inputs that will be grouped\n        :return: Instance of CWLGroup after grouping by metadata_key\n        \"\"\"\n        return CWLGroup({key: [f for f in val]\n                for key, val in self.full_group_by(inputs, key=lambda x: x[METADATA_KEY][metadata_key]\n                                                                        if metadata_key in x[METADATA_KEY]\n                                                                        else None)})\n\n    def group_by(self, metadata_keys: list, input_key, sort_by_metadata_keys: typing.List[str]=None) -> CWLGroup:\n        \"\"\"\n        :param metadata_keys: The keys that are used for grouping\n        :param input_key: input key in job.json inputs field\n        :param sort_by_metadata_keys: Keys used for sorting leafs\n        :return: Instance of CWLGroup after grouping by metadata_keys\n        \"\"\"\n        if isinstance(metadata_keys,list) and len(metadata_keys) > 0:\n            if input_key in self._inputs:\n                groups = self.group_by_metadata_key(metadata_key=metadata_keys[0],\n                                                    inputs=deepcopy(self._inputs)[input_key])\n                last_groups = [groups]\n                for i in range(1, len(metadata_keys)):\n                    metadata_key = metadata_keys[i]\n                    newGroups = list()\n                    for group in last_groups:\n                        for group_key in group:\n                            g = self.group_by_metadata_key(metadata_key=metadata_key, inputs=group[group_key])\n                            group[group_key] = g\n                            newGroups.append(group[group_key])\n                    last_groups = newGroups\n\n                if sort_by_metadata_keys:\n                    def get_str_cmp(keys, file):\n                        out = ''\n                        for k in keys:\n                            if k in file[METADATA_KEY]:\n                                out += str(file[METADATA_KEY][k])\n                        return out\n\n                    for group in last_groups:\n                        for key in group:\n                            group[key].sort(key=lambda x: get_str_cmp(sort_by_metadata_keys, x))\n                return groups\n            else:\n                raise Exception('Error: ' + input_key + ' not member of ', self._inputs)\n        else:\n            raise Exception('Error: metadata_keys argument have to be non empty list.')\n\n    def create_out_json(self, file: CWLFile) -> dict:\n        \"\"\"\n        :param file: CWLFile object \n        :return: JSON representation of file \n        \"\"\"\n        out = {}\n        out[CLASS_KEY] = 'File'\n        out[PATH_KEY] = file.__str__()\n        out[NAME_KEY] = basename(file.__str__())\n        out[METADATA_KEY] = file.metadata\n        return out\n\n    def create_cwl_file(self, path: str, metadata: dict):\n        \"\"\"\n        :param path: Path to cwl file \n        :param metadata: Metadata information about file\n        :return: CWLFile\n        \"\"\"\n        cwl_file = CWLFile(path)\n        cwl_file.metadata = metadata\n        return cwl_file\n    def make_cwl_output_json(self, out_path: str, cwl_files: dict):\n        \"\"\"\n        :param out_path: Location where cwl.output.json will be created.\n        :param cwl_files: Files with metadata that will be written into cwl.output.json in the header field.\n        :param output_id: Output id in cwl.output.json\n        :return: None\n        \"\"\"\n        try:\n\n            with open(out_path, 'w') as out:\n                json.dump(cwl_files, out, default=lambda o: o.toJSON(), sort_keys=True, indent=4, separators=(',', ': '))\n\n        except Exception as e:\n            print ('Error: ' + str(e))"
                    },
                    {
                      "filename": "Compressor.py",
                      "fileContent": "from abc import ABCMeta, abstractmethod\nfrom typing import List\nimport subprocess\n\nclass Compressor(metaclass=ABCMeta):\n\n    @abstractmethod\n    def get_compress_cmd(self, params: dict = None) -> List[str]:\n        pass\n\n    @abstractmethod\n    def get_decompress_cmd(self, params: dict = None) -> List[str]:\n        pass\n\n    def compress(self, stdin, stdout, params: dict=None):\n        if not stdout:\n            raise Exception('Need to specify stdout stream')\n        subprocess.call(self.get_compress_cmd(params), stdin=stdin, stdout=stdout)\n\n    def decompress(self, stdin, stdout, params: dict=None):\n        if not stdout:\n            raise Exception('Need to specify stdout stream')\n        subprocess.call(self.get_decompress_cmd(params), stdin=stdin, stdout=stdout)\n\n    def compress_async(self, stdin, stdout, params: dict=None):\n        if not stdout:\n            raise Exception('Need to specify stdout stream')\n        return subprocess.Popen(self.get_compress_cmd(params), stdin=stdin, stdout=stdout)\n\n    def decompress_async(self, stdin, stdout, params: dict=None):\n        if not stdout:\n            raise Exception('Need to specify stdout stream')\n        return subprocess.Popen(self.get_decompress_cmd(params), stdin=stdin, stdout=stdout)\n\nclass GzipCompressor(Compressor):\n    def get_compress_cmd(self, params: dict= None) -> List[str]:\n        return ['gzip', '--force', '-c']\n\n    def get_decompress_cmd (self, params: dict= None) -> List[str]:\n        return ['gzip', '--decompress', '--force', '-c']\n\nclass PigzCompressor(Compressor):\n    def get_compress_cmd(self, params: dict = None) -> List[str]:\n        cmd = ['pigz', '--force', '--keep']\n        if params and params['threads'] and isinstance(params['threads'], int):\n            cmd.extend(['-p', str(params['threads'])])\n        return cmd\n\n    def get_decompress_cmd (self, params: dict = None) -> List[str]:\n        return ['pigz', '--decompress', '--force', '--keep']"
                    },
                    {
                      "filename": "Merger.py",
                      "fileContent": "from pathlib import Path\nfrom CWL import CWLFile\nimport os\nimport sys\nimport subprocess\nfrom Compressor import PigzCompressor\nimport functools\nimport re\n\n\nclass Merger(object):\n\n    GZ = b'\\x1f\\x8b'\n\n    @staticmethod\n    def common_name(file_list):\n        file_names = [Path(f).name for f in file_list]\n\n        #trim left prefix '_numbers_'\n        for i in range(len(file_names)):\n            search = re.search('\\_[0-9]+\\_', file_names[i])\n            if search:\n                file_names[i] = file_names[i].lstrip(search.group())\n\n        prefix = os.path.commonprefix(file_names).rstrip('.')\n        suffix = os.path.commonprefix(list(map(lambda s: s[::-1], file_names)))[::-1]\n        return Merger.strip_gz_tail(prefix + suffix if prefix != suffix else prefix)\n\n    # @staticmethod\n    # def common_name(file_list):\n    #     file_names = [Path(f).name for f in file_list]\n    #     suffix = os.path.commonprefix(list(map(lambda s: s[::-1], file_names)))[::-1]\n    #     suffix = suffix.lstrip(' _.')\n    #     prefix = functools.reduce(Merger.longest_common_substring, file_names)\n    #     return Merger.strip_gz_tail(prefix + suffix if prefix != suffix else prefix)\n\n    @staticmethod\n    def longest_common_substring(s1, s2):\n        m = [[0] * (1 + len(s2)) for i in range(1 + len(s1))]\n        longest, x_longest = 0, 0\n        for x in range(1, 1 + len(s1)):\n            for y in range(1, 1 + len(s2)):\n                if s1[x - 1] == s2[y - 1]:\n                    m[x][y] = m[x - 1][y - 1] + 1\n                    if m[x][y] > longest:\n                        longest = m[x][y]\n                        x_longest = x\n                else:\n                    m[x][y] = 0\n        return s1[x_longest - longest: x_longest]\n\n    @staticmethod\n    def strip_gz_tail(fname):\n        return fname[:-3] if fname.endswith('.gz') else fname\n\n    def merge(self, file_list: list, out_path=os.path.dirname(sys.argv[0]), compress: bool=False):\n        try:\n            with open(file_list[0], 'rb') as f:\n                gz = f.read(2) == Merger.GZ\n            if out_path.endswith('/'):\n                result = out_path + Merger.common_name(file_list)\n            else:\n                result = out_path + '/' + Merger.common_name(file_list)\n            if compress:\n                result += '.gz'\n\n            cat_inputs = [file for file in file_list]\n            cat_inputs.insert(0, 'cat')\n            if not os.path.exists(result):\n                with open(result, 'w') as r:\n                    stream = subprocess.PIPE if gz or compress else r\n                    cat_process = subprocess.Popen(cat_inputs, stdout=stream)\n                    ziper = PigzCompressor()\n\n                    if gz:\n                        if compress:\n                            proc = ziper.decompress_async(stdin=cat_process.stdout, stdout=subprocess.PIPE)\n                            ziper.compress(stdin=proc.stdout, stdout=r)\n                            proc.wait()\n                        else:\n                            ziper.decompress(stdin=cat_process.stdout, stdout=r)\n                    else:\n                        if compress:\n                            ziper.compress(stdin=cat_process.stdout, stdout=r)\n\n                    cat_process.wait()\n            return result\n        except Exception as e:\n            print('Failed to merger files: ' + str(e))\n\n\nclass FASTQMerger(Merger):\n\n    def merge(self, file_list: list=None, out_path=os.path.dirname(sys.argv[0]), compress:bool=False):\n        merged_file = CWLFile(super(FASTQMerger, self)\n                              .merge(file_list = [x for x in map(lambda x: x['path'], file_list)],\n                                     out_path=out_path,\n                                     compress=compress))\n        merged_file.metadata = file_list[0]['metadata']\n        for i in range(1, len(file_list)):\n            merged_file.intersect_metadata(file_list[i]['metadata'])\n        return merged_file"
                    }
                  ]
                },
                {
                  "class": "ExpressionEngineRequirement",
                  "requirements": [
                    {
                      "class": "DockerRequirement",
                      "dockerPull": "rabix/js-engine"
                    }
                  ],
                  "id": "#cwl-js-engine"
                }
              ],
              "sbg:appVersion": [
                "sbg:draft-2"
              ],
              "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
              "$namespaces": {
                "sbg": "https://sevenbridges.com"
              },
              "cwlVersion": "sbg:draft-2",
              "sbg:job": {
                "allocatedResources": {
                  "cpu": 1,
                  "mem": 1
                },
                "inputs": {
                  "out_compress": true,
                  "group_by": [
                    "sample_id",
                    "paired_end"
                  ],
                  "cpu": 1,
                  "skip": true,
                  "mem": 1,
                  "fastq": [
                    {
                      "path": "fastq.ext",
                      "class": "File",
                      "size": 0,
                      "secondaryFiles": []
                    }
                  ]
                }
              },
              "sbg:revisionsInfo": [
                {
                  "sbg:modifiedOn": 1524401818,
                  "sbg:revision": 0,
                  "sbg:revisionNotes": null,
                  "sbg:modifiedBy": "milos_jordanski"
                },
                {
                  "sbg:modifiedOn": 1524401843,
                  "sbg:revision": 1,
                  "sbg:revisionNotes": "rev:2 copied",
                  "sbg:modifiedBy": "milos_jordanski"
                },
                {
                  "sbg:modifiedOn": 1527685627,
                  "sbg:revision": 2,
                  "sbg:revisionNotes": "print removed from main.py",
                  "sbg:modifiedBy": "jordanski.milos"
                }
              ],
              "outputs": [
                {
                  "outputBinding": {
                    "glob": {
                      "class": "Expression",
                      "script": "if ($job.inputs.out_compress) {\n  '*.f*q.gz'\n}\nelse {\n  '*.f*q*'\n}",
                      "engine": "#cwl-js-engine"
                    },
                    "sbg:metadata": {
                      "sample_id": {
                        "class": "Expression",
                        "script": "{\n\tinput_file = [].concat($job.inputs.fastq)[0]\n    if (input_file.metadata && input_file.metadata.sample_id)\n      return input_file.metadata.sample_id\n}",
                        "engine": "#cwl-js-engine"
                      },
                      "paired_end": {
                        "class": "Expression",
                        "script": "{\n \toutput_name = $self.path.split('/').pop() \t\n    input_files = [].concat($job.inputs.fastq)\n    \n    for(i=0; i < input_files.length; i++)\n    {\n      \n      file_name = input_files[i].path.split('/').pop()\n      \n      if (file_name==output_name && input_files[i].metadata && input_files[i].metadata.paired_end)\n        return input_files[i].metadata.paired_end\n    }\n}",
                        "engine": "#cwl-js-engine"
                      }
                    }
                  },
                  "label": "Merged",
                  "sbg:fileTypes": "FASTQ",
                  "description": "Merged FASTQ files.",
                  "type": [
                    "null",
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "id": "#merged"
                }
              ],
              "label": "SBG FASTQ Merge new",
              "sbg:publisher": "sbg",
              "sbg:revisionNotes": "print removed from main.py",
              "sbg:cmdPreview": "echo Skip \"  \"",
              "inputs": [
                {
                  "label": "Fastq",
                  "sbg:fileTypes": "FASTQ,FASTQ.GZ,FQ,FQ.GZ",
                  "description": "FASTQ files.",
                  "type": [
                    {
                      "type": "array",
                      "items": "File"
                    }
                  ],
                  "id": "#fastq",
                  "sbg:stageInput": "link"
                },
                {
                  "description": "Sample - all files from the same sample will be merged into one file for each end for paired-end reads. Library - all files from the same sample and library will be merged into one file for each end for paired-end reads. Platform unit - all files from the same sample, library and platform unit will be merged into one file for each end for paired-end reads.",
                  "label": "Group by level",
                  "type": [
                    "null",
                    {
                      "type": "enum",
                      "name": "group_by",
                      "symbols": [
                        "Sample",
                        "Library",
                        "Platform unit"
                      ]
                    }
                  ],
                  "id": "#group_by",
                  "inputBinding": {
                    "valueFrom": {
                      "class": "Expression",
                      "script": "{\n  lvl=$job.inputs.group_by\n  \n  if (lvl == 'Sample') {\n    val = ['sample_id', 'paired_end']\n  }\n  else if (lvl == 'Library') {\n\tval = ['sample_id', 'library_id', 'paired_end']\n  }\n  else if (lvl == 'Platform unit') {\n\tval = ['sample_id', 'library_id', 'platform_unit', 'paired_end']\n  }\n  else {\n    val = ['sample_id', 'paired_end']\n  }\n  return '--group_by ' + val.join(' --group_by ')\n}",
                      "engine": "#cwl-js-engine"
                    },
                    "separate": true,
                    "sbg:cmdInclude": true,
                    "itemSeparator": null
                  }
                },
                {
                  "description": "Compress merged fastq files on output",
                  "label": "Compress output",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "id": "#out_compress",
                  "sbg:stageInput": null
                },
                {
                  "description": "Number of CPUs used for the tool",
                  "label": "CPU",
                  "type": [
                    "null",
                    "int"
                  ],
                  "id": "#cpu",
                  "sbg:stageInput": null
                },
                {
                  "description": "Size of memory used for the tool",
                  "label": "Memory",
                  "type": [
                    "null",
                    "int"
                  ],
                  "id": "#mem",
                  "sbg:stageInput": null
                },
                {
                  "sbg:includeInPorts": true,
                  "id": "#skip",
                  "type": [
                    "null",
                    "boolean"
                  ],
                  "sbg:stageInput": null
                }
              ],
              "description": "SBG FASTQ Merge is a tool that concatenates FASTQ files based on chosen grouping parameter and file metadata: Sample ID, Library ID, Platform unit ID, File segment number and Paired End information.\n\nMetadata fields that are uniquely defining one FASTQ pair are Sample ID, Library ID, Platform unit ID and File segment number. Listed order of metadata fields is also representing their hierarchy in the metadata structure. Not all of these four metadata fields are required, but the present set has to be sufficient to create unique combinations for each pair of FASTQ files.",
              "class": "CommandLineTool",
              "sbg:license": "Apache License 2.0",
              "sbg:modifiedBy": "jordanski.milos",
              "sbg:image_url": null,
              "sbg:contributors": [
                "milos_jordanski",
                "jordanski.milos"
              ],
              "stdout": "",
              "successCodes": [],
              "baseCommand": [
                {
                  "class": "Expression",
                  "script": "{\n\tif($job.inputs.skip)\n    {\n    \treturn \"echo Skip \\\"\"\n    }\n  \treturn \"python3.4 main.py\"\n}",
                  "engine": "#cwl-js-engine"
                }
              ],
              "sbg:sbgMaintained": false,
              "sbg:projectName": "SPACHETE Salzman Collaboration ",
              "sbg:latestRevision": 2,
              "sbg:revision": 2,
              "sbg:toolkit": "SBGTools",
              "hints": [
                {
                  "class": "DockerRequirement",
                  "dockerImageId": "",
                  "dockerPull": "images.sbgenomics.com/milos_jordanski/python3:3.4"
                },
                {
                  "class": "sbg:CPURequirement",
                  "value": {
                    "class": "Expression",
                    "script": "{\n  if ($job.inputs.cpu){\n    return $job.inputs.cpu\n  }\n  else return 1\n}",
                    "engine": "#cwl-js-engine"
                  }
                },
                {
                  "class": "sbg:MemRequirement",
                  "value": {
                    "class": "Expression",
                    "script": "{\n  if ($job.inputs.mem){\n    return $job.inputs.mem\n  }\n  else return 2000\n}",
                    "engine": "#cwl-js-engine"
                  }
                }
              ],
              "sbg:createdOn": 1524401818
            },
            "sbg:y": 259.015625,
            "id": "#SBG_FASTQ_Merge_new"
          }
        ],
        "class": "Workflow",
        "sbg:canvas_zoom": 1,
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1524401865,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1524402226,
            "sbg:revision": 1,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1527685692,
            "sbg:revision": 2,
            "sbg:revisionNotes": "SBG Flatten and SBG FASTQ Merge new: print removed",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "outputs": [
          {
            "label": "merged",
            "sbg:includeInPorts": true,
            "source": [
              "#SBG_FASTQ_Merge_new.merged"
            ],
            "required": false,
            "sbg:fileTypes": "FASTQ",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:y": 259,
            "id": "#merged",
            "sbg:x": 1247
          }
        ],
        "label": "Trim Galore Skip New",
        "sbg:revisionNotes": "SBG Flatten and SBG FASTQ Merge new: print removed",
        "y": 260.01841345182004,
        "inputs": [
          {
            "label": "3' clip read 1",
            "sbg:toolDefaultValue": "0",
            "required": false,
            "description": "Instructs Trim Galore to remove <int> bp from the 3' end of read 1 (or single-end reads) AFTER adapter/quality trimming has been performed. This may remove some unwanted bias from the 3' end that is not directly related to adapter sequence or basecall quality. Default: OFF.",
            "type": [
              "null",
              "int"
            ],
            "id": "#three_clip_r1"
          },
          {
            "label": "Suppress warnings",
            "sbg:toolDefaultValue": "False",
            "required": false,
            "description": "If specified any output to STDOUT or STDERR will be suppressed.",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#suppress_warn",
            "sbg:stageInput": null
          },
          {
            "label": "Split by",
            "required": true,
            "sbg:suggestedValue": {
              "files": 30
            },
            "description": "Define splitting by number of files or by number of reads per file.",
            "type": [
              {
                "fields": [
                  {
                    "description": "Number of parts to split the FASTQ into.",
                    "label": "Files",
                    "type": [
                      "null",
                      "int"
                    ],
                    "name": "files"
                  },
                  {
                    "description": "Number of reads per resulting FASTQ part.",
                    "label": "Reads",
                    "type": [
                      "null",
                      "int"
                    ],
                    "name": "reads"
                  }
                ],
                "type": "record",
                "name": "split_by"
              }
            ],
            "id": "#split_by"
          },
          {
            "label": "skip_trimming",
            "sbg:includeInPorts": false,
            "sbg:x": 123,
            "type": [
              "null",
              "boolean"
            ],
            "sbg:y": 77,
            "id": "#skip_trimming",
            "required": false
          },
          {
            "label": "Paired",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end specific",
            "sbg:suggestedValue": true,
            "description": "This option performs length trimming of quality/adapter/RRBS trimmed reads for paired-end files. To pass the validation test, both sequences of a sequence pair are required to have a certain minimum length which is governed by the option --length (see above). If only one read passes this length threshold the other read can be rescued (see option --retain_unpaired). Using this option lets you discard too short read pairs without disturbing the sequence-by-sequence order of FastQ files which is required by many aligners. Trim Galore! expects paired-end files to be supplied in a pairwise fashion, e.g. file1_1.fq file1_2.fq SRR2_1.fq.gz SRR2_2.fq.gz ... .",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#paired",
            "required": false
          },
          {
            "label": "Compress output",
            "required": false,
            "description": "Compress merged fastq files on output",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#out_compress",
            "sbg:stageInput": null
          },
          {
            "label": "5' clip read 2",
            "sbg:toolDefaultValue": "0",
            "required": false,
            "description": "Instructs Trim Galore to remove <int> bp from the 5' end of read 2 (paired-end reads only). This may be useful if the qualities were very poor, or if there is some sort of unwanted bias at the 5' end. For paired-end BS-Seq, it is recommended to remove the first few bp because the end-repair reaction may introduce a bias towards low methylation. Please refer to the M-bias plot section in the Bismark User Guide for some examples. Default: OFF.",
            "type": [
              "null",
              "int"
            ],
            "id": "#five_clip_r2"
          },
          {
            "label": "5' clip read 1",
            "sbg:toolDefaultValue": "0",
            "required": false,
            "description": "Instructs Trim Galore to remove <int> bp from the 5' end of read 1 (or single-end reads). This may be useful if the qualities were very poor, or if there is some sort of unwanted bias at the 5' end. Default: OFF.",
            "type": [
              "null",
              "int"
            ],
            "id": "#five_clip_r1"
          },
          {
            "label": "fastq",
            "sbg:x": 131,
            "sbg:fileTypes": "FQ,FASTQ,FQ.GZ,FASTQ.GZ",
            "type": [
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:y": 335,
            "id": "#fastq",
            "required": true
          }
        ],
        "sbg:canvas_x": -58,
        "sbg:revision": 2,
        "sbg:modifiedBy": "jordanski.milos",
        "requirements": [],
        "sbg:image_url": "https://cgc.sbgenomics.com/ns/brood/images/milos_jordanski/spachete-salzman-collaboration/trim-galore-skip-new/2.png",
        "description": "",
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/trim-galore-skip-new/2",
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "sbg:createdOn": 1524401865,
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 2,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": []
      },
      "inputs": [
        {
          "id": "#Trim_Galore_Skip_New.three_clip_r1"
        },
        {
          "id": "#Trim_Galore_Skip_New.suppress_warn"
        },
        {
          "id": "#Trim_Galore_Skip_New.split_by",
          "default": {
            "files": 30
          }
        },
        {
          "id": "#Trim_Galore_Skip_New.skip_trimming",
          "source": [
            "#skip_trimming"
          ]
        },
        {
          "id": "#Trim_Galore_Skip_New.paired",
          "default": true
        },
        {
          "id": "#Trim_Galore_Skip_New.out_compress"
        },
        {
          "id": "#Trim_Galore_Skip_New.five_clip_r2"
        },
        {
          "id": "#Trim_Galore_Skip_New.five_clip_r1"
        },
        {
          "id": "#Trim_Galore_Skip_New.fastq",
          "source": [
            "#fastq_files"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#Trim_Galore_Skip_New.merged"
        }
      ],
      "sbg:x": 358.8235700270718,
      "sbg:y": 260.01841345182004
    },
    {
      "id": "#MACHETE_AppendNaiveReptParallel_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python AppendNaiveRept.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/appendnaivereptparallel/22",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    \n    if($job.inputs.naive_report.metadata && $job.inputs.naive_report.metadata.sample_id)\n    \tcmd = \"-s \" + $job.inputs.naive_report.metadata.sample_id\n\treturn cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 5355.768849360133,
        "id": "milos_jordanski/spachete-salzman-collaboration/appendnaivereptparallel/22",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532045295,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "AppendNaiveRept.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Nov 18 14:13:58 2015\n\n@author: Gillian\n\"\"\"\n\n\n# this function takes a [a,b,c,x,d,e,f] and sums a-f vs x\n\ndef addindels(bracketedstring):\n    IndelArray = bracketedstring.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\")\n    midpoint = len(IndelArray) / 2\n    NumJuncAlignments = int(IndelArray[midpoint])\n    NumIndels = 0\n    for entry in IndelArray:\n        NumIndels += int(entry)\n    NumIndels = NumIndels - NumJuncAlignments\n    return NumJuncAlignments, NumIndels\n\n\n## START PROGRAM\n\n\nimport glob\nimport os\nimport argparse\nimport pickle\n\nparser = argparse.ArgumentParser()\n# parser.add_argument(\"-f\", \"--FarJuncDir\", required=True, help=\"Far Junction Directory\")\n# parser.add_argument(\"-g\", \"--glmReportsDir\", required=True, help=\"linear junc glmReports Directory\")\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"file name\")\n# parser.add_argument(\"-G\", \"--FJGLM\", required=True, help=\"directory with FJ pipeline GLM outputs\")\n# parser.add_argument(\"-o\", \"--outputdir\", help=\"optional- if this exists then will default output dir of FJ/reports/AppendedReports/ with new output dir\")\n\nparser.add_argument(\"-badfj\", \"--BadFJ\", required=True, nargs='+',\n                    help=\"fusion junctions aligned to genome, transcriptome, regular, scrambled junctions\")\nparser.add_argument(\"-badfjpe\", \"--BadFJPE\", required=True, nargs='+',\n                    help=\"paired end fusion junctions aligned to genome, transcriptome, regular, scrambled junctions\")\nparser.add_argument(\"-mglm\", \"--MacheteGLM\", required=True, nargs='+',\n                    help=\"FUSION_W_ANOM_AND_INDEL output file from Machete GLM model\")\nparser.add_argument(\"-nr\", \"--naiveReport\", required=True, nargs='+', help=\"Output of FarJuncNaiveReport\")\nparser.add_argument(\"-if\", \"--indelFiles\", required=True, nargs='+', help=\"output of MakeIndelsHisto\")\nparser.add_argument(\"-fj\", \"--far_junctions\", required=True, help=\"far_junctions\")\nparser.add_argument(\"-kglm\", \"--KnifeGLM\", help=\"output of KNIFE GLM\")\nparser.add_argument('-suf', '--suffix', help='suffix')\nparser.add_argument('-5p', '--five_prime', help = 'file prime sam')\nparser.add_argument('-3p', '--three_prime', help = 'three prime sam')\nparser.add_argument('-dj', '--duplicate_junction', help='duplicate junctions')\n\nargs = parser.parse_args()\n\n# if args.FarJuncDir[-1] != \"/\":\n#    args.FarJuncDir += \"/\"\n\n# if args.glmReportsDir[-1] != \"/\":\n#    args.glmReportsDir += \"/\"\n\n# if args.FJGLM[-1] != \"/\":\n#    args.FJGLM += \"/\"\n\n# indelsDir = args.FarJuncDir + \"IndelsHistogram/\"\n# reportsDir = args.FarJuncDir + \"reports/\"\n# if args.outputdir:\n#    if args.outputdir[-1] != \"/\":\n#        args.outputdir += \"/\"\n#    outputDir = args.outputdir\n# else:\n#    outputDir = args.FarJuncDir + \"reports/AppendedReports/\"\n# print \"output to \" + outputDir\n# BadFJDir = args.FarJuncDir + \"BadFJ/\" + args.stem + \"/\"\n# BadFJV2Dir = args.FarJuncDir + \"BadFJ_ver2/\" + args.stem + \"/\"\n\nduplicate_junctions = pickle.load(open(args.duplicate_junction, \"rb\"))\nreverse_duplicate_junctions = {}\nfor key, value in duplicate_junctions.iteritems():\n    if value not in reverse_duplicate_junctions:\n        reverse_duplicate_junctions[value] = [key]\n    else:\n        reverse_duplicate_junctions[value].append(key)\n\n\nNoGLM = False\n\n# parses through bad FJ alignments.  for every FJ that aligned to genome/transcriptome/reg/junc\n# the FJ is stored in the Bad FJ dictionary, for tagging in the report file.\nBadFJDictionary = {}\n\nfor BadFJfile in args.BadFJ:\n\n    f1 = open(BadFJfile, mode=\"rU\")\n    print BadFJfile\n    for line_raw in f1:\n        if line_raw[0] == \"@\":\n            continue\n\n        badjunction = line_raw.strip().split(\"\\t\")[0]\n\n        if BadFJfile.endswith(\"regular_FJ_Known_MACHETE.sam\") or BadFJfile.endswith(\n                \"scrambled_FJ_Known_MACHETE.sam\") or BadFJfile.endswith(\"regular_FJ_MACHETE.sam\") or BadFJfile.endswith(\n                \"scrambled_FJ_MACHETE.sam\"):\n            alignment_score = float(line_raw.strip().split(\"\\t\")[11].split(\":\")[-1])\n            if line_raw.split(\"\\t\")[12][0:3] == \"XS:\":\n                num_N_reference = float(line_raw.split(\"\\t\")[13].split(\":\")[-1])\n            else:\n                num_N_reference = float(line_raw.split(\"\\t\")[12].split(\":\")[-1])\n            num_N_junction = line_raw.split(\"\\t\")[9].count(\"N\")\n\n            num_of_mismatches = int(line_raw.split(\"XM:i:\")[1].split(\"\\t\")[0])\n\n            if alignment_score > -0.24 * (300 - (num_of_mismatches + alignment_score / 6)) or (alignment_score / 6 + num_of_mismatches) < 50:\n                BadFJDictionary[badjunction] = 1\n\n        else:\n            BadFJDictionary[badjunction] = 1\n\n    f1.close()\n\n## parses thru version 2 bad FJ alignments. For every FJ whose midportion aligned to genome/transcrip\n## tome / reg/ junc, the FJ is stored in badFJv2 dictionary.\nBadFJ_V2_dict = {}\n\nfor BadFJV2file in args.BadFJPE:\n    f1 = open(BadFJV2file, mode=\"rU\")\n    print BadFJV2file\n    for line_raw in f1:\n        if line_raw[0] == \"@\":\n            continue\n        badjunction = line_raw.strip().split(\"\\t\")[0]\n        BadFJ_V2_dict[badjunction] = 1\n    f1.close()\n\n## Parse thru FJ GLM and load results into a dictionary for appending onto the naive report\nFJ_GLM_Dict = {}\n\n# FJ_GLM_files = glob.glob(args.FJGLM + args.stem + \"*FUSION_W_ANOM_AND_INDEL*\")\n# print glob.glob(args.FJGLM + args.stem + \"*FUSION_W_ANOM_AND_INDEL*\")\n\n# if glob.glob(args.FJGLM + args.stem + \"*FUSION_W_ANOM_AND_INDEL*\") == []:\n#    print \"no indels, using Fusion with Anom GLM reads\"\n#    FJ_GLM_files = glob.glob(args.FJGLM + args.stem + \"*FUSION_W_ANOM*\")\n\njunction_cdf_y = []\njunction_cdf_y_2 = []\njunction_to_cdf_y = {}\n\nfor FJ_GLM_file in args.MacheteGLM:\n\n    GLMfile = open(FJ_GLM_file, mode=\"rU\")\n\n    for line_raw in GLMfile:\n        if line_raw[0:4] == \"junc\":\n            FJ_GLM_Dict[\"header\"] = line_raw.strip()[9:]\n            continue\n\n        junc = line_raw.strip().split(\"\\t\")[0]\n\n        if junc in BadFJDictionary:\n            junction_cdf_y.append(float(line_raw.strip().split(\"\\t\")[13]))\n\n        if junc in BadFJDictionary and line_raw.strip().split(\"\\t\")[1] != \"NA\" and int(line_raw.strip().split(\"\\t\")[1]) > 1:\n            junction_cdf_y_2.append(float(line_raw.strip().split(\"\\t\")[13]))\n\n        junction_to_cdf_y[junc] = float(line_raw.strip().split(\"\\t\")[13])\n        value = line_raw.strip()[len(junc) + 1:]\n\n        FJ_GLM_Dict[junc] = value\n\n    GLMfile.close()\n\njunctions_to_seq = {}\n\nwith open(args.far_junctions, \"r\") as f:\n    while True:\n        line1 = f.readline()\n        if not line1:\n            break\n        line2 = f.readline()\n        if not line2:\n            break\n\n        junctions_to_seq[line1.strip()[1:]] = line2.strip()\n\n## parses through the report file and adds # indels.\n\nprint len(set(junctions_to_seq.keys()).intersection(set(FJ_GLM_Dict.keys())))\n\nfive_prime  = {}\nthree_prime = {}\n\nwith open(args.five_prime, \"r\") as f:\n    while True:\n        line = f.readline()\n        if not line:\n            break\n        five_prime[line.split(\"\\t\")[0]] = line.split(\"\\t\")[4]\n\nwith open(args.three_prime, \"r\") as f:\n    while True:\n        line = f.readline()\n        if not line:\n            break\n        three_prime[line.split(\"\\t\")[0]] = line.split(\"\\t\")[4]\n\nfor reportfile in args.naiveReport:\n\n    f1 = open(reportfile, mode=\"rU\")\n\n    indelfiles = sorted(args.indelFiles)\n    f2 = open(indelfiles[0], mode=\"rU\")\n    f3 = open(indelfiles[1], mode=\"rU\")\n\n    print indelfiles[0]\n    print indelfiles[1]\n\n    # f2 = open(indelfiles[0], mode=\"rU\")  # the indels  histo _1 file\n    # f3 = open(indelfiles[1], mode=\"rU\")  # the indels  histo _2 file\n\n    # glmReportfile = glob.glob(args.glmReportsDir + \"*\" + args.stem + \"*linear*.txt\")\n    if not args.KnifeGLM:\n        NoGLM = True\n    else:\n        f4 = open(args.KnifeGLM, mode=\"rU\")\n\n    # if glmReportfile == []:\n    #    NoGLM = True\n    # else:\n    #    f4 = open(glmReportfile[0], mode=\"rU\")\n\n    fout = open(args.sample + \"_naive_report_Appended\" + args.suffix + \".txt\", mode=\"w\")\n\n    # populate a junction dictionary so each key is the junction name\n    # each value is a string, where entry 0 is the _1 file indels\n    # and entry 1 is the _2 file indels\n\n    JunctionIndelsDict = {}\n\n    for line_raw in f2:\n        line = line_raw.strip().split(\"\\t\")\n        if line[0] not in JunctionIndelsDict:\n            JunctionIndelsDict[line[0]] = [\"0\", \"0\"]\n        numNoIndels, numIndels = addindels(line[1])\n        JunctionIndelsDict[line[0]][0] = str(numNoIndels) + \":\" + str(numIndels)\n\n    f2.close()\n\n    for line_raw in f3:\n        line = line_raw.strip().split(\"\\t\")\n        if line[0] not in JunctionIndelsDict:\n            JunctionIndelsDict[line[0]] = [\"0\", \"0\"]\n        numNoIndels, numIndels = addindels(line[1])\n        JunctionIndelsDict[line[0]][1] = str(numNoIndels) + \":\" + str(numIndels)\n\n    f3.close()\n\n    ## parse through reports and get all exons that participated.\n    exonDict = {}\n\n    for line_raw in f1:\n        if line_raw[0] == \"@\":\n            continue\n\n        junc = line_raw.strip().split(\"\\t\")[0]\n\n        exonL = line_raw.strip().split(\"\\t\")[0].split(\":\")[1]\n        exonR = line_raw.strip().split(\"\\t\")[0].split(\":\")[4]\n\n        if exonL not in exonDict:\n            exonDict[exonL] = 0\n        if exonR not in exonDict:\n            exonDict[exonR] = 0\n    f1.close()\n\n    total_badfj1s = len(junction_cdf_y)\n    total_badfj1s_numR = len(junction_cdf_y_2)\n    # print junction_cdf_y[0]\n\n    if NoGLM == False:\n        ## open GLMreports file and see what is the max # of times exon appeared.\n        for line_raw in f4:\n            if line_raw.strip().split(\"\\t\")[0] == \"junction\":\n                continue\n                # if posterior prob >0.8 then if L or R exon count is the greatest in exonDict,\n                ## then replace exonDict entry with new count\n\n            if float(line_raw.strip().split(\"\\t\")[3]) >= 0.8:\n                exonL = line_raw.strip().split(\"\\t\")[0].replace(\"|\", \":\").split(\":\")[1]\n                exonR = line_raw.strip().split(\"\\t\")[0].replace(\"|\", \":\").split(\":\")[3]\n\n                if exonL in exonDict:\n                    if int(line_raw.strip().split(\"\\t\")[1]) > exonDict[exonL]:\n                        exonDict[exonL] = int(line_raw.strip().split(\"\\t\")[1])\n\n                if exonR in exonDict:\n                    if int(line_raw.strip().split(\"\\t\")[1]) > exonDict[exonR]:\n                        exonDict[exonR] = int(line_raw.strip().split(\"\\t\")[1])\n\n        f4.close()\n\n    ## OUTPUTTING- includes report file, no indel: indel ratio, quality of FJ (bad = 1, good = 0)\n    ## and max # times that an exon appeared with good quality in GLM reports file.\n\n    # print sorted(junction_cdf_y)\n    f1 = open(reportfile, mode=\"rU\")\n    for line_raw in f1:\n        if line_raw[0] == \"@\":\n            fout.write(line_raw.strip() + \"\\t_1NoIndels:Indels\\t_2NoIndels:Indels\\tBadFJ=1\\tBadFJv2=1\\tExonL\\tExonR\\t\" +\n                       FJ_GLM_Dict[\"header\"] + \"\\temp.p\\temp.p.2\\tseq\\tfive_prime_qual\\tthree_prime_qual\" + \"\\n\")\n            continue\n\n        junc = line_raw.strip().split(\"\\t\")[0]\n\n        junc_key = \">\" + junc + \"\\n\"\n        tmp_duplicate_junctions = []\n        if junc_key in reverse_duplicate_junctions:\n            for duplicate in reverse_duplicate_junctions[junc_key]:\n                tmp_duplicate_junctions.append(duplicate[1:-1])\n\n        if junc == \"6:DEK:18237381:-|6:DEK:18236600:-|reg\":\n            print tmp_duplicate_junctions\n\n        num_greater = 0\n        num_greater_2 = 0\n        if junc in junction_to_cdf_y:\n            jct_cdf = junction_to_cdf_y[junc]\n            for jcy in junction_cdf_y:\n                if jcy > jct_cdf:\n                    num_greater += 1\n            emp_ps = float(num_greater) / total_badfj1s\n\n            for jcy in junction_cdf_y_2:\n                if jcy > jct_cdf:\n                    num_greater_2 += 1\n            emp_ps_2 = float(num_greater_2) / total_badfj1s_numR\n\n        else:\n            emp_ps = \"-\"\n            emp_ps_2 = \"-\"\n\n        if junc in BadFJDictionary:\n            BadFJ = \"1\"\n        else:\n            BadFJ = \"0\"\n\n        if junc in BadFJ_V2_dict:\n            BadFJv2 = \"1\"\n        else:\n            BadFJv2 = \"0\"\n\n        # try:\n        exonL = str(exonDict[line_raw.strip().split(\"\\t\")[0].split(\":\")[1]])\n        #        except:\n        #           print line_raw\n        # print line_raw.strip().split(\"\\t\")[0].split(\":\")[1]\n        # print exonDict[line_raw.strip().split(\"\\t\")[0].split(\":\")[1]]\n\n\n        exonR = str(exonDict[line_raw.strip().split(\"\\t\")[0].split(\":\")[4]])\n        if NoGLM == True:\n            exonL = \"No glmReport\"\n            exonR = \"No glmReport\"\n\n        if junc in junctions_to_seq:\n            sequence = junctions_to_seq[junc]\n        else:\n            sequence = \"-\"\n\n        five_prime_qual = \"-\"\n        if junc in five_prime:\n            five_prime_qual = five_prime[junc]\n\n        three_prime_qual = \"-\"\n        if junc in three_prime:\n            three_prime_qual = three_prime[junc]\n\n        line_without_junc = \"\\t\".join(line_raw.strip().split(\"\\t\")[1:])\n\n        duplicate_junctions_str = line_without_junc\n        if junc in JunctionIndelsDict:\n            fout.write(junc + \"\\t\" + line_without_junc + \"\\t\" + JunctionIndelsDict[junc][0] + \"\\t\" + JunctionIndelsDict[junc][\n                1] + \"\\t\" + BadFJ + \"\\t\" + BadFJv2 + \"\\t\" + exonL + \"\\t\" + exonR + \"\\t\")\n            duplicate_junctions_str += \"\\t\" + JunctionIndelsDict[junc][0] + \"\\t\" + JunctionIndelsDict[junc][\n                1] + \"\\t\" + BadFJ + \"\\t\" + BadFJv2 + \"\\t\" + exonL + \"\\t\" + exonR + \"\\t\"\n        else:\n            fout.write(line_raw.strip() + \"\\t-\\t-\\t\" + BadFJ + \"\\t\" + BadFJv2 + \"\\t\" + exonL + \"\\t\" + exonR + \"\\t\")\n            duplicate_junctions_str += \"\\t-\\t-\\t\" + BadFJ + \"\\t\" + BadFJv2 + \"\\t\" + exonL + \"\\t\" + exonR + \"\\t\"\n\n        if junc in FJ_GLM_Dict:\n            fout.write(FJ_GLM_Dict[junc] + \"\\t\" + str(emp_ps) + \"\\t\" + str(emp_ps_2) + \"\\t\" + sequence + \"\\t\" + five_prime_qual + \"\\t\" + three_prime_qual + \"\\n\")\n            duplicate_junctions_str += FJ_GLM_Dict[junc] + \"\\t\" + str(emp_ps) + \"\\t\" + str(emp_ps_2) + \"\\t\" + sequence + \"\\t\" + five_prime_qual + \"\\t\" + three_prime_qual + \"\\n\"\n        else:\n            fout.write(\"-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t\" + sequence + \"\\t\" + five_prime_qual + \"\\t\" + three_prime_qual + \"\\n\")\n            duplicate_junctions_str += \"-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t\" + sequence + \"\\t\" + five_prime_qual + \"\\t\" + three_prime_qual + \"\\n\"\n\n        for junction in tmp_duplicate_junctions:\n            fout.write(junction + \"|DUPLICATE\\t\" + duplicate_junctions_str)\n\n    fout.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "naive_report": {
              "path": "/path/to/naive_report.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "sample_name"
              }
            },
            "badfjpe": [
              {
                "path": "/path/to/badfjpe-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/badfjpe-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "three_prime_sam": {
              "path": "/path/to/three_prime_sam.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "machete_glm": {
              "path": "/path/to/machete_glm.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "far_junctions": {
              "path": "/path/to/far_junctions.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "five_prime_sam": {
              "path": "/path/to/five_prime_sam.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "knife_glm": {
              "path": "/path/to/knife_glm.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "duplicate_junction": {
              "path": "/path/to/duplicate_junction.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "suffix": "suffix-string-value",
            "indel_files": [
              {
                "path": "/path/to/indel_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/indel_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "badfj": [
              {
                "path": "/path/to/badfj-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/badfj-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520601227,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": null,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedOn": 1520601247,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "revision 6 copied",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedOn": 1521482965,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "3prime and 5prime included",
            "sbg:revision": 2
          },
          {
            "sbg:modifiedOn": 1522995292,
            "sbg:modifiedBy": "roozbehdn",
            "sbg:revisionNotes": "change the column number of junction_cdf from [11] to [13]",
            "sbg:revision": 3
          },
          {
            "sbg:modifiedOn": 1527022862,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "duplicate_junction added",
            "sbg:revision": 4
          },
          {
            "sbg:modifiedOn": 1527161895,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "appended_report_fixed",
            "sbg:revision": 5
          },
          {
            "sbg:modifiedOn": 1527200130,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "duplicate_junctions input modified",
            "sbg:revision": 6
          },
          {
            "sbg:modifiedOn": 1527806648,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "[13] instead of [11]",
            "sbg:revision": 7
          },
          {
            "sbg:modifiedOn": 1527808310,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "duplicate_junctions_str UPDATED",
            "sbg:revision": 8
          },
          {
            "sbg:modifiedOn": 1528068671,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "filtering reg/scrambled FJ sam files",
            "sbg:revision": 9
          },
          {
            "sbg:modifiedOn": 1528070801,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "emp.p.2 added",
            "sbg:revision": 10
          },
          {
            "sbg:modifiedOn": 1528071089,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "num_greater_2 fixed",
            "sbg:revision": 11
          },
          {
            "sbg:modifiedOn": 1528900862,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "double \"\\t\" fixed",
            "sbg:revision": 12
          },
          {
            "sbg:modifiedOn": 1528902361,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "\"-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t\" fixed",
            "sbg:revision": 13
          },
          {
            "sbg:modifiedOn": 1528924746,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "one \"-\\t\" removed",
            "sbg:revision": 14
          },
          {
            "sbg:modifiedOn": 1530718622,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "emp.p.2 ~ BadFJ and numR>1",
            "sbg:revision": 15
          },
          {
            "sbg:modifiedOn": 1530720124,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "syntax fixed",
            "sbg:revision": 16
          },
          {
            "sbg:modifiedOn": 1530729640,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "line_raw.strip().split(\"\\t\")[1] != \"NA\"",
            "sbg:revision": 17
          },
          {
            "sbg:modifiedOn": 1531976181,
            "sbg:modifiedBy": "roozbehdn",
            "sbg:revisionNotes": "Roozbeh: change the alignment score threshold to -0.24*(300-(XM+AS/6))",
            "sbg:revision": 18
          },
          {
            "sbg:modifiedOn": 1532032289,
            "sbg:modifiedBy": "roozbehdn",
            "sbg:revisionNotes": "fix a bug in revision 18.",
            "sbg:revision": 19
          },
          {
            "sbg:modifiedOn": 1532037140,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "revision 17 + changed the way badfj are filtered",
            "sbg:revision": 20
          },
          {
            "sbg:modifiedOn": 1532043530,
            "sbg:modifiedBy": "roozbehdn",
            "sbg:revisionNotes": "alignemet_score -> alignment_score",
            "sbg:revision": 21
          },
          {
            "sbg:modifiedOn": 1532045295,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "alignement type fixed",
            "sbg:revision": 22
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#naive_report",
              "glob": "*_naive_report_Appended*"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#appended_naive_report"
          }
        ],
        "label": "MACHETE AppendNaiveReptParallel Known",
        "sbg:latestRevision": 22,
        "sbg:revisionNotes": "alignement type fixed",
        "y": 850.4021981280008,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-3p"
            },
            "id": "#three_prime_sam",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--suffix",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-suf"
            },
            "id": "#suffix",
            "type": [
              "null",
              "string"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-nr"
            },
            "id": "#naive_report",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-mglm"
            },
            "id": "#machete_glm",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-kglm"
            },
            "id": "#knife_glm",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-if",
              "itemSeparator": " "
            },
            "id": "#indel_files",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-5p"
            },
            "id": "#five_prime_sam",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fj"
            },
            "id": "#far_junctions",
            "type": [
              "null",
              "File"
            ],
            "sbg:stageInput": "link",
            "required": false
          },
          {
            "sbg:altPrefix": "--duplicate_junction",
            "required": false,
            "sbg:fileTypes": "PICKLE",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-dj"
            },
            "id": "#duplicate_junction",
            "type": [
              "null",
              "File"
            ],
            "sbg:stageInput": "link"
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-badfjpe",
              "itemSeparator": " "
            },
            "id": "#badfjpe",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-badfj",
              "itemSeparator": " "
            },
            "id": "#badfj",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos",
          "roozbehdn"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "AppendNaiveRept.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 22,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520601227
      },
      "inputs": [
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.three_prime_sam",
          "source": [
            "#MACHETE_Bowtie2_Aligner_3_prime_Known.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.suffix",
          "default": "_MACHETE_Parallel_Known"
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.naive_report",
          "source": [
            "#MACHETE_FarJuncNaiveReport_Known.naive_report"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.machete_glm",
          "source": [
            "#GLM_script_UseIndel_MACHETE_Known.fusion_w_anomaly_and_indel_juncp_out_lef_join"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.knife_glm",
          "source": [
            "#KNIFE_GLM_model.linear_junc_probs"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.indel_files",
          "source": [
            "#MACHETE_MakeIndelsHisto_Known.indels_txt"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.five_prime_sam",
          "source": [
            "#MACHETE_Bowtie2_Aligner_5_prime_Known.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.far_junctions",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate_Known.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.duplicate_junction",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate_Known.duplicate_filtered_far_junctions"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.badfjpe",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.badfj",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_AppendNaiveReptParallel_Known.appended_naive_report"
        }
      ],
      "sbg:x": 5355.768849360133,
      "sbg:y": 850.4021981280008
    },
    {
      "id": "#MACHETE_AppendNaiveReptParallel",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python AppendNaiveRept.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/appendnaivereptparallel/22",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    \n    if($job.inputs.naive_report.metadata && $job.inputs.naive_report.metadata.sample_id)\n    \tcmd = \"-s \" + $job.inputs.naive_report.metadata.sample_id\n\treturn cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 5744.790039062502,
        "id": "milos_jordanski/spachete-salzman-collaboration/appendnaivereptparallel/22",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532045295,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "AppendNaiveRept.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Nov 18 14:13:58 2015\n\n@author: Gillian\n\"\"\"\n\n\n# this function takes a [a,b,c,x,d,e,f] and sums a-f vs x\n\ndef addindels(bracketedstring):\n    IndelArray = bracketedstring.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\")\n    midpoint = len(IndelArray) / 2\n    NumJuncAlignments = int(IndelArray[midpoint])\n    NumIndels = 0\n    for entry in IndelArray:\n        NumIndels += int(entry)\n    NumIndels = NumIndels - NumJuncAlignments\n    return NumJuncAlignments, NumIndels\n\n\n## START PROGRAM\n\n\nimport glob\nimport os\nimport argparse\nimport pickle\n\nparser = argparse.ArgumentParser()\n# parser.add_argument(\"-f\", \"--FarJuncDir\", required=True, help=\"Far Junction Directory\")\n# parser.add_argument(\"-g\", \"--glmReportsDir\", required=True, help=\"linear junc glmReports Directory\")\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"file name\")\n# parser.add_argument(\"-G\", \"--FJGLM\", required=True, help=\"directory with FJ pipeline GLM outputs\")\n# parser.add_argument(\"-o\", \"--outputdir\", help=\"optional- if this exists then will default output dir of FJ/reports/AppendedReports/ with new output dir\")\n\nparser.add_argument(\"-badfj\", \"--BadFJ\", required=True, nargs='+',\n                    help=\"fusion junctions aligned to genome, transcriptome, regular, scrambled junctions\")\nparser.add_argument(\"-badfjpe\", \"--BadFJPE\", required=True, nargs='+',\n                    help=\"paired end fusion junctions aligned to genome, transcriptome, regular, scrambled junctions\")\nparser.add_argument(\"-mglm\", \"--MacheteGLM\", required=True, nargs='+',\n                    help=\"FUSION_W_ANOM_AND_INDEL output file from Machete GLM model\")\nparser.add_argument(\"-nr\", \"--naiveReport\", required=True, nargs='+', help=\"Output of FarJuncNaiveReport\")\nparser.add_argument(\"-if\", \"--indelFiles\", required=True, nargs='+', help=\"output of MakeIndelsHisto\")\nparser.add_argument(\"-fj\", \"--far_junctions\", required=True, help=\"far_junctions\")\nparser.add_argument(\"-kglm\", \"--KnifeGLM\", help=\"output of KNIFE GLM\")\nparser.add_argument('-suf', '--suffix', help='suffix')\nparser.add_argument('-5p', '--five_prime', help = 'file prime sam')\nparser.add_argument('-3p', '--three_prime', help = 'three prime sam')\nparser.add_argument('-dj', '--duplicate_junction', help='duplicate junctions')\n\nargs = parser.parse_args()\n\n# if args.FarJuncDir[-1] != \"/\":\n#    args.FarJuncDir += \"/\"\n\n# if args.glmReportsDir[-1] != \"/\":\n#    args.glmReportsDir += \"/\"\n\n# if args.FJGLM[-1] != \"/\":\n#    args.FJGLM += \"/\"\n\n# indelsDir = args.FarJuncDir + \"IndelsHistogram/\"\n# reportsDir = args.FarJuncDir + \"reports/\"\n# if args.outputdir:\n#    if args.outputdir[-1] != \"/\":\n#        args.outputdir += \"/\"\n#    outputDir = args.outputdir\n# else:\n#    outputDir = args.FarJuncDir + \"reports/AppendedReports/\"\n# print \"output to \" + outputDir\n# BadFJDir = args.FarJuncDir + \"BadFJ/\" + args.stem + \"/\"\n# BadFJV2Dir = args.FarJuncDir + \"BadFJ_ver2/\" + args.stem + \"/\"\n\nduplicate_junctions = pickle.load(open(args.duplicate_junction, \"rb\"))\nreverse_duplicate_junctions = {}\nfor key, value in duplicate_junctions.iteritems():\n    if value not in reverse_duplicate_junctions:\n        reverse_duplicate_junctions[value] = [key]\n    else:\n        reverse_duplicate_junctions[value].append(key)\n\n\nNoGLM = False\n\n# parses through bad FJ alignments.  for every FJ that aligned to genome/transcriptome/reg/junc\n# the FJ is stored in the Bad FJ dictionary, for tagging in the report file.\nBadFJDictionary = {}\n\nfor BadFJfile in args.BadFJ:\n\n    f1 = open(BadFJfile, mode=\"rU\")\n    print BadFJfile\n    for line_raw in f1:\n        if line_raw[0] == \"@\":\n            continue\n\n        badjunction = line_raw.strip().split(\"\\t\")[0]\n\n        if BadFJfile.endswith(\"regular_FJ_Known_MACHETE.sam\") or BadFJfile.endswith(\n                \"scrambled_FJ_Known_MACHETE.sam\") or BadFJfile.endswith(\"regular_FJ_MACHETE.sam\") or BadFJfile.endswith(\n                \"scrambled_FJ_MACHETE.sam\"):\n            alignment_score = float(line_raw.strip().split(\"\\t\")[11].split(\":\")[-1])\n            if line_raw.split(\"\\t\")[12][0:3] == \"XS:\":\n                num_N_reference = float(line_raw.split(\"\\t\")[13].split(\":\")[-1])\n            else:\n                num_N_reference = float(line_raw.split(\"\\t\")[12].split(\":\")[-1])\n            num_N_junction = line_raw.split(\"\\t\")[9].count(\"N\")\n\n            num_of_mismatches = int(line_raw.split(\"XM:i:\")[1].split(\"\\t\")[0])\n\n            if alignment_score > -0.24 * (300 - (num_of_mismatches + alignment_score / 6)) or (alignment_score / 6 + num_of_mismatches) < 50:\n                BadFJDictionary[badjunction] = 1\n\n        else:\n            BadFJDictionary[badjunction] = 1\n\n    f1.close()\n\n## parses thru version 2 bad FJ alignments. For every FJ whose midportion aligned to genome/transcrip\n## tome / reg/ junc, the FJ is stored in badFJv2 dictionary.\nBadFJ_V2_dict = {}\n\nfor BadFJV2file in args.BadFJPE:\n    f1 = open(BadFJV2file, mode=\"rU\")\n    print BadFJV2file\n    for line_raw in f1:\n        if line_raw[0] == \"@\":\n            continue\n        badjunction = line_raw.strip().split(\"\\t\")[0]\n        BadFJ_V2_dict[badjunction] = 1\n    f1.close()\n\n## Parse thru FJ GLM and load results into a dictionary for appending onto the naive report\nFJ_GLM_Dict = {}\n\n# FJ_GLM_files = glob.glob(args.FJGLM + args.stem + \"*FUSION_W_ANOM_AND_INDEL*\")\n# print glob.glob(args.FJGLM + args.stem + \"*FUSION_W_ANOM_AND_INDEL*\")\n\n# if glob.glob(args.FJGLM + args.stem + \"*FUSION_W_ANOM_AND_INDEL*\") == []:\n#    print \"no indels, using Fusion with Anom GLM reads\"\n#    FJ_GLM_files = glob.glob(args.FJGLM + args.stem + \"*FUSION_W_ANOM*\")\n\njunction_cdf_y = []\njunction_cdf_y_2 = []\njunction_to_cdf_y = {}\n\nfor FJ_GLM_file in args.MacheteGLM:\n\n    GLMfile = open(FJ_GLM_file, mode=\"rU\")\n\n    for line_raw in GLMfile:\n        if line_raw[0:4] == \"junc\":\n            FJ_GLM_Dict[\"header\"] = line_raw.strip()[9:]\n            continue\n\n        junc = line_raw.strip().split(\"\\t\")[0]\n\n        if junc in BadFJDictionary:\n            junction_cdf_y.append(float(line_raw.strip().split(\"\\t\")[13]))\n\n        if junc in BadFJDictionary and line_raw.strip().split(\"\\t\")[1] != \"NA\" and int(line_raw.strip().split(\"\\t\")[1]) > 1:\n            junction_cdf_y_2.append(float(line_raw.strip().split(\"\\t\")[13]))\n\n        junction_to_cdf_y[junc] = float(line_raw.strip().split(\"\\t\")[13])\n        value = line_raw.strip()[len(junc) + 1:]\n\n        FJ_GLM_Dict[junc] = value\n\n    GLMfile.close()\n\njunctions_to_seq = {}\n\nwith open(args.far_junctions, \"r\") as f:\n    while True:\n        line1 = f.readline()\n        if not line1:\n            break\n        line2 = f.readline()\n        if not line2:\n            break\n\n        junctions_to_seq[line1.strip()[1:]] = line2.strip()\n\n## parses through the report file and adds # indels.\n\nprint len(set(junctions_to_seq.keys()).intersection(set(FJ_GLM_Dict.keys())))\n\nfive_prime  = {}\nthree_prime = {}\n\nwith open(args.five_prime, \"r\") as f:\n    while True:\n        line = f.readline()\n        if not line:\n            break\n        five_prime[line.split(\"\\t\")[0]] = line.split(\"\\t\")[4]\n\nwith open(args.three_prime, \"r\") as f:\n    while True:\n        line = f.readline()\n        if not line:\n            break\n        three_prime[line.split(\"\\t\")[0]] = line.split(\"\\t\")[4]\n\nfor reportfile in args.naiveReport:\n\n    f1 = open(reportfile, mode=\"rU\")\n\n    indelfiles = sorted(args.indelFiles)\n    f2 = open(indelfiles[0], mode=\"rU\")\n    f3 = open(indelfiles[1], mode=\"rU\")\n\n    print indelfiles[0]\n    print indelfiles[1]\n\n    # f2 = open(indelfiles[0], mode=\"rU\")  # the indels  histo _1 file\n    # f3 = open(indelfiles[1], mode=\"rU\")  # the indels  histo _2 file\n\n    # glmReportfile = glob.glob(args.glmReportsDir + \"*\" + args.stem + \"*linear*.txt\")\n    if not args.KnifeGLM:\n        NoGLM = True\n    else:\n        f4 = open(args.KnifeGLM, mode=\"rU\")\n\n    # if glmReportfile == []:\n    #    NoGLM = True\n    # else:\n    #    f4 = open(glmReportfile[0], mode=\"rU\")\n\n    fout = open(args.sample + \"_naive_report_Appended\" + args.suffix + \".txt\", mode=\"w\")\n\n    # populate a junction dictionary so each key is the junction name\n    # each value is a string, where entry 0 is the _1 file indels\n    # and entry 1 is the _2 file indels\n\n    JunctionIndelsDict = {}\n\n    for line_raw in f2:\n        line = line_raw.strip().split(\"\\t\")\n        if line[0] not in JunctionIndelsDict:\n            JunctionIndelsDict[line[0]] = [\"0\", \"0\"]\n        numNoIndels, numIndels = addindels(line[1])\n        JunctionIndelsDict[line[0]][0] = str(numNoIndels) + \":\" + str(numIndels)\n\n    f2.close()\n\n    for line_raw in f3:\n        line = line_raw.strip().split(\"\\t\")\n        if line[0] not in JunctionIndelsDict:\n            JunctionIndelsDict[line[0]] = [\"0\", \"0\"]\n        numNoIndels, numIndels = addindels(line[1])\n        JunctionIndelsDict[line[0]][1] = str(numNoIndels) + \":\" + str(numIndels)\n\n    f3.close()\n\n    ## parse through reports and get all exons that participated.\n    exonDict = {}\n\n    for line_raw in f1:\n        if line_raw[0] == \"@\":\n            continue\n\n        junc = line_raw.strip().split(\"\\t\")[0]\n\n        exonL = line_raw.strip().split(\"\\t\")[0].split(\":\")[1]\n        exonR = line_raw.strip().split(\"\\t\")[0].split(\":\")[4]\n\n        if exonL not in exonDict:\n            exonDict[exonL] = 0\n        if exonR not in exonDict:\n            exonDict[exonR] = 0\n    f1.close()\n\n    total_badfj1s = len(junction_cdf_y)\n    total_badfj1s_numR = len(junction_cdf_y_2)\n    # print junction_cdf_y[0]\n\n    if NoGLM == False:\n        ## open GLMreports file and see what is the max # of times exon appeared.\n        for line_raw in f4:\n            if line_raw.strip().split(\"\\t\")[0] == \"junction\":\n                continue\n                # if posterior prob >0.8 then if L or R exon count is the greatest in exonDict,\n                ## then replace exonDict entry with new count\n\n            if float(line_raw.strip().split(\"\\t\")[3]) >= 0.8:\n                exonL = line_raw.strip().split(\"\\t\")[0].replace(\"|\", \":\").split(\":\")[1]\n                exonR = line_raw.strip().split(\"\\t\")[0].replace(\"|\", \":\").split(\":\")[3]\n\n                if exonL in exonDict:\n                    if int(line_raw.strip().split(\"\\t\")[1]) > exonDict[exonL]:\n                        exonDict[exonL] = int(line_raw.strip().split(\"\\t\")[1])\n\n                if exonR in exonDict:\n                    if int(line_raw.strip().split(\"\\t\")[1]) > exonDict[exonR]:\n                        exonDict[exonR] = int(line_raw.strip().split(\"\\t\")[1])\n\n        f4.close()\n\n    ## OUTPUTTING- includes report file, no indel: indel ratio, quality of FJ (bad = 1, good = 0)\n    ## and max # times that an exon appeared with good quality in GLM reports file.\n\n    # print sorted(junction_cdf_y)\n    f1 = open(reportfile, mode=\"rU\")\n    for line_raw in f1:\n        if line_raw[0] == \"@\":\n            fout.write(line_raw.strip() + \"\\t_1NoIndels:Indels\\t_2NoIndels:Indels\\tBadFJ=1\\tBadFJv2=1\\tExonL\\tExonR\\t\" +\n                       FJ_GLM_Dict[\"header\"] + \"\\temp.p\\temp.p.2\\tseq\\tfive_prime_qual\\tthree_prime_qual\" + \"\\n\")\n            continue\n\n        junc = line_raw.strip().split(\"\\t\")[0]\n\n        junc_key = \">\" + junc + \"\\n\"\n        tmp_duplicate_junctions = []\n        if junc_key in reverse_duplicate_junctions:\n            for duplicate in reverse_duplicate_junctions[junc_key]:\n                tmp_duplicate_junctions.append(duplicate[1:-1])\n\n        if junc == \"6:DEK:18237381:-|6:DEK:18236600:-|reg\":\n            print tmp_duplicate_junctions\n\n        num_greater = 0\n        num_greater_2 = 0\n        if junc in junction_to_cdf_y:\n            jct_cdf = junction_to_cdf_y[junc]\n            for jcy in junction_cdf_y:\n                if jcy > jct_cdf:\n                    num_greater += 1\n            emp_ps = float(num_greater) / total_badfj1s\n\n            for jcy in junction_cdf_y_2:\n                if jcy > jct_cdf:\n                    num_greater_2 += 1\n            emp_ps_2 = float(num_greater_2) / total_badfj1s_numR\n\n        else:\n            emp_ps = \"-\"\n            emp_ps_2 = \"-\"\n\n        if junc in BadFJDictionary:\n            BadFJ = \"1\"\n        else:\n            BadFJ = \"0\"\n\n        if junc in BadFJ_V2_dict:\n            BadFJv2 = \"1\"\n        else:\n            BadFJv2 = \"0\"\n\n        # try:\n        exonL = str(exonDict[line_raw.strip().split(\"\\t\")[0].split(\":\")[1]])\n        #        except:\n        #           print line_raw\n        # print line_raw.strip().split(\"\\t\")[0].split(\":\")[1]\n        # print exonDict[line_raw.strip().split(\"\\t\")[0].split(\":\")[1]]\n\n\n        exonR = str(exonDict[line_raw.strip().split(\"\\t\")[0].split(\":\")[4]])\n        if NoGLM == True:\n            exonL = \"No glmReport\"\n            exonR = \"No glmReport\"\n\n        if junc in junctions_to_seq:\n            sequence = junctions_to_seq[junc]\n        else:\n            sequence = \"-\"\n\n        five_prime_qual = \"-\"\n        if junc in five_prime:\n            five_prime_qual = five_prime[junc]\n\n        three_prime_qual = \"-\"\n        if junc in three_prime:\n            three_prime_qual = three_prime[junc]\n\n        line_without_junc = \"\\t\".join(line_raw.strip().split(\"\\t\")[1:])\n\n        duplicate_junctions_str = line_without_junc\n        if junc in JunctionIndelsDict:\n            fout.write(junc + \"\\t\" + line_without_junc + \"\\t\" + JunctionIndelsDict[junc][0] + \"\\t\" + JunctionIndelsDict[junc][\n                1] + \"\\t\" + BadFJ + \"\\t\" + BadFJv2 + \"\\t\" + exonL + \"\\t\" + exonR + \"\\t\")\n            duplicate_junctions_str += \"\\t\" + JunctionIndelsDict[junc][0] + \"\\t\" + JunctionIndelsDict[junc][\n                1] + \"\\t\" + BadFJ + \"\\t\" + BadFJv2 + \"\\t\" + exonL + \"\\t\" + exonR + \"\\t\"\n        else:\n            fout.write(line_raw.strip() + \"\\t-\\t-\\t\" + BadFJ + \"\\t\" + BadFJv2 + \"\\t\" + exonL + \"\\t\" + exonR + \"\\t\")\n            duplicate_junctions_str += \"\\t-\\t-\\t\" + BadFJ + \"\\t\" + BadFJv2 + \"\\t\" + exonL + \"\\t\" + exonR + \"\\t\"\n\n        if junc in FJ_GLM_Dict:\n            fout.write(FJ_GLM_Dict[junc] + \"\\t\" + str(emp_ps) + \"\\t\" + str(emp_ps_2) + \"\\t\" + sequence + \"\\t\" + five_prime_qual + \"\\t\" + three_prime_qual + \"\\n\")\n            duplicate_junctions_str += FJ_GLM_Dict[junc] + \"\\t\" + str(emp_ps) + \"\\t\" + str(emp_ps_2) + \"\\t\" + sequence + \"\\t\" + five_prime_qual + \"\\t\" + three_prime_qual + \"\\n\"\n        else:\n            fout.write(\"-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t\" + sequence + \"\\t\" + five_prime_qual + \"\\t\" + three_prime_qual + \"\\n\")\n            duplicate_junctions_str += \"-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t\" + sequence + \"\\t\" + five_prime_qual + \"\\t\" + three_prime_qual + \"\\n\"\n\n        for junction in tmp_duplicate_junctions:\n            fout.write(junction + \"|DUPLICATE\\t\" + duplicate_junctions_str)\n\n    fout.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "naive_report": {
              "path": "/path/to/naive_report.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "sample_name"
              }
            },
            "badfjpe": [
              {
                "path": "/path/to/badfjpe-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/badfjpe-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "three_prime_sam": {
              "path": "/path/to/three_prime_sam.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "machete_glm": {
              "path": "/path/to/machete_glm.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "far_junctions": {
              "path": "/path/to/far_junctions.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "five_prime_sam": {
              "path": "/path/to/five_prime_sam.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "knife_glm": {
              "path": "/path/to/knife_glm.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "duplicate_junction": {
              "path": "/path/to/duplicate_junction.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "suffix": "suffix-string-value",
            "indel_files": [
              {
                "path": "/path/to/indel_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/indel_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "badfj": [
              {
                "path": "/path/to/badfj-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/badfj-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520601227,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": null,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedOn": 1520601247,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "revision 6 copied",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedOn": 1521482965,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "3prime and 5prime included",
            "sbg:revision": 2
          },
          {
            "sbg:modifiedOn": 1522995292,
            "sbg:modifiedBy": "roozbehdn",
            "sbg:revisionNotes": "change the column number of junction_cdf from [11] to [13]",
            "sbg:revision": 3
          },
          {
            "sbg:modifiedOn": 1527022862,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "duplicate_junction added",
            "sbg:revision": 4
          },
          {
            "sbg:modifiedOn": 1527161895,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "appended_report_fixed",
            "sbg:revision": 5
          },
          {
            "sbg:modifiedOn": 1527200130,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "duplicate_junctions input modified",
            "sbg:revision": 6
          },
          {
            "sbg:modifiedOn": 1527806648,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "[13] instead of [11]",
            "sbg:revision": 7
          },
          {
            "sbg:modifiedOn": 1527808310,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "duplicate_junctions_str UPDATED",
            "sbg:revision": 8
          },
          {
            "sbg:modifiedOn": 1528068671,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "filtering reg/scrambled FJ sam files",
            "sbg:revision": 9
          },
          {
            "sbg:modifiedOn": 1528070801,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "emp.p.2 added",
            "sbg:revision": 10
          },
          {
            "sbg:modifiedOn": 1528071089,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "num_greater_2 fixed",
            "sbg:revision": 11
          },
          {
            "sbg:modifiedOn": 1528900862,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "double \"\\t\" fixed",
            "sbg:revision": 12
          },
          {
            "sbg:modifiedOn": 1528902361,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "\"-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t-\\t\" fixed",
            "sbg:revision": 13
          },
          {
            "sbg:modifiedOn": 1528924746,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "one \"-\\t\" removed",
            "sbg:revision": 14
          },
          {
            "sbg:modifiedOn": 1530718622,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "emp.p.2 ~ BadFJ and numR>1",
            "sbg:revision": 15
          },
          {
            "sbg:modifiedOn": 1530720124,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "syntax fixed",
            "sbg:revision": 16
          },
          {
            "sbg:modifiedOn": 1530729640,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "line_raw.strip().split(\"\\t\")[1] != \"NA\"",
            "sbg:revision": 17
          },
          {
            "sbg:modifiedOn": 1531976181,
            "sbg:modifiedBy": "roozbehdn",
            "sbg:revisionNotes": "Roozbeh: change the alignment score threshold to -0.24*(300-(XM+AS/6))",
            "sbg:revision": 18
          },
          {
            "sbg:modifiedOn": 1532032289,
            "sbg:modifiedBy": "roozbehdn",
            "sbg:revisionNotes": "fix a bug in revision 18.",
            "sbg:revision": 19
          },
          {
            "sbg:modifiedOn": 1532037140,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "revision 17 + changed the way badfj are filtered",
            "sbg:revision": 20
          },
          {
            "sbg:modifiedOn": 1532043530,
            "sbg:modifiedBy": "roozbehdn",
            "sbg:revisionNotes": "alignemet_score -> alignment_score",
            "sbg:revision": 21
          },
          {
            "sbg:modifiedOn": 1532045295,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "alignement type fixed",
            "sbg:revision": 22
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#naive_report",
              "glob": "*_naive_report_Appended*"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#appended_naive_report"
          }
        ],
        "label": "MACHETE AppendNaiveReptParallel",
        "sbg:latestRevision": 22,
        "sbg:revisionNotes": "alignement type fixed",
        "y": 356.4895019531251,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-3p"
            },
            "id": "#three_prime_sam",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--suffix",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-suf"
            },
            "id": "#suffix",
            "type": [
              "null",
              "string"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-nr"
            },
            "id": "#naive_report",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-mglm"
            },
            "id": "#machete_glm",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-kglm"
            },
            "id": "#knife_glm",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-if",
              "itemSeparator": " "
            },
            "id": "#indel_files",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-5p"
            },
            "id": "#five_prime_sam",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fj"
            },
            "id": "#far_junctions",
            "type": [
              "null",
              "File"
            ],
            "sbg:stageInput": "link",
            "required": false
          },
          {
            "sbg:altPrefix": "--duplicate_junction",
            "required": false,
            "sbg:fileTypes": "PICKLE",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-dj"
            },
            "id": "#duplicate_junction",
            "type": [
              "null",
              "File"
            ],
            "sbg:stageInput": "link"
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-badfjpe",
              "itemSeparator": " "
            },
            "id": "#badfjpe",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-badfj",
              "itemSeparator": " "
            },
            "id": "#badfj",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos",
          "roozbehdn"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "AppendNaiveRept.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 22,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520601227
      },
      "inputs": [
        {
          "id": "#MACHETE_AppendNaiveReptParallel.three_prime_sam",
          "source": [
            "#MACHETE_Bowtie2_Aligner_3_prime.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel.suffix",
          "default": "MACHETE_Parallel"
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel.naive_report",
          "source": [
            "#MACHETE_FarJuncNaiveReport.naive_report"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel.machete_glm",
          "source": [
            "#MACHETE_GLM_script_UseIndel.fusion_w_anomaly_and_indel_juncp_out_lef_join"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel.knife_glm",
          "source": [
            "#KNIFE_GLM_model.linear_junc_probs"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel.indel_files",
          "source": [
            "#MACHETE_MakeIndelsHisto.indels_txt"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel.five_prime_sam",
          "source": [
            "#MACHETE_Bowtie2_Aligner_5_prime.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel.far_junctions",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel.duplicate_junction",
          "source": [
            "#MACHETE_combine_fasta_files.duplicate_junction"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel.badfjpe",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_AppendNaiveReptParallel.badfj",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.result_sam_file",
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_AppendNaiveReptParallel.appended_naive_report"
        }
      ],
      "sbg:x": 5744.790039062502,
      "sbg:y": 356.4895019531251
    },
    {
      "id": "#MACHETE_FJIndels_ClassIDFile",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python FJIndels_ClassIDFile.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/fjindels-classidfile/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 5386.588816692273,
        "id": "milos_jordanski/spachete-salzman-collaboration/fjindels-classidfile/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532513049,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "FJIndels_ClassIDFile.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 16 16:12:27 2015\n\n@author: Gillian\n\"\"\"\n# takes alignments from Indels and finds read partner.\n# all Far Junction and Scrambled junction reads where the alignment does not overlap the\n# Junction by args.window bp will be thrown out.\n\n# This program then tells if read partners \"makes sense\" or not\n# final Output categories -- [0] R1 junc name\n#   [1] genome - R2 location < 100mill bp away\n#   [2] genome anomaly - R2 location > 100mill bp away\n#   [3] genome p value\n#   [4] reg - R2 closest location <100mill bp away\n#   [5] reg anomaly - R2 closest location > 100 mill bp away\n#   [6] reg p value\n#   [7] junc / scrambled - R2 closest location <100mill bp away\n#   [8] junc anomaly - R2 closest location > 100mill bp away\n#   [9] junc p value\n#   [10] FarJunc - R2 aligned to same FarJunc\n#   [11] FarJunc anomaly - R2 aligned to diff FarJunc\n#   [12] FarJunc p value\n#   [13] unaligned - R2 didn't align\n#   [14] unmapped - R2 missing in action\n#   [15] P val for all non-anomaly classes\n\n\n\n################\n# Current categories\n# FJgood -- genome, reg, FJ\n# FJbad -- genome anomaly, reg anomaly, junc, junc anomaly, FJ anomaly\n#################\n\n\n\nimport argparse\nimport os\nimport glob\n\n\ndef AddToDict(inputtype, line_raw_comparison, line_raw_FJ):\n    lineFJ = ReadInfoFJ(line_raw_FJ)\n\n    if inputtype == \"FJ\":  # if comparing Far Junc to Far Junc, they have to be identical\n        line2 = ReadInfoFJ(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction[\n                                                                                        :-5] + \"\\t\" + lineFJ.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        if lineFJ.junction == line2.junction and lineFJ.refstrand in [\"0\", \"16\"] and line2.refstrand in [\"0\",\n                                                                                                         \"16\"] and lineFJ.refstrand != line2.refstrand:\n            #            TargetDict[lineFJ.junction][0] +=1\n            IDfiletype = \"FJgood,FarJunction,\" + lineFJ.junction[-4:]\n        else:\n            #            TargetDict[lineFJ.junction][1]+=1\n            IDfiletype = \"FJbad,FarJuncAnom,\" + lineFJ.junction[-4:]\n        # addAS = 0.0\n        #            addNumofBases = 0.0\n        #\n        #        TargetDict[lineFJ.junction][2] += addAS\n        #        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"reg\" or inputtype == \"junc\":  # if reg or junc read and meets refstrand criteria below\n        line2 = ReadInfoJunc(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction[\n                                                                                        :-5] + \"\\t\" + lineFJ.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        if inputtype == \"junc\":\n            IDfiletype = \"FJbad,Junction,\" + lineFJ.junction[-4:]\n\n        if inputtype == \"reg\":\n            IDfiletype = \"FJbad,RegAnomaly,\" + lineFJ.junction[-4:]\n\n            if lineFJ.chr_left == line2.chr:\n                if lineFJ.strand_left == line2.strand:\n                    if lineFJ.strand_left == \"-\":\n                        if lineFJ.refstrand == line2.refstrand:\n                            if int(lineFJ.loc_left) <= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n                    elif lineFJ.strand_left == \"+\":\n                        if lineFJ.refstrand != line2.refstrand:\n                            if int(lineFJ.loc_left) >= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n            if IDfiletype == \"FJbad,RegAnomaly,\" + lineFJ.junction[-4:]:\n                if lineFJ.chr_right == line2.chr:\n                    if lineFJ.strand_right == line2.strand:\n                        if lineFJ.strand_right == \"-\":\n                            if lineFJ.refstrand == line2.refstrand:\n                                if int(lineFJ.loc_right) >= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n                        elif lineFJ.strand_right == \"+\":\n                            if lineFJ.refstrand != line2.refstrand:\n                                if int(lineFJ.loc_right) <= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n        IDfile.flush()\n\n    if inputtype == \"genome\":  # comparing FJ to genome, has to be within 100Kbp, meet ref strand criteria (opp refstrand if + read, same refstrand if - read)\n\n        line2 = ReadInfoGenome(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction[\n                                                                                        :-5] + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.loc) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(line2.NumOfBases) + \"\\t\" + line2.chr + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"FJbad,genomAnomaly,\" + lineFJ.junction[-4:]\n        # compare left\n        if lineFJ.chr_left == line2.chr:\n            if lineFJ.strand_left == \"-\":\n                if lineFJ.refstrand == line2.refstrand:\n                    if int(lineFJ.loc_left) <= int(line2.loc):\n                        IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n            elif lineFJ.strand_left == \"+\":\n                if lineFJ.refstrand != line2.refstrand:\n                    if int(lineFJ.loc_left) >= int(line2.loc):\n                        IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n                        ## if left not the same, then compare right\n        if IDfiletype == \"FJbad,genomAnomaly,\" + lineFJ.junction[-4:]:\n            if lineFJ.chr_right == line2.chr:\n                if lineFJ.strand_right == \"-\":\n                    if lineFJ.refstrand == line2.refstrand:\n                        if int(lineFJ.loc_right) >= int(line2.loc):\n                            IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n                elif lineFJ.strand_right == \"+\":\n                    if lineFJ.refstrand != line2.refstrand:\n                        if int(lineFJ.loc_right) <= int(line2.loc):\n                            IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n\n#\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        if self.junction[-4:-1] == \"DEL\":\n            self.indel = -int(self.junction[-1:])\n        elif self.junction[-4:-1] == \"INS\":\n            self.indel = int(self.junction[-1:])\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\n\nclass ReadInfoGenome:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.chr = line[2]\n        self.loc = line[3]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\nclass ReadInfoJunc:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.chr = line[2].split(\"|\")[0]\n        self.loc_1 = line[2].replace(\":\", \"|\").split(\"|\")[2]\n        self.loc_2 = line[2].replace(\":\", \"|\").split(\"|\")[4]\n        self.strand = line[2][-1]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\n# =========================================\n# start here\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name of file to generate report\")\n#parser.add_argument(\"-c\", \"--circReads\", required=True, help=\"path to circReads Dir\")\n#parser.add_argument(\"-f\", \"--FJDir\", required=True, help=\"path to aligned junction reads\")\n#parser.add_argument(\"-i\", \"--origDir\", required=True, help=\"path to orig dir containing genome reads\")\nparser.add_argument(\"-w\", \"--window\", required=True, help=\"# of bases needed on each side of the junction\")\n\n\nparser.add_argument(\"-fusj1\", \"--fusionJuncSAM1\", required=True, help=\"unaligned reads1 to fusion junctions\")\nparser.add_argument(\"-fusj2\", \"--fusionJuncSAM2\", required=True, help=\"unaligned reads2 to fusion junctions\")\n\nparser.add_argument(\"-asufji1\", \"--allStillUnalignedFusionJuncSAM1\", required=True, help=\"All still unaligned reads1 to fusion junction indels\")\nparser.add_argument(\"-asufji2\", \"--allStillUnalignedFusionJuncSAM2\", required=True, help=\"All still unaligned reads2 to fusion junction indels\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\n\nparser.add_argument(\"-gens1\", \"--genomeSAM1\", required=True, help=\"read1 to genome\")\nparser.add_argument(\"-gens2\", \"--genomeSAM2\", required=True, help=\"read2 to genome\")\nparser.add_argument(\"-regs1\", \"--regularSAM1\", required=True, help=\"read1 to regular junction\")\nparser.add_argument(\"-regs2\", \"--regularSAM2\", required=True, help=\"read2 to regular junction\")\nparser.add_argument(\"-scrs1\", \"--scrambledSAM1\", required=True, help=\"read1 to ribosomal junction\")\nparser.add_argument(\"-scrs2\", \"--scrambledSAM2\", required=True, help=\"read2 to ribosomal junction\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\nwindow = int(args.window)\njunction_length = int(args.farJunctionLength)\n\n# f1 = open(\"/Users/Gillian/Desktop/sherlock/unaligned_ENCFF000HOC1_1.sam\", mode =\"rU\")\n# f2 = open(\"/Users/Gillian/Desktop/sherlock/20000_ENCFF000HOC2_1_genome_output.sam\", mode =\"rU\")\n\n#if args.FJDir[-1] != \"/\":\n#    args.FJDir += \"/\"\n#if args.origDir[-1] != \"/\":\n#    args.origDir += \"/\"\n#if args.circReads[-1] != \"/\":\n#    args.circReads += \"/\"\n\n#stem = args.stem\n\n#FarJunctionfiles = []\nFarJunction_noIndelfiles = []\ngenomefiles = []\nregfiles = []\njunctionfiles = []\n\n#for name in glob.glob(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + stem + \"/*.sam\"):\n#    print name\n#    if \"All_\" not in name:\n#        FarJunctionfiles.append(name)\n        # FarJunctionFiles contains indel alignments for _1 and _2 files to indels 1-5\n\n\n\n#for name in glob.glob(args.FJDir + \"FarJunctionAlignments/\" + stem + \"/*.sam\"):\n#    FarJunction_noIndelfiles.append(name)\n\n#for name in glob.glob(os.path.join(args.origDir, \"genome/*\" + stem + \"*.sam\")):\n#    #    print name\n#    if \"sorted\" not in name:\n#        genomefiles.append(name)\n\n#for name in glob.glob(os.path.join(args.origDir, \"reg/*\" + stem + \"*.sam\")):\n    #    print name\n#    if \"sorted\" not in name:\n#        regfiles.append(name)\n#for name in glob.glob(os.path.join(args.origDir, \"junction/*\" + stem + \"*.sam\")):\n#    #    print name\n#    if \"sorted\" not in name:\n#        junctionfiles.append(name)\n        # for name in glob.glob(os.path.join(args.origDir,\"unaligned/*\" + stem + \"*.fq\")):\n##    print name\n#    if \"sorted\" not in name:\n#        unalignedfiles.append(name)\n\n\n# opening all files for a particular stem\n#print sorted(FarJunction_noIndelfiles)\n#print sorted(genomefiles)\n#print sorted(regfiles)\n#print sorted(junctionfiles)\n\n## open big indels files\n\n#f1_FarJunc = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + stem + \"/All_\" + stem + \"_1_indels.sam\", mode=\"rB\")\n#f2_FarJunc = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + stem + \"/All_\" + stem + \"_2_indels.sam\", mode=\"rB\")\n\nf1_FarJunc = open(args.allStillUnalignedFusionJuncSAM1, mode = \"rB\")\nf2_FarJunc = open(args.allStillUnalignedFusionJuncSAM2, mode = \"rB\")\n\n#f1_FJ_noIndel = open(sorted(FarJunction_noIndelfiles)[0], mode=\"rB\")\n#f2_FJ_noIndel = open(sorted(FarJunction_noIndelfiles)[1], mode=\"rB\")\n\nf1_FJ_noIndel = open(args.fusionJuncSAM1, mode = \"rB\")\nf2_FJ_noIndel = open(args.fusionJuncSAM2, mode = \"rB\")\n\nIDfile = open(args.sample + \"_temp_output_FJIndels.txt\", mode=\"w\")\nIDfile.write(\"ID\\tclass\\tR1_offset\\tR1_MAPQ\\tR1_AS\\tR1_NumN\\tR1_Readlength\\tR1_JuncName\\tR1_strand\\tR2_offset\\tR2_MAPQ\\tR2_AS\\tR2_NumN\\tR2_Readlength\\tR2_JuncName\\tR2_strand\\n\")\n\n# populate all reads and junctions into separate dictionaries\nAllFJRead1 = {}\nAllFJRead2 = {}\n\n# populate AllFJRead1 dictionary - all read 1's from FarJunction alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening FarJunc _1 file\"\n\nfor line_raw in f1_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n\n    FJ1read = ReadInfoFJ(line_raw)\n\n    if FJ1read.offset <= (junction_length/2 + FJ1read.indel - window) and (\n        FJ1read.offset + FJ1read.NumOfBases) >= junction_length/2 + FJ1read.indel + window:\n        AllFJRead1[FJ1read.ID] = [line_raw, 0]\n\nf1_FarJunc.close()\nIDfile.flush()\n\n# populate AllFJRead2 dictionary - all read 2's from FarJunc alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening farJunc _2 file\"\nfor line_raw in f2_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n\n    FJ2read = ReadInfoFJ(line_raw)\n\n    # if R1 and R2 both in Far Junc, then add to FJ-FJ list\n    if FJ2read.ID in AllFJRead1:\n        if FJ2read.offset <= (junction_length/2 + FJ2read.indel - window) and (\n            FJ2read.offset + FJ2read.NumOfBases) >= junction_length/2 + FJ2read.indel + window and AllFJRead1[FJ2read.ID][1] == 0:\n            AddToDict(\"FJ\", line_raw, AllFJRead1[FJ2read.ID][0])\n            AllFJRead1[FJ2read.ID][1] = \"FJ\"\n    else:\n        AllFJRead2[FJ2read.ID] = [line_raw, 0]\n\n# if FJ2read.junction not in AllJunctions:\n#        AllJunctions[FJ2read.junction]=0\n#\n#    AllJunctions[FJ2read.junction]+=1\nf2_FarJunc.close()\nIDfile.flush()\n\n# compare FJ with indels_1 to FJ with no indels _ 2\nprint \"comparing indels with FJ _2\"\nfor line_raw in f2_FJ_noIndel:\n    if line_raw[0] == \"@\":\n        continue\n    FJ2read = ReadInfoFJ(line_raw)\n\n    if FJ2read.ID in AllFJRead1 and AllFJRead1[FJ2read.ID][1] == 0:\n        AddToDict(\"FJ\", line_raw, AllFJRead1[FJ2read.ID][0])\n        AllFJRead1[FJ2read.ID][1] = \"FJ\"\n\nf2_FJ_noIndel.close()\nIDfile.flush()\n\n# compare FJ with indels _2 to FJ with no indels _1\n\nprint \"comparing indels with FJ _1\"\n\nfor line_raw in f1_FJ_noIndel:\n    if line_raw[0] == \"@\":\n        continue\n    FJ1read = ReadInfoFJ(line_raw)\n\n    if FJ1read.ID in AllFJRead2 and AllFJRead2[FJ1read.ID][1] == 0:\n        # print \"found genome R1\"+g1read.ID\n        #        if g1read.ID in unmappedDict:\n        #            del unmappedDict[g1read.ID]\n        AddToDict(\"FJ\", line_raw, AllFJRead2[FJ1read.ID][0])\n        AllFJRead2[FJ1read.ID][1] = \"FJ\"\nf1_FJ_noIndel.close()\nIDfile.flush()\n\n#f2_genome = open(sorted(genomefiles)[1], mode=\"rB\")\nf2_genome = open(args.genomeSAM2, mode = \"rB\")\n\n# compare FJ read 1 to genome read 2\nprint \"comparing indels with genome_2\"\n\nfor line_raw in f2_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g2read = ReadInfoGenome(line_raw)\n\n    if g2read.ID in AllFJRead1 and AllFJRead1[g2read.ID][1] == 0:\n        AddToDict(\"genome\", line_raw, AllFJRead1[g2read.ID][0])\n        AllFJRead1[g2read.ID][1] = \"genome\"\n\nf2_genome.close()\n\nIDfile.flush()\n\n#f1_genome = open(sorted(genomefiles)[0], mode=\"rB\")\nf1_genome = open(args.genomeSAM1, mode = \"rB\")\n\n# compare FJ read 2 to genome read 1\nprint \"comparing indels with genome _1\"\nfor line_raw in f1_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g1read = ReadInfoGenome(line_raw)\n\n    if g1read.ID in AllFJRead2 and AllFJRead2[g1read.ID][1] == 0:\n        # print \"found genome R1\"+g1read.ID\n        #        if g1read.ID in unmappedDict:\n        #            del unmappedDict[g1read.ID]\n        AddToDict(\"genome\", line_raw, AllFJRead2[g1read.ID][0])\n        AllFJRead2[g1read.ID][1] = \"genome\"\nf1_genome.close()\n\nIDfile.flush()\n\n#f2_reg = open(sorted(regfiles)[1], mode=\"rB\")\nf2_reg = open(args.regularSAM2, mode=\"rB\")\n\n# compare FJ read 1 to reg read 2\nprint \"comparing indels with reg _2\"\n\nfor line_raw in f2_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg2read = ReadInfoJunc(line_raw)\n\n    if reg2read.offset <= (junction_length/2 - window) and (reg2read.offset + reg2read.NumOfBases) >= (junction_length/2 + window):\n        if reg2read.ID in AllFJRead1 and AllFJRead1[reg2read.ID][1] == 0:\n            #            print \"found reg R2:\" + reg2read.ID\n            #            if reg2read.ID in unmappedDict:\n            #                del unmappedDict[reg2read.ID]\n            AddToDict(\"reg\", line_raw, AllFJRead1[reg2read.ID][0])\n            AllFJRead1[reg2read.ID][1] = \"reg\"\nf2_reg.close()\nIDfile.flush()\n\n#f1_reg = open(sorted(regfiles)[0], mode=\"rB\")\nf1_reg = open(args.regularSAM1, mode=\"rB\")\n\n# compare FJ read 2 to reg read 1\nprint \"comparing indels with reg _1\"\n\nfor line_raw in f1_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg1read = ReadInfoJunc(line_raw)\n\n    if reg1read.offset <= (junction_length/2 - window) and (reg1read.offset + reg1read.NumOfBases) >= (junction_length/2 + window):\n        if reg1read.ID in AllFJRead2 and AllFJRead2[reg1read.ID][1] == 0:\n            #            print \"found reg R1: \" + reg1read.ID\n            #            if reg1read.ID in unmappedDict:\n            #                del unmappedDict[reg1read.ID]\n            AddToDict(\"reg\", line_raw, AllFJRead2[reg1read.ID][0])\n            AllFJRead2[reg1read.ID][1] = \"reg\"\nf1_reg.close()\nIDfile.flush()\n\n#f2_junc = open(sorted(junctionfiles)[1], mode=\"rB\")\nf2_junc = open(args.scrambledSAM2, mode=\"rB\")\n\n# compare FJ read 1 to junc read 2\nprint \"comparing indels with junc _2\"\n\nfor line_raw in f2_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc2read = ReadInfoJunc(line_raw)\n\n    if junc2read.offset <= (junction_length/2 - window) and (junc2read.offset + junc2read.NumOfBases) >= (junction_length/2 + window):\n        if junc2read.ID in AllFJRead1 and AllFJRead1[junc2read.ID][1] == 0:\n            # print \"found junc R2 \" + junc2read.ID\n            #            if junc2read.ID in unmappedDict:\n            #                del unmappedDict[junc2read.ID]\n            AddToDict(\"junc\", line_raw, AllFJRead1[junc2read.ID][0])\n            AllFJRead1[junc2read.ID][1] = \"junc\"\nf2_junc.close()\nIDfile.flush()\n\n#f1_junc = open(sorted(junctionfiles)[0], mode=\"rB\")\nf1_junc = open(args.scrambledSAM1, mode=\"rB\")\n\n# compare FJ read 2 to junc read 1\nprint \"comparing indels with junc _1\"\n\nfor line_raw in f1_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc1read = ReadInfoJunc(line_raw)\n\n    if junc1read.offset <= (junction_length/2 - window) and (junc1read.offset + junc1read.NumOfBases) >= (junction_length/2 + window):\n        if junc1read.ID in AllFJRead2 and AllFJRead2[junc1read.ID][1] == 0:\n            # print \"found junc R1: \" + junc1read.ID\n            #            if junc1read.ID in unmappedDict:\n            #                del unmappedDict[junc1read.ID]\n            AddToDict(\"junc\", line_raw, AllFJRead2[junc1read.ID][0])\n            AllFJRead2[junc1read.ID][1] = \"junc\"\nf1_junc.close()\nIDfile.flush()\n\nIDfile.close()\n\n#############################################################################\n## This section of code takes the written ID file above (temp_IDs_STEM.txt) and\n## removes duplicate entries of genome and reg. The same readID may be found\n## in both libraries and would both be in the ID file.\n## The new ID file removes duplicates and only keeps the readID with the\n## best alignment score.\n#tempIDfile = open(args.FJDir + \"GLM_classInput/\" + args.stem + \"_temp_output_FJIndels.txt\", mode=\"rU\")\n#newIDfile = open(args.FJDir + \"GLM_classInput/\" + args.stem + \"_output_FJIndels.txt\", mode=\"w\")\n\ntempIDfile = open(args.sample + \"_temp_output_FJIndels.txt\", mode=\"rU\")\nnewIDfile = open(args.sample + \"__output_FJIndels.txt\", mode=\"w\")\n\n##grep col 2 for \"genom\", \"Regular\" or \"RegAnomaly\". if not found ,write to\n## new file immediately.\n## if found, feed into dictionary (key=readID, value= entire line from temp file)\n## if duplicate entry, then compare R2 AS. if AS larger, then replace\n## value with new value from new R2\n## at completion of file, write entire dictionary into new ID file.\n\nGenomeAndRegReadIDs = {}\n\nfor line in tempIDfile:\n    line = line.strip()\n    if \"unaligned\" in line:\n        continue\n\n    if \"Unmapped\" in line:\n        continue\n\n    readID = line.split(\"\\t\")[0]\n    classID = line.split(\"\\t\")[1]\n    AS_new = line.split(\"\\t\")[11]\n\n    if \"genom\" in classID:\n        ## if readID has been seen previously, then replace value in dictionary\n        ## only if AS is greater.\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"Regular\" in classID:\n        ## do the same if reg\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"RegAnomaly\" in classID:\n        ## do the same if reg anomaly\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    else:\n        ## if not genome/genome anomaly/ reg/ reg anomaly then\n        ## write line directly in new file.\n        newIDfile.write(line + \"\\n\")\n\nfor entry in GenomeAndRegReadIDs:\n    newIDfile.write(GenomeAndRegReadIDs[entry] + \"\\n\")\n\ntempIDfile.close()\nnewIDfile.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "allStillUnalignedFusionJuncSAM2": {
              "path": "/path/to/allStillUnalignedFusionJuncSAM2.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "junction_length": 9,
            "mode": "complete",
            "overlap": 4,
            "regular_sam": [
              {
                "path": "/path/to/regular_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/regular_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "allStillUnalignedFusionJuncSAM1": {
              "path": "/path/to/allStillUnalignedFusionJuncSAM1.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "genome_sam": [
              {
                "path": "/path/to/genome_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/genome_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "fusion_junction_sam": [
              {
                "path": "/path/to/fusion_junction_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/fusion_junction_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "scrambled_sam": [
              {
                "path": "/path/to/scrambled_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/scrambled_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434004,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": null,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedOn": 1520434028,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "revision 7 copied",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedOn": 1532513049,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_temp_output_FJIndels.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#temp_output_FJIndels"
          },
          {
            "outputBinding": {
              "glob": "*__output_FJIndels.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#output_FJIndels"
          }
        ],
        "label": "MACHETE FJIndels_ClassIDFile",
        "sbg:latestRevision": 2,
        "sbg:revisionNotes": "junction_length parameter added",
        "y": 358.8392056664239,
        "inputs": [
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrs1 \" + inputs[i].path\n        else\n          cmd += \" -scrs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#scrambled_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regs1 \" + inputs[i].path\n        else\n          cmd += \" -regs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#regular_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "id": "#overlap",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.overlap)\n    {\n    \treturn \" -w \" + $job.inputs.overlap + \" \"\n    }\n  \telse\n    {\n    \treturn \" -w 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "id": "#mode",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-m"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gens1 \" + inputs[i].path\n        else\n          cmd += \" -gens2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#genome_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -fusj1 \" + inputs[i].path\n        else\n          cmd += \" -fusj2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#fusion_junction_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--allStillUnalignedFusionJuncSAM2",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-asufji2"
            },
            "id": "#allStillUnalignedFusionJuncSAM2",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--allStillUnalignedFusionJuncSAM1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-asufji1"
            },
            "id": "#allStillUnalignedFusionJuncSAM1",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "FJIndels_ClassIDFile.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520434004
      },
      "inputs": [
        {
          "id": "#MACHETE_FJIndels_ClassIDFile.scrambled_sam",
          "source": [
            "#getUnalignedReads_2.mate_scrambled_sam",
            "#getUnalignedReads_1.mate_scrambled_sam"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile.regular_sam",
          "source": [
            "#getUnalignedReads_2.mate_regular_sam",
            "#getUnalignedReads_1.mate_regular_sam"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile.junction_length",
          "default": 300
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile.genome_sam",
          "source": [
            "#getUnalignedReads_2.mate_genome_sam",
            "#getUnalignedReads_1.mate_genome_sam"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile.fusion_junction_sam",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile.allStillUnalignedFusionJuncSAM2",
          "source": [
            "#MACHETE_MakeIndelsHisto.all_indels_sam_2"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile.allStillUnalignedFusionJuncSAM1",
          "source": [
            "#MACHETE_MakeIndelsHisto.all_indels_sam_1"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_FJIndels_ClassIDFile.temp_output_FJIndels"
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile.output_FJIndels"
        }
      ],
      "sbg:x": 5386.588816692273,
      "sbg:y": 358.8392056664239
    },
    {
      "id": "#MACHETE_MakeIndelsHisto",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python MakeIndelsHisto.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/makeindelshisto/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 4839.688818384,
        "id": "milos_jordanski/spachete-salzman-collaboration/makeindelshisto/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532513116,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "MakeIndelsHisto.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Mar 25 15:25:42 2016\n\n@author: Gillian\n\"\"\"\n\nimport argparse\nimport glob\n\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        if self.junction[-4:-1] == \"DEL\":\n            self.indel = -int(self.junction[-1:])\n        elif self.junction[-4:-1] == \"INS\":\n            self.indel = int(self.junction[-1:])\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n        else:\n            self.NumN = line[12][5:]\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"file sample name\")\n#parser.add_argument(\"-f\", \"--FJDir\", required=True, help=\"FJ directory\")\nparser.add_argument(\"-w\", \"--overlap\", required=True, help=\"required overlapping nt on each side of junction, including # indels\")\nparser.add_argument(\"-x\", \"--NumIndels\", required=True, help=\"number of indels allowed from previous file\")\nparser.add_argument(\"-ufj1\", \"--unaligned_to_FJ_1\", required=True, help=\"unaligned read1 from KNIFE aligned to FJ\")\nparser.add_argument(\"-ufj2\", \"--unaligned_to_FJ_2\", required=True, help=\"unaligned read2 from KNIFE aligned to FJ\")\nparser.add_argument(\"-sufji1\", \"--still_unaligned_to_FJIndels_1\", nargs='+', required=True, help=\"still unaligned read1 aligned to FJIndels1\")\nparser.add_argument(\"-sufji2\", \"--still_unaligned_to_FJIndels_2\", nargs='+', required=True, help=\"still unaligned read2 aligned to FJIndels2\")\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\n\njunction_length = int(args.farJunctionLength)\n\n#if args.FJDir[-1] != \"/\":\n#    args.FJDir += \"/\"\n\n#\n### make a concatenated list of all the far junction alignment files\n\n#\n# input_lines=fileinput.input(FJ1_list)\n# fout_FJ1.writelines(input_lines)\n# input_lines=fileinput.input(FJ2_list)\n# fout_FJ2.writelines(input_lines)\n#\n# fout_FJ1.close()\n# fout_FJ2.close()\n\n\n## now go through all primary alignments and make a dictionary of possible far juncs:\n\nFJDict_1 = {}  ## key = junc name, Val = # [0,0,0,0,X,0,0,0,0]  0's # of indels\nFJDict_2 = {}\n\n#FJFile1 = sorted(glob.glob(args.FJDir + \"FarJunctionAlignments/\" + args.stem + \"/*.sam\"))[0]\n#FJFile2 = sorted(glob.glob(args.FJDir + \"FarJunctionAlignments/\" + args.stem + \"/*.sam\"))[1]\n\nFJFile1 = args.unaligned_to_FJ_1\nFJFile2 = args.unaligned_to_FJ_2\n\nf1 = open(FJFile1, mode=\"rU\")\nprint \"opening\" + FJFile1\n\nlinecount = 0\ngoodlinecount = 0\nnewjunc = 0\nfor line_raw in f1:\n    if line_raw[0] == \"@\":\n        continue\n    linecount += 1\n    FJread = ReadInfoFJ(line_raw)\n    if FJread.offset <= (junction_length/2 - int(args.overlap)) and FJread.offset + FJread.NumOfBases >= (junction_length/2 + int(args.overlap)):\n        if FJread.junction not in FJDict_1:\n            FJDict_1[FJread.junction] = [0] * (2 * int(args.NumIndels) + 1)\n            newjunc += 1\n        FJDict_1[FJread.junction][int(args.NumIndels)] += 1\n        goodlinecount += 1\nf1.close()\nprint \"new junc added\" + str(newjunc)\nprint linecount\nprint goodlinecount\n\nlinecount = 0\ngoodlinecount = 0\nnewjunc = 0\n\nf2 = open(FJFile2, mode=\"rU\")\nprint \"opening\" + FJFile2\nfor line_raw in f2:\n    if line_raw[0] == \"@\":\n        continue\n    FJread = ReadInfoFJ(line_raw)\n    linecount += 1\n    if FJread.offset <= (junction_length/2 - int(args.overlap)) and FJread.offset + FJread.NumOfBases >= (junction_length/2 + int(args.overlap)):\n        if FJread.junction not in FJDict_2:\n            FJDict_2[FJread.junction] = [0] * (2 * int(args.NumIndels) + 1)\n            newjunc += 1\n\n        FJDict_2[FJread.junction][int(args.NumIndels)] += 1\n        goodlinecount += 1\nf2.close()\nprint \"new junc added\" + str(newjunc)\nprint linecount\nprint goodlinecount\n\n## make a dictionary of readIDs that aligned to any FJ indel\n\n\n\nAlignedFJFiles = []\n\n#for name in glob.glob(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/*.sam\"):\n#    if \"All_\" not in name:\n#        AlignedFJFiles.append(name)\n\n\n#FJ1_list = sorted(AlignedFJFiles)[0:len(AlignedFJFiles) / 2]\n#FJ2_list = sorted(AlignedFJFiles)[len(AlignedFJFiles) / 2:]\n\nFJ1_list = args.still_unaligned_to_FJIndels_1\nFJ2_list = args.still_unaligned_to_FJIndels_2\n\n#\n# print \"FJ1 indels list\"\n# print FJ1_list\n# print \"FJ2 indels list\"\n# print FJ2_list\n\nIndelsReadIDs = {}\n\nfor name in FJ1_list:\n    print \"FJ1 indels\"\n    print name\n    f1 = open(name, mode=\"rU\")\n\n    for line in f1:\n        if line[0] == \"@\":\n            continue\n\n        read = ReadInfoFJ(line)\n        # if the read overlaps the junction\n        if read.offset <= (junction_length/2 - int(args.overlap) + read.indel) and read.offset + read.NumOfBases >= (junction_length/2 + int(args.overlap) + read.indel):\n\n            # if the read isn't in dictionary then add it\n            if read.ID not in IndelsReadIDs:\n                IndelsReadIDs[read.ID] = line\n            # if the read is in the dictionary, compare it to existing read. If AS is better, then replace existing read\n            else:\n                compareRead = ReadInfoFJ(IndelsReadIDs[read.ID])\n                if int(compareRead.AS) >= int(read.AS):\n                    pass\n                else:\n                    IndelsReadIDs[read.ID] = line\n    f1.close()\n\n# write all distinct readIDs to an All_1_indels file\n#fout_FJ1 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_1_indels.sam\", mode=\"w\")\nfout_FJ1 = open(\"All_\" + args.sample + \"_1_indels.sam\", mode = \"w\")\n\nfor key in IndelsReadIDs:\n    fout_FJ1.write(IndelsReadIDs[key].strip() + \"\\n\")\nfout_FJ1.close()\n\n## CLEAR Read IDs dictionary and do the same with FJ2 list\nIndelsReadIDs = {}\n\nfor name in FJ2_list:\n    print \"FJ2 indels\"\n    print name\n\n    f1 = open(name, mode=\"rU\")\n\n    for line in f1:\n        if line[0] == \"@\":\n            continue\n\n        read = ReadInfoFJ(line)\n        # if the read overlaps the junction\n        if read.offset <= (junction_length/2 - int(args.overlap) + read.indel) and read.offset + read.NumOfBases >= (junction_length/2 + int(args.overlap) + read.indel):\n\n            # if the read isn't in dictionary then add it\n            if read.ID not in IndelsReadIDs:\n                IndelsReadIDs[read.ID] = line\n            # if the read is in the dictionary, compare it to existing read. If AS is better, then replace existing read\n            else:\n                compareRead = ReadInfoFJ(IndelsReadIDs[read.ID])\n                if int(compareRead.AS) >= int(read.AS):\n                    pass\n                else:\n                    IndelsReadIDs[read.ID] = line\n    f1.close()\n\n# write all distinct readIDs to an All_1_indels file\n#fout_FJ2 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_2_indels.sam\", mode=\"w\")\nfout_FJ2 = open(\"All_\" + args.sample + \"_2_indels.sam\", mode = \"w\")\n\nfor key in IndelsReadIDs:\n    fout_FJ2.write(IndelsReadIDs[key].strip() + \"\\n\")\nfout_FJ2.close()\n\n## parse AllIndels_1 and AllIndels_2 files to see if they aligned to the same juncs with indels as an FJ\n## if yes, then add to junction \"dictionary\"\n\n#Indels1 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_1_indels.sam\", mode=\"rU\")\nIndels1 = open(\"All_\" + args.sample + \"_1_indels.sam\", mode=\"rU\")\n\nfor line in Indels1:\n    read = ReadInfoFJ(line)\n    if read.junction[:-5] in FJDict_1:\n        FJDict_1[read.junction[:-5]][int(args.NumIndels) + read.indel] += 1\nIndels1.close()\n\n#Indels2 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_2_indels.sam\", mode=\"rU\")\nIndels2 = open(\"All_\" + args.sample + \"_2_indels.sam\", mode=\"rU\")\n\nfor line in Indels2:\n    read = ReadInfoFJ(line)\n    if read.junction[:-5] in FJDict_2:\n        FJDict_2[read.junction[:-5]][int(args.NumIndels) + read.indel] += 1\nIndels2.close()\n\n## output indels histo\n\n#Outfile1 = open(args.FJDir + \"IndelsHistogram/indels_\" + args.stem + \"_1.txt\", mode=\"w\")\nOutfile1 = open(\"indels_\" + args.sample + \"_1.txt\", mode=\"w\")\n\nfor key in FJDict_1:\n    Outfile1.write(key + \"\\t\" + str(FJDict_1[key]) + \"\\n\")\nOutfile1.close()\n\n#Outfile2 = open(args.FJDir + \"IndelsHistogram/indels_\" + args.stem + \"_2.txt\", mode=\"w\")\nOutfile2 = open(\"indels_\" + args.sample + \"_2.txt\", mode=\"w\")\n\nfor key in FJDict_2:\n    Outfile2.write(key + \"\\t\" + str(FJDict_2[key]) + \"\\n\")\nOutfile2.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "mode": "complete",
            "junction_length": 6,
            "num_indels": 10,
            "overlap": 2,
            "unaligned_to_FJ": [
              {
                "path": "/path/to/unaligned_to_FJ-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/unaligned_to_FJ-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "still_unaligned_to_FJIndels_2": [
              {
                "path": "/path/to/still_unaligned_to_FJIndels_2-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/still_unaligned_to_FJIndels_2-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "still_unaligned_to_FJIndels_1": [
              {
                "path": "/path/to/still_unaligned_to_FJIndels_1-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/still_unaligned_to_FJIndels_1-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433939,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": null,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedOn": 1520433966,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "revision 5 copied",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedOn": 1532513116,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "indels*.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#indels_txt"
          },
          {
            "outputBinding": {
              "glob": "All*_2_indels.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#all_indels_sam_2"
          },
          {
            "outputBinding": {
              "glob": "All*_1_indels.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#all_indels_sam_1"
          }
        ],
        "label": "MACHETE MakeIndelsHisto",
        "sbg:latestRevision": 2,
        "sbg:revisionNotes": "junction_length parameter added",
        "y": 371.4365001515148,
        "inputs": [
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -ufj1 \" + inputs[i].path\n        else\n          cmd += \" -ufj2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#unaligned_to_FJ",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-sufji2",
              "itemSeparator": " "
            },
            "id": "#still_unaligned_to_FJIndels_2",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-sufji1",
              "itemSeparator": " "
            },
            "id": "#still_unaligned_to_FJIndels_1",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "id": "#overlap",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-w"
            },
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-x"
            },
            "id": "#num_indels",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "id": "#mode",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-m"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "MakeIndelsHisto.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520433939
      },
      "inputs": [
        {
          "id": "#MACHETE_MakeIndelsHisto.unaligned_to_FJ",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_MakeIndelsHisto.still_unaligned_to_FJIndels_2",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_MakeIndelsHisto.still_unaligned_to_FJIndels_1",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_MakeIndelsHisto.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#MACHETE_MakeIndelsHisto.num_indels",
          "default": 5
        },
        {
          "id": "#MACHETE_MakeIndelsHisto.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#MACHETE_MakeIndelsHisto.junction_length",
          "default": 300
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_MakeIndelsHisto.indels_txt"
        },
        {
          "id": "#MACHETE_MakeIndelsHisto.all_indels_sam_2"
        },
        {
          "id": "#MACHETE_MakeIndelsHisto.all_indels_sam_1"
        }
      ],
      "sbg:x": 4839.688818384,
      "sbg:y": 371.4365001515148
    },
    {
      "id": "#MACHETE_AddIndelsToFasta",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python AddIndelsToFasta.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/addindelstofasta/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    \n    if($job.inputs.filtered_fusion_junction.metadata && $job.inputs.filtered_fusion_junction.metadata.sample_id)\n   \t\tcmd = \"-s \" + $job.inputs.filtered_fusion_junction.metadata.sample_id\n\treturn cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 4202.60918707784,
        "id": "milos_jordanski/spachete-salzman-collaboration/addindelstofasta/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532513222,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "AddIndelsToFasta.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Oct 21 15:17:27 2015\n\n@author: Gillian\n\"\"\"\n\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-i\", \"--infile\", required=True, help=\"input file\")\n#parser.add_argument(\"-o\", \"--outDir\", required=True, help=\"output directory\")\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\nparser.add_argument(\"-n\", \"--MaxInDel\", required=True, help=\"# of indels on each side to test\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\n\n#if args.outDir[-1] != \"/\":\n#    args.outDir += \"/\"\n\n# indels are inserted into the FarJunction.fa file\n# insertions are SEQUENCEANNNNNSEQUENCEB where 2N is the number of indels given in the argument parser\n# deletions are SEQA-AAAAA[AAABBB]BBBSEQB where N*AAA and N*BBB are removed from the junction interface.\n# x,..,5, 4, 3, 2, 1 deletions on each side, then 2, 4, 6, 8, 10,.., 2X N's inserted into junction\n\njunction_length = int(args.farJunctionLength)\n\ncounter = 0\nf1 = open(args.infile, mode=\"rU\")\n\nfor i in range(1, int(args.MaxInDel) + 1):\n    f1.seek(0)\n\n    fout = open(args.sample + \"_FJ_Indels_\" + str(i) + \".fa\", mode=\"w\")\n    print \"writing indels\" + str(i) + \".fa\"\n\n    for line_raw in f1:\n\n        counter += 1\n\n        if line_raw[0] == \">\":\n            JunctionName = line_raw.strip()\n            JunctionSeq = \"\"\n\n        else:\n            JunctionSeq += line_raw.strip()\n\n        if len(JunctionSeq) == junction_length:\n            LeftExon = JunctionSeq[0:junction_length/2]\n            RightExon = JunctionSeq[junction_length/2:junction_length]\n            #        print JunctionName\n            # print JunctionSeq\n\n            fout.write(JunctionName + \"|DEL\" + str(i) + \"\\n\")\n            fout.write(LeftExon[0:-i] + RightExon[i:] + \"\\n\")\n            InsertN = \"N\" * (i * 2)\n            fout.write(JunctionName + \"|INS\" + str(i) + \"\\n\")\n            fout.write(LeftExon + InsertN + RightExon + \"\\n\")\n\n        if counter == 5000:\n            fout.flush()\n    fout.close()\n\nf1.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "junction_length": 3,
            "filtered_fusion_junction": {
              "path": "/path/to/filtered_fusion_junction.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "sample_name"
              }
            },
            "max_indel": 10
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433772,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": null,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedOn": 1520433790,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedOn": 1532513222,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#filtered_fusion_junction",
              "glob": "*_FJ_Indels_*"
            },
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#filtered_fusion_junction_indels"
          }
        ],
        "label": "MACHETE AddIndelsToFasta",
        "sbg:latestRevision": 2,
        "sbg:revisionNotes": "junction_length parameter added",
        "y": 355.2149511729233,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-n"
            },
            "id": "#max_indel",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-i"
            },
            "id": "#filtered_fusion_junction",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "AddIndelsToFasta.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520433772
      },
      "inputs": [
        {
          "id": "#MACHETE_AddIndelsToFasta.max_indel",
          "default": 5
        },
        {
          "id": "#MACHETE_AddIndelsToFasta.junction_length",
          "default": 300
        },
        {
          "id": "#MACHETE_AddIndelsToFasta.filtered_fusion_junction",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate.far_junctions"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_AddIndelsToFasta.filtered_fusion_junction_indels"
        }
      ],
      "sbg:x": 4202.60918707784,
      "sbg:y": 355.2149511729233
    },
    {
      "id": "#MACHETE_FarJuncNaiveReport",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python FarJuncNaiveReport.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/farjuncnaivereport/3",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 3499.331850466553,
        "id": "milos_jordanski/spachete-salzman-collaboration/farjuncnaivereport/3",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532515924,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "FarJuncNaiveReport.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 16 16:12:27 2015\n\n@author: Gillian\n\"\"\"\n# takes alignments from Far Junctions and finds read partner.\n# all Far Junction and Scrambled junction reads where the alignment does not overlap the\n# Junction by args.window bp will be thrown out.\n\n## Also creates class input files for Far Junctions (R1 = FJ, R2 = something else)\n\n# This program then tells if read partners \"makes sense\" or not\n# final Output categories -- [0] R1 junc name\n#   [1] genome - R2 location < 100mill bp away\n#   [2] genome anomaly - R2 location > 100mill bp away\n#   [3] genome p value\n#   [4] reg - R2 closest location <100mill bp away\n#   [5] reg anomaly - R2 closest location > 100 mill bp away\n#   [6] reg p value\n#   [7] junc / scrambled - R2 closest location <100mill bp away\n#   [8] junc anomaly - R2 closest location > 100mill bp away\n#   [9] junc p value\n#   [10] FarJunc - R2 aligned to same FarJunc\n#   [11] FarJunc anomaly - R2 aligned to diff FarJunc\n#   [12] FarJunc p value\n#   [13] unaligned - R2 didn't align\n#   [14] unmapped - R2 missing in action\n#   [15] P val for all non-anomaly classes\n\n\n\n################\n# Current categories\n# FJgood -- genome, reg, FJ\n# FJbad -- genome anomaly, reg anomaly, junc, junc anomaly, FJ anomaly\n#################\n\n\n\nimport argparse\nimport os\nimport glob\nfrom math import ceil\nfrom scipy.stats import poisson\nfrom collections import Counter\n\n\ndef AddToDict(inputtype, TargetDict, line_raw_comparison, line_raw_FJ):\n    lineFJ = ReadInfoFJ(line_raw_FJ)\n    #    if lineFJ.junction==\"chr1:S100A4:153516097:-|chr1:IFI16:158985661:+|strandcross\":\n    #        print \"ERROR AT LINE 42\"\n    #        print inputtype\n    #        print line_raw_comparison\n    #        print line_raw_FJ\n    #\n\n    if lineFJ.junction not in TargetDict:  # add junction to target dictionary if it doesn't exist\n        TargetDict[lineFJ.junction] = [0, 0, 0.0, 0.0]\n\n    if inputtype == \"FJ\":  # if comparing Far Junc to Far Junc, they have to be identical\n        line2 = ReadInfoFJ(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        addAS = lineFJ.AS + line2.AS\n        addNumofBases = lineFJ.NumOfBases + line2.NumOfBases\n\n        if lineFJ.junction == line2.junction and lineFJ.refstrand != line2.refstrand:\n            TargetDict[lineFJ.junction][0] += 1\n            IDfiletype = \"FJgood,FarJunction\"\n        else:\n            TargetDict[lineFJ.junction][1] += 1\n            IDfiletype = \"FJbad,FarJuncAnom\"\n            addAS = 0.0\n            addNumofBases = 0.0\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"reg\" or inputtype == \"junc\":  # if reg or junc read, then one side has to be within 100KB, and meets refstrand criteria below\n        line2 = ReadInfoJunc(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        if inputtype == \"junc\":\n            IDfiletype = \"FJbad,Junction\"\n            addAS = 0.0\n            addNumofBases = 0.0\n\n        if inputtype == \"reg\":\n            IDfiletype = \"FJbad,RegAnomaly\"\n            addAS = 0.0\n            addNumofBases = 0.0\n\n            if lineFJ.chr_left == line2.chr:\n                if lineFJ.strand_left == line2.strand:\n                    if lineFJ.strand_left == \"-\":\n                        if lineFJ.refstrand == line2.refstrand:\n                            if int(lineFJ.loc_left) <= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular\"\n                    elif lineFJ.strand_left == \"+\":\n                        if lineFJ.refstrand != line2.refstrand:\n                            if int(lineFJ.loc_left) >= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular\"\n            if IDfiletype == \"FJbad,RegAnomaly\":\n                if lineFJ.chr_right == line2.chr:\n                    if lineFJ.strand_right == line2.strand:\n                        if lineFJ.strand_right == \"-\":\n                            if lineFJ.refstrand == line2.refstrand:\n                                if int(lineFJ.loc_right) >= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular\"\n                        elif lineFJ.strand_right == \"+\":\n                            if lineFJ.refstrand != line2.refstrand:\n                                if int(lineFJ.loc_right) <= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular\"\n\n        if IDfiletype == \"FJgood,Regular\":\n            TargetDict[lineFJ.junction][0] += 1\n            addAS = lineFJ.AS + line2.AS\n            addNumofBases = lineFJ.NumOfBases + line2.NumOfBases\n        else:\n            TargetDict[lineFJ.junction][1] += 1\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"genome\":  # comparing FJ to genome, meet ref strand criteria (opp refstrand if + read, same refstrand if - read)\n\n        line2 = ReadInfoGenome(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.loc) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(line2.NumOfBases) + \"\\t\" + line2.chr + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"FJbad,genomAnomaly\"\n        addAS = 0.0\n        addNumofBases = 0.0\n\n        if lineFJ.chr_left == line2.chr:\n            # print \"checking left\"\n            if lineFJ.strand_left == \"-\":\n                # print \"left exon neg\"\n                if lineFJ.refstrand == line2.refstrand:\n                    # print \"left strand reference good\"\n                    if int(lineFJ.loc_left) <= int(line2.loc):\n                        # print \"left exon in expected location\"\n                        IDfiletype = \"FJgood,genome\"\n            elif lineFJ.strand_left == \"+\":\n                # print \"left exon pos\"\n                if lineFJ.refstrand != line2.refstrand:\n                    # print \"left strand good\"\n                    if int(lineFJ.loc_left) >= int(line2.loc):\n                        # print \"left strand location good\"\n                        IDfiletype = \"FJgood,genome\"\n        ## if left not the same, then compare right\n        if IDfiletype == \"FJbad,genomAnomaly\":\n            if lineFJ.chr_right == line2.chr:\n                # print \"right chromosome correct\"\n                if lineFJ.strand_right == \"-\":\n                    # print \"right exon neg\"\n                    if lineFJ.refstrand == line2.refstrand:\n                        # print \"right reference strand correct\"\n                        if int(lineFJ.loc_right) >= int(line2.loc):\n                            # print \"location correct\"\n                            IDfiletype = \"FJgood,genome\"\n                elif lineFJ.strand_right == \"+\":\n                    # print \" right strand pos\"\n                    if lineFJ.refstrand != line2.refstrand:\n                        # print \"right ref strand correct\"\n                        if int(lineFJ.loc_right) <= int(line2.loc):\n                            # print \"right exon location correct\"\n                            IDfiletype = \"FJgood,genome\"\n\n        if IDfiletype == \"FJgood,genome\":\n            TargetDict[lineFJ.junction][0] += 1\n            addAS = lineFJ.AS + line2.AS\n            addNumofBases = lineFJ.NumOfBases + line2.NumOfBases\n        else:\n            TargetDict[lineFJ.junction][1] += 1\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n        IDfile.write(line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"unaligned\":\n        if lineFJ.ID not in FJDict:\n            try:\n                TargetDict[lineFJ.junction][0] += 1\n            except:\n                print lineFJ.junction\n                print TargetDict[lineFJ.junction]\n                print line_raw_comparison\n\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        IDfiletype = \"unaligned\"\n        IDfile.write(line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\n\")\n\n    return TargetDict\n\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\n## actual MM - round up to nearest integer = X\n## expected MM  - no need to round = lambda\n## return 1- poisson.cdf(X, lambda)\n\ndef Pvalue(AS, NumBases):\n    ExpectedMMrate = 0.01\n    ExpectedMM = ExpectedMMrate * float(NumBases)\n    if NumBases == 0.0:\n        return \"-\"\n    ActualMM = int(ceil(float(AS) / (-6.0)))\n    prob = 1 - poisson.cdf(ActualMM, ExpectedMM)\n    return prob\n\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\n\nclass ReadInfoGenome:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.chr = line[2]\n        self.loc = line[3]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\nclass ReadInfoJunc:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.chr = line[2].split(\"|\")[0]\n        self.loc_1 = line[2].replace(\":\", \"|\").split(\"|\")[2]\n        self.loc_2 = line[2].replace(\":\", \"|\").split(\"|\")[4]\n        self.strand = line[2][-1]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\n# =========================================\n# start here\n\nparser = argparse.ArgumentParser()\n#parser.add_argument(\"-s\", \"--stem\", required=True, help=\"stem name of file to generate report\")\n#parser.add_argument(\"-f\", \"--FJDir\", required=True, help=\"path to aligned junction reads\")\n#parser.add_argument(\"-i\", \"--origDir\", required=True, help=\"path to orig dir containing genome reads\")\n\nparser.add_argument(\"-w\", \"--window\", required=True, help=\"# of bases needed on each side of the junction\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\n\nparser.add_argument(\"-gens1\", \"--genomeSAM1\", required=True, help=\"read1 to genome\")\nparser.add_argument(\"-gens2\", \"--genomeSAM2\", required=True, help=\"read2 to genome\")\nparser.add_argument(\"-regs1\", \"--regularSAM1\", required=True, help=\"read1 to regular junction\")\nparser.add_argument(\"-regs2\", \"--regularSAM2\", required=True, help=\"read2 to regular junction\")\nparser.add_argument(\"-scrs1\", \"--scrambledSAM1\", required=True, help=\"read1 to ribosomal junction\")\nparser.add_argument(\"-scrs2\", \"--scrambledSAM2\", required=True, help=\"read2 to ribosomal junction\")\nparser.add_argument(\"-fusj1\", \"--fusionJuncSAM1\", required=True, help=\"unaligned reads1 to fusion junctions\")\nparser.add_argument(\"-fusj2\", \"--fusionJuncSAM2\", required=True, help=\"unaligned reads2 to fusion junctions\")\n\nparser.add_argument(\"-unfq1\", \"--unalignedFQ1\", required=True, help=\"unaligned reads 1\")\nparser.add_argument(\"-unfq2\", \"--unalignedFQ2\", required=True, help=\"unaligned reads 2\")\n\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\n\n\nargs = parser.parse_args()\nwindow = int(args.window)\n\njunction_length = int(args.farJunctionLength)\n\nf1_FarJunc = open(args.fusionJuncSAM1, mode = \"rB\")\nf2_FarJunc = open(args.fusionJuncSAM2, mode = \"rB\")\n\nf1_genome = open(args.genomeSAM1, mode = \"rB\")\nf2_genome = open(args.genomeSAM2, mode = \"rB\")\n\nf1_reg = open(args.regularSAM1, mode = \"rB\")\nf2_reg = open(args.regularSAM2, mode = \"rB\")\n\nf1_junc = open(args.scrambledSAM1, mode = \"rB\")\nf2_junc = open(args.scrambledSAM2, mode = \"rB\")\n\nf1_unaligned = open(args.unalignedFQ1, mode = \"rB\")\nf2_unaligned = open(args.unalignedFQ2, mode = \"rB\")\n\n\n\n\n# ID file ReadID and different buckets.\n# [0] = readID\n# [1] = R2 in genome\n# [2] = R2 in genome anomaly\n# [3] = reg\n# [4] = reg anom\n# [5] = junc\n# [6] = junc anom\n# [7] = FarJunc\n# [8] = FarJunc anom\n# [9] = unaligned\n# [10] = unmapped\n\n\n#IDfile = open(args.FJDir + \"reports/temp_IDs_\" + stem + \".txt\", mode=\"w\")\nIDfile = open(\"temp_IDs_\" + args.sample + \".txt\", mode=\"w\")\n\nIDfile.write(\n    \"ID\\tclass\\tR1_offset\\tR1_MAPQ\\tR1_adjAS\\tR1_NumN\\tR1_Readlength\\tR1_JuncName\\tR1_strand\\tR2_offset\\tR2_MAPQ\\tR2_adjAS\\tR2_NumN\\tR2_Readlength\\tR2_JuncName\\tR2_strand\\n\")\n\n# populate all reads and junctions into separate dictionaries\nAllFJRead1 = {}\nAllFJRead2 = {}\nAllJunctions = {}\ngenomeDict = {}  # for all these dictionaries, [0] = reg, [1] = anom\nregDict = {}  # [2] = sum of AS, [3] = read length\njuncDict = {}\nFJDict = {}\nunalignedDict = {}\nunmappedDict = {}  # start with all readIDs.  if a partner is seen, then remove from list.\n\n# populate AllFJRead1 dictionary - all read 1's from FarJunction alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening FarJunc _1 file\"\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\n\nfor line_raw in f1_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n\n    FJ1read = ReadInfoFJ(line_raw)\n    if FJ1read.offset <= (junction_length/2 - window) and (FJ1read.offset + FJ1read.NumOfBases) >= junction_length/2 + window:\n        goodlinecounter += 1\n        # Dict AllFJRead1 contains key = read ID of all FJ R1\n        # Value = [ FJ read info, indicator of which library the R2 is in]\n        # indicator = 0 if no R2 detected\n        # indicator = FJ if R2 in FJ, genome if R2 in genome, reg if r2 in reg, etc...\n        AllFJRead1[FJ1read.ID] = [line_raw, 0]\n        if FJ1read.junction not in AllJunctions:\n            AllJunctions[FJ1read.junction] = 0\n            newjunccounter += 1\n        AllJunctions[FJ1read.junction] += 1\n        unmappedDict[FJ1read.ID] = FJ1read.junction\n\nf1_FarJunc.close()\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\n\nIDfile.flush()\n\n# populate AllFJRead2 dictionary - all read 2's from FarJunc alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening farJunc _2 file\"\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\noverlapwithFJ1 = 0\n\nfor line_raw in f2_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n    FJ2read = ReadInfoFJ(line_raw)\n\n    #    if FJ1read.junction==\"chr1:S100A4:153516097:-|chr1:IFI16:158985661:+|strandcross\":\n    #        print \"ERROR AT LINE 409\"\n\n    # if R1 and R2 both in Far Junc, then add to FJ-FJ list\n    if FJ2read.ID in AllFJRead1:\n        overlapwithFJ1 += 1\n        # print \"found FJ read\"\n        # AllFJRead1[FJ2read.ID][1]=\"FJ\"\n        if FJ2read.offset <= (junction_length/2 - window) and (FJ2read.offset + FJ2read.NumOfBases) >= junction_length/2 + window and \\\n                        AllFJRead1[FJ2read.ID][1] == 0:\n            FJDict = AddToDict(\"FJ\", FJDict, line_raw, AllFJRead1[FJ2read.ID][0])\n\n            AllFJRead1[FJ2read.ID][1] = \"FJ\"\n            if FJ2read.ID in unmappedDict:\n                del unmappedDict[FJ2read.ID]\n                # otherwise add to F2 read\n    else:\n        if FJ2read.offset <= (junction_length/2 - window) and (FJ2read.offset + FJ2read.NumOfBases) >= junction_length/2 + window:\n            goodlinecounter += 1\n            AllFJRead2[FJ2read.ID] = [line_raw, 0]\n            unmappedDict[FJ2read.ID] = FJ2read.junction\n            if FJ2read.junction not in AllJunctions:\n                newjunccounter += 1\n                AllJunctions[FJ2read.junction] = 0\n\n            AllJunctions[FJ2read.junction] += 1\nf2_FarJunc.close()\n\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\nprint \"overlapping with FJ1 \" + str(overlapwithFJ1)\nIDfile.flush()\n\n# compare FJ read 1 to genome read 2\nfor line_raw in f2_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g2read = ReadInfoGenome(line_raw)\n\n    if g2read.ID in AllFJRead1 and AllFJRead1[g2read.ID][1] == 0:\n        # print \"found genome R2\"+ g2read.ID\n        if g2read.ID in unmappedDict:\n            del unmappedDict[g2read.ID]\n        genomeDict = AddToDict(\"genome\", genomeDict, line_raw, AllFJRead1[g2read.ID][0])\n        AllFJRead1[g2read.ID][1] = \"genome\"\n\nf2_genome.close()\nIDfile.flush()\n\n# compare FJ read 2 to genome read 1\n\nfor line_raw in f1_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g1read = ReadInfoGenome(line_raw)\n\n    if g1read.ID in AllFJRead2 and AllFJRead2[g1read.ID][1] == 0:\n        # print \"found genome R1\"+g1read.ID\n        if g1read.ID in unmappedDict:\n            del unmappedDict[g1read.ID]\n        genomeDict = AddToDict(\"genome\", genomeDict, line_raw, AllFJRead2[g1read.ID][0])\n        AllFJRead2[g1read.ID][1] = \"genome\"\nf1_genome.close()\nIDfile.flush()\n\n# compare FJ read 1 to reg read 2\nfor line_raw in f2_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg2read = ReadInfoJunc(line_raw)\n\n    if reg2read.offset <= (junction_length/2 - window) and (reg2read.offset + reg2read.NumOfBases) >= (junction_length/2 + window):\n        if reg2read.ID in AllFJRead1:\n            if AllFJRead1[reg2read.ID][1] == 0 or AllFJRead1[reg2read.ID][1] == \"genome\":\n                # print \"found reg R2\" + reg2read.ID\n                if reg2read.ID in unmappedDict:\n                    del unmappedDict[reg2read.ID]\n                regDict = AddToDict(\"reg\", regDict, line_raw, AllFJRead1[reg2read.ID][0])\n                AllFJRead1[reg2read.ID][1] = \"reg\"\nf2_reg.close()\nIDfile.flush()\n\n# compare FJ read 2 to reg read 1\n\nfor line_raw in f1_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg1read = ReadInfoJunc(line_raw)\n\n    if reg1read.offset <= (junction_length/2 - window) and (reg1read.offset + reg1read.NumOfBases) >= (junction_length/2 + window):\n        if reg1read.ID in AllFJRead2:\n            if AllFJRead2[reg1read.ID][1] == 0 or AllFJRead2[reg1read.ID][1] == \"genome\":\n                # print \"found reg R1: \" + reg1read.ID\n                if reg1read.ID in unmappedDict:\n                    del unmappedDict[reg1read.ID]\n                regDict = AddToDict(\"reg\", regDict, line_raw, AllFJRead2[reg1read.ID][0])\n                AllFJRead2[reg1read.ID][1] = \"reg\"\nf1_reg.close()\nIDfile.flush()\n\n# compare FJ read 1 to junc read 2\nfor line_raw in f2_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc2read = ReadInfoJunc(line_raw)\n\n    if junc2read.offset <= (junction_length/2 - window) and (junc2read.offset + junc2read.NumOfBases) >= (junction_length/2 + window):\n        if junc2read.ID in AllFJRead1 and AllFJRead1[junc2read.ID][1] == 0:\n            # print \"found junc R2 \" + junc2read.ID\n            if junc2read.ID in unmappedDict:\n                del unmappedDict[junc2read.ID]\n            juncDict = AddToDict(\"junc\", juncDict, line_raw, AllFJRead1[junc2read.ID][0])\n            AllFJRead1[junc2read.ID][1] = \"junc\"\nf2_junc.close()\nIDfile.flush()\n\n# compare FJ read 2 to junc read 1\nfor line_raw in f1_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc1read = ReadInfoJunc(line_raw)\n\n    if junc1read.offset <= (junction_length/2 - window) and (junc1read.offset + junc1read.NumOfBases) >= (junction_length/2 + window):\n        if junc1read.ID in AllFJRead2 and AllFJRead2[junc1read.ID][1] == 0:\n            # print \"found junc R1: \" + junc1read.ID\n            if junc1read.ID in unmappedDict:\n                del unmappedDict[junc1read.ID]\n            juncDict = AddToDict(\"junc\", juncDict, line_raw, AllFJRead2[junc1read.ID][0])\n            AllFJRead2[junc1read.ID][1] = \"junc\"\nf1_junc.close()\nIDfile.flush()\n\n# compare FJ read 1 to unaligned read 2\n\nfor line_raw in f2_unaligned:\n    if line_raw[0] == \"@\":\n        readID = line_raw.strip().split(\" \")[0][1:]\n        readID = ID(readID)\n        if readID in AllFJRead1 and AllFJRead1[readID][1] == 0:\n            if readID in unmappedDict:\n                del unmappedDict[readID]\n            unalignedDict = AddToDict(\"unaligned\", unalignedDict, line_raw, AllFJRead1[readID][0])\n            AllFJRead1[readID][1] = \"unaligned\"\nf2_unaligned.close()\nIDfile.flush()\n\n# compare FJ read 2 to unaligned read 1\n\nfor line_raw in f1_unaligned:\n    if line_raw[0] == \"@\":\n        readID = line_raw.strip().split(\" \")[0][1:]\n        readID = ID(readID)\n        if readID in AllFJRead2 and AllFJRead2[readID][1] == 0:\n            if readID in unmappedDict:\n                del unmappedDict[readID]\n            unalignedDict = AddToDict(\"unaligned\", unalignedDict, line_raw, AllFJRead2[readID][0])\n            AllFJRead2[readID][1] = \"unaligned\"\nf1_unaligned.close()\nIDfile.flush()\n\n# output header\n#outputfile = \"reports/\" + stem + \"_naive_report.txt\"\n#fout = open(args.FJDir + outputfile, mode=\"w\")\n#print \"fout: \" + args.FJDir + outputfile\n\nfout = open(args.sample + \"_naive_report.txt\", mode=\"w\")\n\nfout.write(\"@Junction\\tgenome\\tgenome-anomaly\\tgenome-pval\\treg\\treg-anomaly\\treg-pval\\tjunc\\tjunc-anom\\tjunc-pval\\tFarJunc\\tFarJunc-anom\\tFarJunc-pval\\tunaligned\\tNoPartner\\tNetPValue\\n\")\n\nfor key in unmappedDict:\n    IDfile.write(key + \"\\t\" + unmappedDict[key] + \"\\tUnmapped\\n\")\nIDfile.close()\n#\n#\n### TESTING MODE - SEE WHAT ALLFJREAD1 and 2 FILE SHOW\n# AllReadOutfile=open(\"AllJuncDict.txt\", mode=\"w\")\n#\n# AllReadOutfile.write(\"AllFJRead1:\\n\")\n#\n# for key in AllFJRead1:\n#    AllReadOutfile.write(key+\"\\t\"+str(AllFJRead1[key][1])+\"\\n\")\n#\n#\n# AllReadOutfile.write(\"AllFJRead2:\\n\")\n#\n# for key in AllFJRead2:\n#    AllReadOutfile.write(key+\"\\t\"+str(AllFJRead2[key][1])+\"\\n\")\n#\n# AllReadOutfile.close()\n#\n\n\n## WRITE ALL JUNCTIONS\nfor key in AllJunctions:\n\n    for dict in [genomeDict, regDict, juncDict, FJDict, unalignedDict]:\n        if key not in dict:\n            dict[key] = [0, 0, 0.0, 0.0]\n\n    NumUnmapped = Counter(unmappedDict.values())[key]\n    # calculates P value for all genome/reg/junc/FJ dicts combined, excluding all anomalous reads\n    NetAS = genomeDict[key][2] + regDict[key][2] + juncDict[key][2] + FJDict[key][2]\n    NetNumBases = genomeDict[key][3] + regDict[key][3] + juncDict[key][3] + FJDict[key][3]\n    NetP = Pvalue(NetAS, NetNumBases)\n\n    # writing to output file\n    fout.write(key + \"\\t\")  # write junction [0]\n    fout.write(str(genomeDict[key][0]) + \"\\t\")  # [1]  number of make-sense maps in genome\n    fout.write(str(genomeDict[key][1]) + \"\\t\")  # [2]  nonsense maps in genome\n    fout.write(str(Pvalue(genomeDict[key][2], genomeDict[key][3])) + \"\\t\")  # [3] p value for genome reads\n    fout.write(str(regDict[key][0]) + \"\\t\")  # [4]  number of make-sense maps in reg\n    fout.write(str(regDict[key][1]) + \"\\t\")  # [5]  nonsense maps in reg\n    fout.write(str(Pvalue(regDict[key][2], regDict[key][3])) + \"\\t\")  # [6] p value for reg reads\n    fout.write(str(juncDict[key][0]) + \"\\t\")  # [7]  number of make-sense maps in junc\n    fout.write(str(juncDict[key][1]) + \"\\t\")  # [8]  nonsense maps in junc\n    fout.write(str(Pvalue(juncDict[key][2], juncDict[key][3])) + \"\\t\")  # [9] p value for junc reads\n    fout.write(str(FJDict[key][0]) + \"\\t\")  # [10]  number of make-sense maps in FJ\n    fout.write(str(FJDict[key][1]) + \"\\t\")  # [11]  nonsense maps in FJ\n    fout.write(str(Pvalue(FJDict[key][2], FJDict[key][3])) + \"\\t\")  # [12] p value for FJ reads\n    fout.write(str(unalignedDict[key][0]) + \"\\t\")  # [13]  number junctions whose partner was unaligned\n    fout.write(str(NumUnmapped) + \"\\t\")  # [14] - no read partner in any of the files.\n    fout.write(str(NetP) + \"\\n\")  # [15] net P value of all non-anomalous reads\nfout.close()\n\n# takes alignments from Far Junctions and finds read partner.\n# tells if read partner makes sense or not\n# final Output categories -- [0] R1 junc name\n#   [1] genome - R2 location < 100mill bp away\n#   [2] genome anomaly - R2 location > 100mill bp away\n#   [3] genome p value\n#   [4] reg - R2 closest location <100mill bp away\n#   [5] reg anomaly - R2 closest location > 100mill bp away\n#   [6] reg p value\n#   [7] junc / scrambled - R2 closest location <100mill bp away\n#   [8] junc anomaly - R2 closest location > 100mill bp away\n#   [9] junc p value\n#   [10] FarJunc - R2 aligned to same FarJunc\n#   [11] FarJunc anomaly - R2 aligned to diff FarJunc\n#   [12] FarJunc p value\n#   [13] unaligned - R2 didn't align\n#   [14] unmapped - R2 missing\n#  [15] P value for all non-anomaly classes\n\n\n\n\n#############################################################################\n## This section of code takes the written ID file above (temp_IDs_STEM.txt) and\n## removes duplicate entries of genome and reg. The same readID may be found\n## in both libraries and would both be in the ID file.\n## The new ID file removes duplicates and only keeps the readID with the\n## best alignment score.\ntempIDfile = open(\"temp_IDs_\" + args.sample + \".txt\", mode=\"rU\")\nnewIDfile = open(\"IDs_\" + args.sample + \".txt\", mode=\"w\")\n\n##grep col 2 for \"genom\", \"Regular\" or \"RegAnomaly\". if not found ,write to\n## new file immediately.\n## if found, feed into dictionary (key=readID, value= entire line from temp file)\n## if duplicate entry, then compare R2 AS. if AS larger, then replace\n## value with new value from new R2\n## at completion of file, write entire dictionary into new ID file.\n\nGenomeAndRegReadIDs = {}\n\nfor line in tempIDfile:\n    line = line.strip()\n    if \"unaligned\" in line:\n        continue\n\n    if \"Unmapped\" in line:\n        continue\n\n    readID = line.split(\"\\t\")[0]\n    classID = line.split(\"\\t\")[1]\n    AS_new = line.split(\"\\t\")[11]\n\n    if \"genom\" in classID:\n        ## if readID has been seen previously, then replace value in dictionary\n        ## only if AS is greater.\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"Regular\" in classID:\n        ## do the same if reg\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"RegAnomaly\" in classID:\n        ## do the same if reg anomaly\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    else:\n        ## if not genome/genome anomaly/ reg/ reg anomaly then\n        ## write line directly in new file.\n        newIDfile.write(line + \"\\n\")\n\nfor entry in GenomeAndRegReadIDs:\n    newIDfile.write(GenomeAndRegReadIDs[entry] + \"\\n\")\n\ntempIDfile.close()\nnewIDfile.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "mode": "complete",
            "junction_length": 0,
            "window": 7,
            "unaligned_fq": [
              {
                "path": "/path/to/unaligned_fq-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/unaligned_fq-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "regular_sam": [
              {
                "path": "/path/to/regular_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/regular_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "genome_sam": [
              {
                "path": "/path/to/genome_sam_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/genome_sam_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "fusion_junction_sam": [
              {
                "path": "/path/to/fusion_junction_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/fusion_junction_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "scrambled_sam": [
              {
                "path": "/path/to/scambled_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/scambled_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433633,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": null,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedOn": 1520433651,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "revision 12 copied",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedOn": 1532513542,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2
          },
          {
            "sbg:modifiedOn": 1532515924,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 3
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*naive_report.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#naive_report"
          },
          {
            "outputBinding": {
              "glob": "IDs*.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#IDs"
          }
        ],
        "label": "MACHETE FarJuncNaiveReport",
        "sbg:latestRevision": 3,
        "sbg:revisionNotes": "junction_length parameter added",
        "y": 359.4139721113468,
        "inputs": [
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "id": "#window",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-w"
            },
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.unaligned_fq)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -unfq1 \" + inputs[i].path\n        else\n          cmd += \" -unfq2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#unaligned_fq",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrs1 \" + inputs[i].path\n        else\n          cmd += \" -scrs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#scrambled_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regs1 \" + inputs[i].path\n        else\n          cmd += \" -regs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#regular_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "id": "#mode",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-m"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gens1 \" + inputs[i].path\n        else\n          cmd += \" -gens2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#genome_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -fusj1 \" + inputs[i].path\n        else\n          cmd += \" -fusj2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#fusion_junction_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "FarJuncNaiveReport.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 3,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520433633
      },
      "inputs": [
        {
          "id": "#MACHETE_FarJuncNaiveReport.window",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport.unaligned_fq",
          "source": [
            "#getUnalignedReads_1.unaligned_fastq",
            "#getUnalignedReads_2.unaligned_fastq"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport.scrambled_sam",
          "source": [
            "#getUnalignedReads_2.mate_scrambled_sam",
            "#getUnalignedReads_1.mate_scrambled_sam"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport.regular_sam",
          "source": [
            "#getUnalignedReads_2.mate_regular_sam",
            "#getUnalignedReads_1.mate_regular_sam"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport.junction_length",
          "default": 300
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport.genome_sam",
          "source": [
            "#getUnalignedReads_1.mate_genome_sam",
            "#getUnalignedReads_2.mate_genome_sam"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport.fusion_junction_sam",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_FarJuncNaiveReport.naive_report"
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport.IDs"
        }
      ],
      "sbg:x": 3499.331850466553,
      "sbg:y": 359.4139721113468
    },
    {
      "id": "#MACHETE_FarJuncJustNaiveReport",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python FarJuncJustNaiveReport.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/farjuncjustnaivereport/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 2778.19502209432,
        "id": "milos_jordanski/spachete-salzman-collaboration/farjuncjustnaivereport/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532512528,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "FarJuncJustNaiveReport.py",
                "fileContent": "import argparse\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\"-fusj1\", \"--fusionJuncSAM1\", required=True, help=\"unaligned reads1 to fusion junctions\")\nparser.add_argument(\"-fusj2\", \"--fusionJuncSAM2\", required=True, help=\"unaligned reads2 to fusion junctions\")\nparser.add_argument(\"-w\", \"--window\", required=True, help=\"# of bases needed on each side of the junction\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\n\nargs = parser.parse_args()\n\nwindow = int(args.window)\njunction_length = int(args.farJunctionLength)\n\nf1_FarJunc = open(args.fusionJuncSAM1, mode = \"rB\")\nf2_FarJunc = open(args.fusionJuncSAM2, mode = \"rB\")\n\n\nprint \"opening FarJunc _1 file\"\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\nAllJunctions = {}\nAllFJRead1 = {}\n\nfor line_raw in f1_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n\n    FJ1read = ReadInfoFJ(line_raw)\n    if FJ1read.offset <= (junction_length/2 - window) and (FJ1read.offset + FJ1read.NumOfBases) >= junction_length/2 + window:\n        goodlinecounter += 1\n\n        AllFJRead1[FJ1read.ID] = 0\n        if FJ1read.junction not in AllJunctions:\n            AllJunctions[FJ1read.junction] = 0\n            newjunccounter += 1\n\n\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\noverlapwithFJ1 = 0\n\nfor line_raw in f2_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n    FJ2read = ReadInfoFJ(line_raw)\n\n    #    if FJ1read.junction==\"chr1:S100A4:153516097:-|chr1:IFI16:158985661:+|strandcross\":\n    #        print \"ERROR AT LINE 409\"\n\n    # if R1 and R2 both in Far Junc, then add to FJ-FJ list\n    if FJ2read.ID in AllFJRead1:\n        overlapwithFJ1 += 1\n\n    else:\n        if FJ2read.offset <= (junction_length/2 - window) and (FJ2read.offset + FJ2read.NumOfBases) >= junction_length/2 + window:\n            goodlinecounter += 1\n\n            if FJ2read.junction not in AllJunctions:\n                newjunccounter += 1\n                AllJunctions[FJ2read.junction] = 0\nf2_FarJunc.close()\n\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\nprint \"overlapping with FJ1 \" + str(overlapwithFJ1)\n\nfout = open(args.sample + \"_naive_report.txt\", mode=\"w\")\nfout.write(\"@Junction\\n\")\n\nfor key in AllJunctions:\n    fout.write(key + \"\\n\")"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "mode": "complete",
            "junction_length": 7,
            "fusion_junction_sam": [
              {
                "path": "/path/to/fusion_junction_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/fusion_junction_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "window": 4
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433383,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": null,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedOn": 1520433411,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "revision 5 copied",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedOn": 1532512528,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*naive_report.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#just_naive_report"
          }
        ],
        "label": "MACHETE FarJuncJustNaiveReport",
        "sbg:latestRevision": 2,
        "sbg:revisionNotes": "junction_length parameter added",
        "y": 374.13783664728186,
        "inputs": [
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "id": "#window",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-w"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "id": "#mode",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-m"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -fusj1 \" + inputs[i].path\n        else\n          cmd += \" -fusj2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#fusion_junction_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "FarJuncJustNaiveReport.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520433383
      },
      "inputs": [
        {
          "id": "#MACHETE_FarJuncJustNaiveReport.window",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#MACHETE_FarJuncJustNaiveReport.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#MACHETE_FarJuncJustNaiveReport.junction_length",
          "default": 300
        },
        {
          "id": "#MACHETE_FarJuncJustNaiveReport.fusion_junction_sam",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_FarJuncJustNaiveReport.just_naive_report"
        }
      ],
      "sbg:x": 2778.19502209432,
      "sbg:y": 374.13783664728186
    },
    {
      "id": "#MACHETE_FarJuncNaiveReport_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python FarJuncNaiveReport.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/farjuncnaivereport/3",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 3497.015329123378,
        "id": "milos_jordanski/spachete-salzman-collaboration/farjuncnaivereport/3",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532515924,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "FarJuncNaiveReport.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 16 16:12:27 2015\n\n@author: Gillian\n\"\"\"\n# takes alignments from Far Junctions and finds read partner.\n# all Far Junction and Scrambled junction reads where the alignment does not overlap the\n# Junction by args.window bp will be thrown out.\n\n## Also creates class input files for Far Junctions (R1 = FJ, R2 = something else)\n\n# This program then tells if read partners \"makes sense\" or not\n# final Output categories -- [0] R1 junc name\n#   [1] genome - R2 location < 100mill bp away\n#   [2] genome anomaly - R2 location > 100mill bp away\n#   [3] genome p value\n#   [4] reg - R2 closest location <100mill bp away\n#   [5] reg anomaly - R2 closest location > 100 mill bp away\n#   [6] reg p value\n#   [7] junc / scrambled - R2 closest location <100mill bp away\n#   [8] junc anomaly - R2 closest location > 100mill bp away\n#   [9] junc p value\n#   [10] FarJunc - R2 aligned to same FarJunc\n#   [11] FarJunc anomaly - R2 aligned to diff FarJunc\n#   [12] FarJunc p value\n#   [13] unaligned - R2 didn't align\n#   [14] unmapped - R2 missing in action\n#   [15] P val for all non-anomaly classes\n\n\n\n################\n# Current categories\n# FJgood -- genome, reg, FJ\n# FJbad -- genome anomaly, reg anomaly, junc, junc anomaly, FJ anomaly\n#################\n\n\n\nimport argparse\nimport os\nimport glob\nfrom math import ceil\nfrom scipy.stats import poisson\nfrom collections import Counter\n\n\ndef AddToDict(inputtype, TargetDict, line_raw_comparison, line_raw_FJ):\n    lineFJ = ReadInfoFJ(line_raw_FJ)\n    #    if lineFJ.junction==\"chr1:S100A4:153516097:-|chr1:IFI16:158985661:+|strandcross\":\n    #        print \"ERROR AT LINE 42\"\n    #        print inputtype\n    #        print line_raw_comparison\n    #        print line_raw_FJ\n    #\n\n    if lineFJ.junction not in TargetDict:  # add junction to target dictionary if it doesn't exist\n        TargetDict[lineFJ.junction] = [0, 0, 0.0, 0.0]\n\n    if inputtype == \"FJ\":  # if comparing Far Junc to Far Junc, they have to be identical\n        line2 = ReadInfoFJ(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        addAS = lineFJ.AS + line2.AS\n        addNumofBases = lineFJ.NumOfBases + line2.NumOfBases\n\n        if lineFJ.junction == line2.junction and lineFJ.refstrand != line2.refstrand:\n            TargetDict[lineFJ.junction][0] += 1\n            IDfiletype = \"FJgood,FarJunction\"\n        else:\n            TargetDict[lineFJ.junction][1] += 1\n            IDfiletype = \"FJbad,FarJuncAnom\"\n            addAS = 0.0\n            addNumofBases = 0.0\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"reg\" or inputtype == \"junc\":  # if reg or junc read, then one side has to be within 100KB, and meets refstrand criteria below\n        line2 = ReadInfoJunc(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        if inputtype == \"junc\":\n            IDfiletype = \"FJbad,Junction\"\n            addAS = 0.0\n            addNumofBases = 0.0\n\n        if inputtype == \"reg\":\n            IDfiletype = \"FJbad,RegAnomaly\"\n            addAS = 0.0\n            addNumofBases = 0.0\n\n            if lineFJ.chr_left == line2.chr:\n                if lineFJ.strand_left == line2.strand:\n                    if lineFJ.strand_left == \"-\":\n                        if lineFJ.refstrand == line2.refstrand:\n                            if int(lineFJ.loc_left) <= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular\"\n                    elif lineFJ.strand_left == \"+\":\n                        if lineFJ.refstrand != line2.refstrand:\n                            if int(lineFJ.loc_left) >= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular\"\n            if IDfiletype == \"FJbad,RegAnomaly\":\n                if lineFJ.chr_right == line2.chr:\n                    if lineFJ.strand_right == line2.strand:\n                        if lineFJ.strand_right == \"-\":\n                            if lineFJ.refstrand == line2.refstrand:\n                                if int(lineFJ.loc_right) >= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular\"\n                        elif lineFJ.strand_right == \"+\":\n                            if lineFJ.refstrand != line2.refstrand:\n                                if int(lineFJ.loc_right) <= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular\"\n\n        if IDfiletype == \"FJgood,Regular\":\n            TargetDict[lineFJ.junction][0] += 1\n            addAS = lineFJ.AS + line2.AS\n            addNumofBases = lineFJ.NumOfBases + line2.NumOfBases\n        else:\n            TargetDict[lineFJ.junction][1] += 1\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"genome\":  # comparing FJ to genome, meet ref strand criteria (opp refstrand if + read, same refstrand if - read)\n\n        line2 = ReadInfoGenome(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.loc) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(line2.NumOfBases) + \"\\t\" + line2.chr + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"FJbad,genomAnomaly\"\n        addAS = 0.0\n        addNumofBases = 0.0\n\n        if lineFJ.chr_left == line2.chr:\n            # print \"checking left\"\n            if lineFJ.strand_left == \"-\":\n                # print \"left exon neg\"\n                if lineFJ.refstrand == line2.refstrand:\n                    # print \"left strand reference good\"\n                    if int(lineFJ.loc_left) <= int(line2.loc):\n                        # print \"left exon in expected location\"\n                        IDfiletype = \"FJgood,genome\"\n            elif lineFJ.strand_left == \"+\":\n                # print \"left exon pos\"\n                if lineFJ.refstrand != line2.refstrand:\n                    # print \"left strand good\"\n                    if int(lineFJ.loc_left) >= int(line2.loc):\n                        # print \"left strand location good\"\n                        IDfiletype = \"FJgood,genome\"\n        ## if left not the same, then compare right\n        if IDfiletype == \"FJbad,genomAnomaly\":\n            if lineFJ.chr_right == line2.chr:\n                # print \"right chromosome correct\"\n                if lineFJ.strand_right == \"-\":\n                    # print \"right exon neg\"\n                    if lineFJ.refstrand == line2.refstrand:\n                        # print \"right reference strand correct\"\n                        if int(lineFJ.loc_right) >= int(line2.loc):\n                            # print \"location correct\"\n                            IDfiletype = \"FJgood,genome\"\n                elif lineFJ.strand_right == \"+\":\n                    # print \" right strand pos\"\n                    if lineFJ.refstrand != line2.refstrand:\n                        # print \"right ref strand correct\"\n                        if int(lineFJ.loc_right) <= int(line2.loc):\n                            # print \"right exon location correct\"\n                            IDfiletype = \"FJgood,genome\"\n\n        if IDfiletype == \"FJgood,genome\":\n            TargetDict[lineFJ.junction][0] += 1\n            addAS = lineFJ.AS + line2.AS\n            addNumofBases = lineFJ.NumOfBases + line2.NumOfBases\n        else:\n            TargetDict[lineFJ.junction][1] += 1\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        TargetDict[lineFJ.junction][2] += addAS\n        TargetDict[lineFJ.junction][3] += addNumofBases\n        IDfile.write(line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"unaligned\":\n        if lineFJ.ID not in FJDict:\n            try:\n                TargetDict[lineFJ.junction][0] += 1\n            except:\n                print lineFJ.junction\n                print TargetDict[lineFJ.junction]\n                print line_raw_comparison\n\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(\n            lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction + \"\\t\" + lineFJ.refstrand\n        IDfiletype = \"unaligned\"\n        IDfile.write(line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\n\")\n\n    return TargetDict\n\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\n## actual MM - round up to nearest integer = X\n## expected MM  - no need to round = lambda\n## return 1- poisson.cdf(X, lambda)\n\ndef Pvalue(AS, NumBases):\n    ExpectedMMrate = 0.01\n    ExpectedMM = ExpectedMMrate * float(NumBases)\n    if NumBases == 0.0:\n        return \"-\"\n    ActualMM = int(ceil(float(AS) / (-6.0)))\n    prob = 1 - poisson.cdf(ActualMM, ExpectedMM)\n    return prob\n\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\n\nclass ReadInfoGenome:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.chr = line[2]\n        self.loc = line[3]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\nclass ReadInfoJunc:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.chr = line[2].split(\"|\")[0]\n        self.loc_1 = line[2].replace(\":\", \"|\").split(\"|\")[2]\n        self.loc_2 = line[2].replace(\":\", \"|\").split(\"|\")[4]\n        self.strand = line[2][-1]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\n# =========================================\n# start here\n\nparser = argparse.ArgumentParser()\n#parser.add_argument(\"-s\", \"--stem\", required=True, help=\"stem name of file to generate report\")\n#parser.add_argument(\"-f\", \"--FJDir\", required=True, help=\"path to aligned junction reads\")\n#parser.add_argument(\"-i\", \"--origDir\", required=True, help=\"path to orig dir containing genome reads\")\n\nparser.add_argument(\"-w\", \"--window\", required=True, help=\"# of bases needed on each side of the junction\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\n\nparser.add_argument(\"-gens1\", \"--genomeSAM1\", required=True, help=\"read1 to genome\")\nparser.add_argument(\"-gens2\", \"--genomeSAM2\", required=True, help=\"read2 to genome\")\nparser.add_argument(\"-regs1\", \"--regularSAM1\", required=True, help=\"read1 to regular junction\")\nparser.add_argument(\"-regs2\", \"--regularSAM2\", required=True, help=\"read2 to regular junction\")\nparser.add_argument(\"-scrs1\", \"--scrambledSAM1\", required=True, help=\"read1 to ribosomal junction\")\nparser.add_argument(\"-scrs2\", \"--scrambledSAM2\", required=True, help=\"read2 to ribosomal junction\")\nparser.add_argument(\"-fusj1\", \"--fusionJuncSAM1\", required=True, help=\"unaligned reads1 to fusion junctions\")\nparser.add_argument(\"-fusj2\", \"--fusionJuncSAM2\", required=True, help=\"unaligned reads2 to fusion junctions\")\n\nparser.add_argument(\"-unfq1\", \"--unalignedFQ1\", required=True, help=\"unaligned reads 1\")\nparser.add_argument(\"-unfq2\", \"--unalignedFQ2\", required=True, help=\"unaligned reads 2\")\n\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\n\n\nargs = parser.parse_args()\nwindow = int(args.window)\n\njunction_length = int(args.farJunctionLength)\n\nf1_FarJunc = open(args.fusionJuncSAM1, mode = \"rB\")\nf2_FarJunc = open(args.fusionJuncSAM2, mode = \"rB\")\n\nf1_genome = open(args.genomeSAM1, mode = \"rB\")\nf2_genome = open(args.genomeSAM2, mode = \"rB\")\n\nf1_reg = open(args.regularSAM1, mode = \"rB\")\nf2_reg = open(args.regularSAM2, mode = \"rB\")\n\nf1_junc = open(args.scrambledSAM1, mode = \"rB\")\nf2_junc = open(args.scrambledSAM2, mode = \"rB\")\n\nf1_unaligned = open(args.unalignedFQ1, mode = \"rB\")\nf2_unaligned = open(args.unalignedFQ2, mode = \"rB\")\n\n\n\n\n# ID file ReadID and different buckets.\n# [0] = readID\n# [1] = R2 in genome\n# [2] = R2 in genome anomaly\n# [3] = reg\n# [4] = reg anom\n# [5] = junc\n# [6] = junc anom\n# [7] = FarJunc\n# [8] = FarJunc anom\n# [9] = unaligned\n# [10] = unmapped\n\n\n#IDfile = open(args.FJDir + \"reports/temp_IDs_\" + stem + \".txt\", mode=\"w\")\nIDfile = open(\"temp_IDs_\" + args.sample + \".txt\", mode=\"w\")\n\nIDfile.write(\n    \"ID\\tclass\\tR1_offset\\tR1_MAPQ\\tR1_adjAS\\tR1_NumN\\tR1_Readlength\\tR1_JuncName\\tR1_strand\\tR2_offset\\tR2_MAPQ\\tR2_adjAS\\tR2_NumN\\tR2_Readlength\\tR2_JuncName\\tR2_strand\\n\")\n\n# populate all reads and junctions into separate dictionaries\nAllFJRead1 = {}\nAllFJRead2 = {}\nAllJunctions = {}\ngenomeDict = {}  # for all these dictionaries, [0] = reg, [1] = anom\nregDict = {}  # [2] = sum of AS, [3] = read length\njuncDict = {}\nFJDict = {}\nunalignedDict = {}\nunmappedDict = {}  # start with all readIDs.  if a partner is seen, then remove from list.\n\n# populate AllFJRead1 dictionary - all read 1's from FarJunction alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening FarJunc _1 file\"\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\n\nfor line_raw in f1_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n\n    FJ1read = ReadInfoFJ(line_raw)\n    if FJ1read.offset <= (junction_length/2 - window) and (FJ1read.offset + FJ1read.NumOfBases) >= junction_length/2 + window:\n        goodlinecounter += 1\n        # Dict AllFJRead1 contains key = read ID of all FJ R1\n        # Value = [ FJ read info, indicator of which library the R2 is in]\n        # indicator = 0 if no R2 detected\n        # indicator = FJ if R2 in FJ, genome if R2 in genome, reg if r2 in reg, etc...\n        AllFJRead1[FJ1read.ID] = [line_raw, 0]\n        if FJ1read.junction not in AllJunctions:\n            AllJunctions[FJ1read.junction] = 0\n            newjunccounter += 1\n        AllJunctions[FJ1read.junction] += 1\n        unmappedDict[FJ1read.ID] = FJ1read.junction\n\nf1_FarJunc.close()\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\n\nIDfile.flush()\n\n# populate AllFJRead2 dictionary - all read 2's from FarJunc alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening farJunc _2 file\"\n\nlinecounter = 0\nnewjunccounter = 0\ngoodlinecounter = 0\noverlapwithFJ1 = 0\n\nfor line_raw in f2_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n    linecounter += 1\n    FJ2read = ReadInfoFJ(line_raw)\n\n    #    if FJ1read.junction==\"chr1:S100A4:153516097:-|chr1:IFI16:158985661:+|strandcross\":\n    #        print \"ERROR AT LINE 409\"\n\n    # if R1 and R2 both in Far Junc, then add to FJ-FJ list\n    if FJ2read.ID in AllFJRead1:\n        overlapwithFJ1 += 1\n        # print \"found FJ read\"\n        # AllFJRead1[FJ2read.ID][1]=\"FJ\"\n        if FJ2read.offset <= (junction_length/2 - window) and (FJ2read.offset + FJ2read.NumOfBases) >= junction_length/2 + window and \\\n                        AllFJRead1[FJ2read.ID][1] == 0:\n            FJDict = AddToDict(\"FJ\", FJDict, line_raw, AllFJRead1[FJ2read.ID][0])\n\n            AllFJRead1[FJ2read.ID][1] = \"FJ\"\n            if FJ2read.ID in unmappedDict:\n                del unmappedDict[FJ2read.ID]\n                # otherwise add to F2 read\n    else:\n        if FJ2read.offset <= (junction_length/2 - window) and (FJ2read.offset + FJ2read.NumOfBases) >= junction_length/2 + window:\n            goodlinecounter += 1\n            AllFJRead2[FJ2read.ID] = [line_raw, 0]\n            unmappedDict[FJ2read.ID] = FJ2read.junction\n            if FJ2read.junction not in AllJunctions:\n                newjunccounter += 1\n                AllJunctions[FJ2read.junction] = 0\n\n            AllJunctions[FJ2read.junction] += 1\nf2_FarJunc.close()\n\nprint \"lines \" + str(linecounter)\nprint \"good lines \" + str(goodlinecounter)\nprint \"independent juncs\" + str(newjunccounter)\nprint \"overlapping with FJ1 \" + str(overlapwithFJ1)\nIDfile.flush()\n\n# compare FJ read 1 to genome read 2\nfor line_raw in f2_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g2read = ReadInfoGenome(line_raw)\n\n    if g2read.ID in AllFJRead1 and AllFJRead1[g2read.ID][1] == 0:\n        # print \"found genome R2\"+ g2read.ID\n        if g2read.ID in unmappedDict:\n            del unmappedDict[g2read.ID]\n        genomeDict = AddToDict(\"genome\", genomeDict, line_raw, AllFJRead1[g2read.ID][0])\n        AllFJRead1[g2read.ID][1] = \"genome\"\n\nf2_genome.close()\nIDfile.flush()\n\n# compare FJ read 2 to genome read 1\n\nfor line_raw in f1_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g1read = ReadInfoGenome(line_raw)\n\n    if g1read.ID in AllFJRead2 and AllFJRead2[g1read.ID][1] == 0:\n        # print \"found genome R1\"+g1read.ID\n        if g1read.ID in unmappedDict:\n            del unmappedDict[g1read.ID]\n        genomeDict = AddToDict(\"genome\", genomeDict, line_raw, AllFJRead2[g1read.ID][0])\n        AllFJRead2[g1read.ID][1] = \"genome\"\nf1_genome.close()\nIDfile.flush()\n\n# compare FJ read 1 to reg read 2\nfor line_raw in f2_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg2read = ReadInfoJunc(line_raw)\n\n    if reg2read.offset <= (junction_length/2 - window) and (reg2read.offset + reg2read.NumOfBases) >= (junction_length/2 + window):\n        if reg2read.ID in AllFJRead1:\n            if AllFJRead1[reg2read.ID][1] == 0 or AllFJRead1[reg2read.ID][1] == \"genome\":\n                # print \"found reg R2\" + reg2read.ID\n                if reg2read.ID in unmappedDict:\n                    del unmappedDict[reg2read.ID]\n                regDict = AddToDict(\"reg\", regDict, line_raw, AllFJRead1[reg2read.ID][0])\n                AllFJRead1[reg2read.ID][1] = \"reg\"\nf2_reg.close()\nIDfile.flush()\n\n# compare FJ read 2 to reg read 1\n\nfor line_raw in f1_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg1read = ReadInfoJunc(line_raw)\n\n    if reg1read.offset <= (junction_length/2 - window) and (reg1read.offset + reg1read.NumOfBases) >= (junction_length/2 + window):\n        if reg1read.ID in AllFJRead2:\n            if AllFJRead2[reg1read.ID][1] == 0 or AllFJRead2[reg1read.ID][1] == \"genome\":\n                # print \"found reg R1: \" + reg1read.ID\n                if reg1read.ID in unmappedDict:\n                    del unmappedDict[reg1read.ID]\n                regDict = AddToDict(\"reg\", regDict, line_raw, AllFJRead2[reg1read.ID][0])\n                AllFJRead2[reg1read.ID][1] = \"reg\"\nf1_reg.close()\nIDfile.flush()\n\n# compare FJ read 1 to junc read 2\nfor line_raw in f2_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc2read = ReadInfoJunc(line_raw)\n\n    if junc2read.offset <= (junction_length/2 - window) and (junc2read.offset + junc2read.NumOfBases) >= (junction_length/2 + window):\n        if junc2read.ID in AllFJRead1 and AllFJRead1[junc2read.ID][1] == 0:\n            # print \"found junc R2 \" + junc2read.ID\n            if junc2read.ID in unmappedDict:\n                del unmappedDict[junc2read.ID]\n            juncDict = AddToDict(\"junc\", juncDict, line_raw, AllFJRead1[junc2read.ID][0])\n            AllFJRead1[junc2read.ID][1] = \"junc\"\nf2_junc.close()\nIDfile.flush()\n\n# compare FJ read 2 to junc read 1\nfor line_raw in f1_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc1read = ReadInfoJunc(line_raw)\n\n    if junc1read.offset <= (junction_length/2 - window) and (junc1read.offset + junc1read.NumOfBases) >= (junction_length/2 + window):\n        if junc1read.ID in AllFJRead2 and AllFJRead2[junc1read.ID][1] == 0:\n            # print \"found junc R1: \" + junc1read.ID\n            if junc1read.ID in unmappedDict:\n                del unmappedDict[junc1read.ID]\n            juncDict = AddToDict(\"junc\", juncDict, line_raw, AllFJRead2[junc1read.ID][0])\n            AllFJRead2[junc1read.ID][1] = \"junc\"\nf1_junc.close()\nIDfile.flush()\n\n# compare FJ read 1 to unaligned read 2\n\nfor line_raw in f2_unaligned:\n    if line_raw[0] == \"@\":\n        readID = line_raw.strip().split(\" \")[0][1:]\n        readID = ID(readID)\n        if readID in AllFJRead1 and AllFJRead1[readID][1] == 0:\n            if readID in unmappedDict:\n                del unmappedDict[readID]\n            unalignedDict = AddToDict(\"unaligned\", unalignedDict, line_raw, AllFJRead1[readID][0])\n            AllFJRead1[readID][1] = \"unaligned\"\nf2_unaligned.close()\nIDfile.flush()\n\n# compare FJ read 2 to unaligned read 1\n\nfor line_raw in f1_unaligned:\n    if line_raw[0] == \"@\":\n        readID = line_raw.strip().split(\" \")[0][1:]\n        readID = ID(readID)\n        if readID in AllFJRead2 and AllFJRead2[readID][1] == 0:\n            if readID in unmappedDict:\n                del unmappedDict[readID]\n            unalignedDict = AddToDict(\"unaligned\", unalignedDict, line_raw, AllFJRead2[readID][0])\n            AllFJRead2[readID][1] = \"unaligned\"\nf1_unaligned.close()\nIDfile.flush()\n\n# output header\n#outputfile = \"reports/\" + stem + \"_naive_report.txt\"\n#fout = open(args.FJDir + outputfile, mode=\"w\")\n#print \"fout: \" + args.FJDir + outputfile\n\nfout = open(args.sample + \"_naive_report.txt\", mode=\"w\")\n\nfout.write(\"@Junction\\tgenome\\tgenome-anomaly\\tgenome-pval\\treg\\treg-anomaly\\treg-pval\\tjunc\\tjunc-anom\\tjunc-pval\\tFarJunc\\tFarJunc-anom\\tFarJunc-pval\\tunaligned\\tNoPartner\\tNetPValue\\n\")\n\nfor key in unmappedDict:\n    IDfile.write(key + \"\\t\" + unmappedDict[key] + \"\\tUnmapped\\n\")\nIDfile.close()\n#\n#\n### TESTING MODE - SEE WHAT ALLFJREAD1 and 2 FILE SHOW\n# AllReadOutfile=open(\"AllJuncDict.txt\", mode=\"w\")\n#\n# AllReadOutfile.write(\"AllFJRead1:\\n\")\n#\n# for key in AllFJRead1:\n#    AllReadOutfile.write(key+\"\\t\"+str(AllFJRead1[key][1])+\"\\n\")\n#\n#\n# AllReadOutfile.write(\"AllFJRead2:\\n\")\n#\n# for key in AllFJRead2:\n#    AllReadOutfile.write(key+\"\\t\"+str(AllFJRead2[key][1])+\"\\n\")\n#\n# AllReadOutfile.close()\n#\n\n\n## WRITE ALL JUNCTIONS\nfor key in AllJunctions:\n\n    for dict in [genomeDict, regDict, juncDict, FJDict, unalignedDict]:\n        if key not in dict:\n            dict[key] = [0, 0, 0.0, 0.0]\n\n    NumUnmapped = Counter(unmappedDict.values())[key]\n    # calculates P value for all genome/reg/junc/FJ dicts combined, excluding all anomalous reads\n    NetAS = genomeDict[key][2] + regDict[key][2] + juncDict[key][2] + FJDict[key][2]\n    NetNumBases = genomeDict[key][3] + regDict[key][3] + juncDict[key][3] + FJDict[key][3]\n    NetP = Pvalue(NetAS, NetNumBases)\n\n    # writing to output file\n    fout.write(key + \"\\t\")  # write junction [0]\n    fout.write(str(genomeDict[key][0]) + \"\\t\")  # [1]  number of make-sense maps in genome\n    fout.write(str(genomeDict[key][1]) + \"\\t\")  # [2]  nonsense maps in genome\n    fout.write(str(Pvalue(genomeDict[key][2], genomeDict[key][3])) + \"\\t\")  # [3] p value for genome reads\n    fout.write(str(regDict[key][0]) + \"\\t\")  # [4]  number of make-sense maps in reg\n    fout.write(str(regDict[key][1]) + \"\\t\")  # [5]  nonsense maps in reg\n    fout.write(str(Pvalue(regDict[key][2], regDict[key][3])) + \"\\t\")  # [6] p value for reg reads\n    fout.write(str(juncDict[key][0]) + \"\\t\")  # [7]  number of make-sense maps in junc\n    fout.write(str(juncDict[key][1]) + \"\\t\")  # [8]  nonsense maps in junc\n    fout.write(str(Pvalue(juncDict[key][2], juncDict[key][3])) + \"\\t\")  # [9] p value for junc reads\n    fout.write(str(FJDict[key][0]) + \"\\t\")  # [10]  number of make-sense maps in FJ\n    fout.write(str(FJDict[key][1]) + \"\\t\")  # [11]  nonsense maps in FJ\n    fout.write(str(Pvalue(FJDict[key][2], FJDict[key][3])) + \"\\t\")  # [12] p value for FJ reads\n    fout.write(str(unalignedDict[key][0]) + \"\\t\")  # [13]  number junctions whose partner was unaligned\n    fout.write(str(NumUnmapped) + \"\\t\")  # [14] - no read partner in any of the files.\n    fout.write(str(NetP) + \"\\n\")  # [15] net P value of all non-anomalous reads\nfout.close()\n\n# takes alignments from Far Junctions and finds read partner.\n# tells if read partner makes sense or not\n# final Output categories -- [0] R1 junc name\n#   [1] genome - R2 location < 100mill bp away\n#   [2] genome anomaly - R2 location > 100mill bp away\n#   [3] genome p value\n#   [4] reg - R2 closest location <100mill bp away\n#   [5] reg anomaly - R2 closest location > 100mill bp away\n#   [6] reg p value\n#   [7] junc / scrambled - R2 closest location <100mill bp away\n#   [8] junc anomaly - R2 closest location > 100mill bp away\n#   [9] junc p value\n#   [10] FarJunc - R2 aligned to same FarJunc\n#   [11] FarJunc anomaly - R2 aligned to diff FarJunc\n#   [12] FarJunc p value\n#   [13] unaligned - R2 didn't align\n#   [14] unmapped - R2 missing\n#  [15] P value for all non-anomaly classes\n\n\n\n\n#############################################################################\n## This section of code takes the written ID file above (temp_IDs_STEM.txt) and\n## removes duplicate entries of genome and reg. The same readID may be found\n## in both libraries and would both be in the ID file.\n## The new ID file removes duplicates and only keeps the readID with the\n## best alignment score.\ntempIDfile = open(\"temp_IDs_\" + args.sample + \".txt\", mode=\"rU\")\nnewIDfile = open(\"IDs_\" + args.sample + \".txt\", mode=\"w\")\n\n##grep col 2 for \"genom\", \"Regular\" or \"RegAnomaly\". if not found ,write to\n## new file immediately.\n## if found, feed into dictionary (key=readID, value= entire line from temp file)\n## if duplicate entry, then compare R2 AS. if AS larger, then replace\n## value with new value from new R2\n## at completion of file, write entire dictionary into new ID file.\n\nGenomeAndRegReadIDs = {}\n\nfor line in tempIDfile:\n    line = line.strip()\n    if \"unaligned\" in line:\n        continue\n\n    if \"Unmapped\" in line:\n        continue\n\n    readID = line.split(\"\\t\")[0]\n    classID = line.split(\"\\t\")[1]\n    AS_new = line.split(\"\\t\")[11]\n\n    if \"genom\" in classID:\n        ## if readID has been seen previously, then replace value in dictionary\n        ## only if AS is greater.\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"Regular\" in classID:\n        ## do the same if reg\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"RegAnomaly\" in classID:\n        ## do the same if reg anomaly\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    else:\n        ## if not genome/genome anomaly/ reg/ reg anomaly then\n        ## write line directly in new file.\n        newIDfile.write(line + \"\\n\")\n\nfor entry in GenomeAndRegReadIDs:\n    newIDfile.write(GenomeAndRegReadIDs[entry] + \"\\n\")\n\ntempIDfile.close()\nnewIDfile.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "mode": "complete",
            "junction_length": 0,
            "window": 7,
            "unaligned_fq": [
              {
                "path": "/path/to/unaligned_fq-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/unaligned_fq-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "regular_sam": [
              {
                "path": "/path/to/regular_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/regular_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "genome_sam": [
              {
                "path": "/path/to/genome_sam_files-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/genome_sam_files-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "fusion_junction_sam": [
              {
                "path": "/path/to/fusion_junction_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/fusion_junction_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "scrambled_sam": [
              {
                "path": "/path/to/scambled_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/scambled_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433633,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": null,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedOn": 1520433651,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "revision 12 copied",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedOn": 1532513542,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2
          },
          {
            "sbg:modifiedOn": 1532515924,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 3
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*naive_report.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#naive_report"
          },
          {
            "outputBinding": {
              "glob": "IDs*.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#IDs"
          }
        ],
        "label": "MACHETE FarJuncNaiveReport Known",
        "sbg:latestRevision": 3,
        "sbg:revisionNotes": "junction_length parameter added",
        "y": 881.8289152451889,
        "inputs": [
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "id": "#window",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-w"
            },
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.unaligned_fq)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -unfq1 \" + inputs[i].path\n        else\n          cmd += \" -unfq2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#unaligned_fq",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrs1 \" + inputs[i].path\n        else\n          cmd += \" -scrs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#scrambled_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regs1 \" + inputs[i].path\n        else\n          cmd += \" -regs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#regular_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "id": "#mode",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-m"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gens1 \" + inputs[i].path\n        else\n          cmd += \" -gens2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#genome_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -fusj1 \" + inputs[i].path\n        else\n          cmd += \" -fusj2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#fusion_junction_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "FarJuncNaiveReport.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 3,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520433633
      },
      "inputs": [
        {
          "id": "#MACHETE_FarJuncNaiveReport_Known.window",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport_Known.unaligned_fq",
          "source": [
            "#getUnalignedReads_1.unaligned_fastq",
            "#getUnalignedReads_2.unaligned_fastq"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport_Known.scrambled_sam",
          "source": [
            "#getUnalignedReads_2.mate_scrambled_sam",
            "#getUnalignedReads_1.mate_scrambled_sam"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport_Known.regular_sam",
          "source": [
            "#getUnalignedReads_2.mate_regular_sam",
            "#getUnalignedReads_1.mate_regular_sam"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport_Known.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport_Known.junction_length",
          "default": 300
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport_Known.genome_sam",
          "source": [
            "#getUnalignedReads_2.mate_genome_sam",
            "#getUnalignedReads_1.mate_genome_sam"
          ]
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport_Known.fusion_junction_sam",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.result_sam_file"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_FarJuncNaiveReport_Known.naive_report"
        },
        {
          "id": "#MACHETE_FarJuncNaiveReport_Known.IDs"
        }
      ],
      "sbg:x": 3497.015329123378,
      "sbg:y": 881.8289152451889
    },
    {
      "id": "#MACHETE_AddIndelsToFasta_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python AddIndelsToFasta.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/addindelstofasta/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    \n    if($job.inputs.filtered_fusion_junction.metadata && $job.inputs.filtered_fusion_junction.metadata.sample_id)\n   \t\tcmd = \"-s \" + $job.inputs.filtered_fusion_junction.metadata.sample_id\n\treturn cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 4206.697499276893,
        "id": "milos_jordanski/spachete-salzman-collaboration/addindelstofasta/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532513222,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "AddIndelsToFasta.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Oct 21 15:17:27 2015\n\n@author: Gillian\n\"\"\"\n\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-i\", \"--infile\", required=True, help=\"input file\")\n#parser.add_argument(\"-o\", \"--outDir\", required=True, help=\"output directory\")\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\nparser.add_argument(\"-n\", \"--MaxInDel\", required=True, help=\"# of indels on each side to test\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\n\n#if args.outDir[-1] != \"/\":\n#    args.outDir += \"/\"\n\n# indels are inserted into the FarJunction.fa file\n# insertions are SEQUENCEANNNNNSEQUENCEB where 2N is the number of indels given in the argument parser\n# deletions are SEQA-AAAAA[AAABBB]BBBSEQB where N*AAA and N*BBB are removed from the junction interface.\n# x,..,5, 4, 3, 2, 1 deletions on each side, then 2, 4, 6, 8, 10,.., 2X N's inserted into junction\n\njunction_length = int(args.farJunctionLength)\n\ncounter = 0\nf1 = open(args.infile, mode=\"rU\")\n\nfor i in range(1, int(args.MaxInDel) + 1):\n    f1.seek(0)\n\n    fout = open(args.sample + \"_FJ_Indels_\" + str(i) + \".fa\", mode=\"w\")\n    print \"writing indels\" + str(i) + \".fa\"\n\n    for line_raw in f1:\n\n        counter += 1\n\n        if line_raw[0] == \">\":\n            JunctionName = line_raw.strip()\n            JunctionSeq = \"\"\n\n        else:\n            JunctionSeq += line_raw.strip()\n\n        if len(JunctionSeq) == junction_length:\n            LeftExon = JunctionSeq[0:junction_length/2]\n            RightExon = JunctionSeq[junction_length/2:junction_length]\n            #        print JunctionName\n            # print JunctionSeq\n\n            fout.write(JunctionName + \"|DEL\" + str(i) + \"\\n\")\n            fout.write(LeftExon[0:-i] + RightExon[i:] + \"\\n\")\n            InsertN = \"N\" * (i * 2)\n            fout.write(JunctionName + \"|INS\" + str(i) + \"\\n\")\n            fout.write(LeftExon + InsertN + RightExon + \"\\n\")\n\n        if counter == 5000:\n            fout.flush()\n    fout.close()\n\nf1.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "junction_length": 3,
            "filtered_fusion_junction": {
              "path": "/path/to/filtered_fusion_junction.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "sample_name"
              }
            },
            "max_indel": 10
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433772,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": null,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedOn": 1520433790,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedOn": 1532513222,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#filtered_fusion_junction",
              "glob": "*_FJ_Indels_*"
            },
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#filtered_fusion_junction_indels"
          }
        ],
        "label": "MACHETE AddIndelsToFasta Known",
        "sbg:latestRevision": 2,
        "sbg:revisionNotes": "junction_length parameter added",
        "y": 844.3625795687977,
        "inputs": [
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-n"
            },
            "id": "#max_indel",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-i"
            },
            "id": "#filtered_fusion_junction",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "AddIndelsToFasta.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520433772
      },
      "inputs": [
        {
          "id": "#MACHETE_AddIndelsToFasta_Known.max_indel",
          "default": 5
        },
        {
          "id": "#MACHETE_AddIndelsToFasta_Known.junction_length",
          "default": 300
        },
        {
          "id": "#MACHETE_AddIndelsToFasta_Known.filtered_fusion_junction",
          "source": [
            "#MACHETE_parse_to_remove_known_fusions.filtered_known_fusion_junction"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_AddIndelsToFasta_Known.filtered_fusion_junction_indels"
        }
      ],
      "sbg:x": 4206.697499276893,
      "sbg:y": 844.3625795687977
    },
    {
      "id": "#MACHETE_MakeIndelsHisto_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python MakeIndelsHisto.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/makeindelshisto/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          cmd = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 4810.771035250914,
        "id": "milos_jordanski/spachete-salzman-collaboration/makeindelshisto/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532513116,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "MakeIndelsHisto.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Fri Mar 25 15:25:42 2016\n\n@author: Gillian\n\"\"\"\n\nimport argparse\nimport glob\n\n\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        if self.junction[-4:-1] == \"DEL\":\n            self.indel = -int(self.junction[-1:])\n        elif self.junction[-4:-1] == \"INS\":\n            self.indel = int(self.junction[-1:])\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n        else:\n            self.NumN = line[12][5:]\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"file sample name\")\n#parser.add_argument(\"-f\", \"--FJDir\", required=True, help=\"FJ directory\")\nparser.add_argument(\"-w\", \"--overlap\", required=True, help=\"required overlapping nt on each side of junction, including # indels\")\nparser.add_argument(\"-x\", \"--NumIndels\", required=True, help=\"number of indels allowed from previous file\")\nparser.add_argument(\"-ufj1\", \"--unaligned_to_FJ_1\", required=True, help=\"unaligned read1 from KNIFE aligned to FJ\")\nparser.add_argument(\"-ufj2\", \"--unaligned_to_FJ_2\", required=True, help=\"unaligned read2 from KNIFE aligned to FJ\")\nparser.add_argument(\"-sufji1\", \"--still_unaligned_to_FJIndels_1\", nargs='+', required=True, help=\"still unaligned read1 aligned to FJIndels1\")\nparser.add_argument(\"-sufji2\", \"--still_unaligned_to_FJIndels_2\", nargs='+', required=True, help=\"still unaligned read2 aligned to FJIndels2\")\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\n\njunction_length = int(args.farJunctionLength)\n\n#if args.FJDir[-1] != \"/\":\n#    args.FJDir += \"/\"\n\n#\n### make a concatenated list of all the far junction alignment files\n\n#\n# input_lines=fileinput.input(FJ1_list)\n# fout_FJ1.writelines(input_lines)\n# input_lines=fileinput.input(FJ2_list)\n# fout_FJ2.writelines(input_lines)\n#\n# fout_FJ1.close()\n# fout_FJ2.close()\n\n\n## now go through all primary alignments and make a dictionary of possible far juncs:\n\nFJDict_1 = {}  ## key = junc name, Val = # [0,0,0,0,X,0,0,0,0]  0's # of indels\nFJDict_2 = {}\n\n#FJFile1 = sorted(glob.glob(args.FJDir + \"FarJunctionAlignments/\" + args.stem + \"/*.sam\"))[0]\n#FJFile2 = sorted(glob.glob(args.FJDir + \"FarJunctionAlignments/\" + args.stem + \"/*.sam\"))[1]\n\nFJFile1 = args.unaligned_to_FJ_1\nFJFile2 = args.unaligned_to_FJ_2\n\nf1 = open(FJFile1, mode=\"rU\")\nprint \"opening\" + FJFile1\n\nlinecount = 0\ngoodlinecount = 0\nnewjunc = 0\nfor line_raw in f1:\n    if line_raw[0] == \"@\":\n        continue\n    linecount += 1\n    FJread = ReadInfoFJ(line_raw)\n    if FJread.offset <= (junction_length/2 - int(args.overlap)) and FJread.offset + FJread.NumOfBases >= (junction_length/2 + int(args.overlap)):\n        if FJread.junction not in FJDict_1:\n            FJDict_1[FJread.junction] = [0] * (2 * int(args.NumIndels) + 1)\n            newjunc += 1\n        FJDict_1[FJread.junction][int(args.NumIndels)] += 1\n        goodlinecount += 1\nf1.close()\nprint \"new junc added\" + str(newjunc)\nprint linecount\nprint goodlinecount\n\nlinecount = 0\ngoodlinecount = 0\nnewjunc = 0\n\nf2 = open(FJFile2, mode=\"rU\")\nprint \"opening\" + FJFile2\nfor line_raw in f2:\n    if line_raw[0] == \"@\":\n        continue\n    FJread = ReadInfoFJ(line_raw)\n    linecount += 1\n    if FJread.offset <= (junction_length/2 - int(args.overlap)) and FJread.offset + FJread.NumOfBases >= (junction_length/2 + int(args.overlap)):\n        if FJread.junction not in FJDict_2:\n            FJDict_2[FJread.junction] = [0] * (2 * int(args.NumIndels) + 1)\n            newjunc += 1\n\n        FJDict_2[FJread.junction][int(args.NumIndels)] += 1\n        goodlinecount += 1\nf2.close()\nprint \"new junc added\" + str(newjunc)\nprint linecount\nprint goodlinecount\n\n## make a dictionary of readIDs that aligned to any FJ indel\n\n\n\nAlignedFJFiles = []\n\n#for name in glob.glob(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/*.sam\"):\n#    if \"All_\" not in name:\n#        AlignedFJFiles.append(name)\n\n\n#FJ1_list = sorted(AlignedFJFiles)[0:len(AlignedFJFiles) / 2]\n#FJ2_list = sorted(AlignedFJFiles)[len(AlignedFJFiles) / 2:]\n\nFJ1_list = args.still_unaligned_to_FJIndels_1\nFJ2_list = args.still_unaligned_to_FJIndels_2\n\n#\n# print \"FJ1 indels list\"\n# print FJ1_list\n# print \"FJ2 indels list\"\n# print FJ2_list\n\nIndelsReadIDs = {}\n\nfor name in FJ1_list:\n    print \"FJ1 indels\"\n    print name\n    f1 = open(name, mode=\"rU\")\n\n    for line in f1:\n        if line[0] == \"@\":\n            continue\n\n        read = ReadInfoFJ(line)\n        # if the read overlaps the junction\n        if read.offset <= (junction_length/2 - int(args.overlap) + read.indel) and read.offset + read.NumOfBases >= (junction_length/2 + int(args.overlap) + read.indel):\n\n            # if the read isn't in dictionary then add it\n            if read.ID not in IndelsReadIDs:\n                IndelsReadIDs[read.ID] = line\n            # if the read is in the dictionary, compare it to existing read. If AS is better, then replace existing read\n            else:\n                compareRead = ReadInfoFJ(IndelsReadIDs[read.ID])\n                if int(compareRead.AS) >= int(read.AS):\n                    pass\n                else:\n                    IndelsReadIDs[read.ID] = line\n    f1.close()\n\n# write all distinct readIDs to an All_1_indels file\n#fout_FJ1 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_1_indels.sam\", mode=\"w\")\nfout_FJ1 = open(\"All_\" + args.sample + \"_1_indels.sam\", mode = \"w\")\n\nfor key in IndelsReadIDs:\n    fout_FJ1.write(IndelsReadIDs[key].strip() + \"\\n\")\nfout_FJ1.close()\n\n## CLEAR Read IDs dictionary and do the same with FJ2 list\nIndelsReadIDs = {}\n\nfor name in FJ2_list:\n    print \"FJ2 indels\"\n    print name\n\n    f1 = open(name, mode=\"rU\")\n\n    for line in f1:\n        if line[0] == \"@\":\n            continue\n\n        read = ReadInfoFJ(line)\n        # if the read overlaps the junction\n        if read.offset <= (junction_length/2 - int(args.overlap) + read.indel) and read.offset + read.NumOfBases >= (junction_length/2 + int(args.overlap) + read.indel):\n\n            # if the read isn't in dictionary then add it\n            if read.ID not in IndelsReadIDs:\n                IndelsReadIDs[read.ID] = line\n            # if the read is in the dictionary, compare it to existing read. If AS is better, then replace existing read\n            else:\n                compareRead = ReadInfoFJ(IndelsReadIDs[read.ID])\n                if int(compareRead.AS) >= int(read.AS):\n                    pass\n                else:\n                    IndelsReadIDs[read.ID] = line\n    f1.close()\n\n# write all distinct readIDs to an All_1_indels file\n#fout_FJ2 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_2_indels.sam\", mode=\"w\")\nfout_FJ2 = open(\"All_\" + args.sample + \"_2_indels.sam\", mode = \"w\")\n\nfor key in IndelsReadIDs:\n    fout_FJ2.write(IndelsReadIDs[key].strip() + \"\\n\")\nfout_FJ2.close()\n\n## parse AllIndels_1 and AllIndels_2 files to see if they aligned to the same juncs with indels as an FJ\n## if yes, then add to junction \"dictionary\"\n\n#Indels1 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_1_indels.sam\", mode=\"rU\")\nIndels1 = open(\"All_\" + args.sample + \"_1_indels.sam\", mode=\"rU\")\n\nfor line in Indels1:\n    read = ReadInfoFJ(line)\n    if read.junction[:-5] in FJDict_1:\n        FJDict_1[read.junction[:-5]][int(args.NumIndels) + read.indel] += 1\nIndels1.close()\n\n#Indels2 = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + args.stem + \"/All_\" + args.stem + \"_2_indels.sam\", mode=\"rU\")\nIndels2 = open(\"All_\" + args.sample + \"_2_indels.sam\", mode=\"rU\")\n\nfor line in Indels2:\n    read = ReadInfoFJ(line)\n    if read.junction[:-5] in FJDict_2:\n        FJDict_2[read.junction[:-5]][int(args.NumIndels) + read.indel] += 1\nIndels2.close()\n\n## output indels histo\n\n#Outfile1 = open(args.FJDir + \"IndelsHistogram/indels_\" + args.stem + \"_1.txt\", mode=\"w\")\nOutfile1 = open(\"indels_\" + args.sample + \"_1.txt\", mode=\"w\")\n\nfor key in FJDict_1:\n    Outfile1.write(key + \"\\t\" + str(FJDict_1[key]) + \"\\n\")\nOutfile1.close()\n\n#Outfile2 = open(args.FJDir + \"IndelsHistogram/indels_\" + args.stem + \"_2.txt\", mode=\"w\")\nOutfile2 = open(\"indels_\" + args.sample + \"_2.txt\", mode=\"w\")\n\nfor key in FJDict_2:\n    Outfile2.write(key + \"\\t\" + str(FJDict_2[key]) + \"\\n\")\nOutfile2.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "mode": "complete",
            "junction_length": 6,
            "num_indels": 10,
            "overlap": 2,
            "unaligned_to_FJ": [
              {
                "path": "/path/to/unaligned_to_FJ-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/unaligned_to_FJ-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "still_unaligned_to_FJIndels_2": [
              {
                "path": "/path/to/still_unaligned_to_FJIndels_2-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/still_unaligned_to_FJIndels_2-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ],
            "still_unaligned_to_FJIndels_1": [
              {
                "path": "/path/to/still_unaligned_to_FJIndels_1-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              },
              {
                "path": "/path/to/still_unaligned_to_FJIndels_1-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": []
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520433939,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": null,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedOn": 1520433966,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "revision 5 copied",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedOn": 1532513116,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "indels*.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#indels_txt"
          },
          {
            "outputBinding": {
              "glob": "All*_2_indels.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#all_indels_sam_2"
          },
          {
            "outputBinding": {
              "glob": "All*_1_indels.sam",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#all_indels_sam_1"
          }
        ],
        "label": "MACHETE MakeIndelsHisto Known",
        "sbg:latestRevision": 2,
        "sbg:revisionNotes": "junction_length parameter added",
        "y": 861.3763280305288,
        "inputs": [
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.unaligned_to_FJ)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -ufj1 \" + inputs[i].path\n        else\n          cmd += \" -ufj2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#unaligned_to_FJ",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-sufji2",
              "itemSeparator": " "
            },
            "id": "#still_unaligned_to_FJIndels_2",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          },
          {
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "-sufji1",
              "itemSeparator": " "
            },
            "id": "#still_unaligned_to_FJIndels_1",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "sbg:stageInput": null,
            "required": false
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "id": "#overlap",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-w"
            },
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-x"
            },
            "id": "#num_indels",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "id": "#mode",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-m"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "MakeIndelsHisto.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520433939
      },
      "inputs": [
        {
          "id": "#MACHETE_MakeIndelsHisto_Known.unaligned_to_FJ",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_MakeIndelsHisto_Known.still_unaligned_to_FJIndels_2",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_MakeIndelsHisto_Known.still_unaligned_to_FJIndels_1",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_MakeIndelsHisto_Known.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#MACHETE_MakeIndelsHisto_Known.num_indels",
          "default": 5
        },
        {
          "id": "#MACHETE_MakeIndelsHisto_Known.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#MACHETE_MakeIndelsHisto_Known.junction_length",
          "default": 300
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_MakeIndelsHisto_Known.indels_txt"
        },
        {
          "id": "#MACHETE_MakeIndelsHisto_Known.all_indels_sam_2"
        },
        {
          "id": "#MACHETE_MakeIndelsHisto_Known.all_indels_sam_1"
        }
      ],
      "sbg:x": 4810.771035250914,
      "sbg:y": 861.3763280305288
    },
    {
      "id": "#MACHETE_FJIndels_ClassIDFile_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python FJIndels_ClassIDFile.py  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/fjindels-classidfile/2",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id = \"-s \" + inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 4990.499752374064,
        "id": "milos_jordanski/spachete-salzman-collaboration/fjindels-classidfile/2",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532513049,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "FJIndels_ClassIDFile.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Sep 16 16:12:27 2015\n\n@author: Gillian\n\"\"\"\n# takes alignments from Indels and finds read partner.\n# all Far Junction and Scrambled junction reads where the alignment does not overlap the\n# Junction by args.window bp will be thrown out.\n\n# This program then tells if read partners \"makes sense\" or not\n# final Output categories -- [0] R1 junc name\n#   [1] genome - R2 location < 100mill bp away\n#   [2] genome anomaly - R2 location > 100mill bp away\n#   [3] genome p value\n#   [4] reg - R2 closest location <100mill bp away\n#   [5] reg anomaly - R2 closest location > 100 mill bp away\n#   [6] reg p value\n#   [7] junc / scrambled - R2 closest location <100mill bp away\n#   [8] junc anomaly - R2 closest location > 100mill bp away\n#   [9] junc p value\n#   [10] FarJunc - R2 aligned to same FarJunc\n#   [11] FarJunc anomaly - R2 aligned to diff FarJunc\n#   [12] FarJunc p value\n#   [13] unaligned - R2 didn't align\n#   [14] unmapped - R2 missing in action\n#   [15] P val for all non-anomaly classes\n\n\n\n################\n# Current categories\n# FJgood -- genome, reg, FJ\n# FJbad -- genome anomaly, reg anomaly, junc, junc anomaly, FJ anomaly\n#################\n\n\n\nimport argparse\nimport os\nimport glob\n\n\ndef AddToDict(inputtype, line_raw_comparison, line_raw_FJ):\n    lineFJ = ReadInfoFJ(line_raw_FJ)\n\n    if inputtype == \"FJ\":  # if comparing Far Junc to Far Junc, they have to be identical\n        line2 = ReadInfoFJ(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction[\n                                                                                        :-5] + \"\\t\" + lineFJ.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        if lineFJ.junction == line2.junction and lineFJ.refstrand in [\"0\", \"16\"] and line2.refstrand in [\"0\",\n                                                                                                         \"16\"] and lineFJ.refstrand != line2.refstrand:\n            #            TargetDict[lineFJ.junction][0] +=1\n            IDfiletype = \"FJgood,FarJunction,\" + lineFJ.junction[-4:]\n        else:\n            #            TargetDict[lineFJ.junction][1]+=1\n            IDfiletype = \"FJbad,FarJuncAnom,\" + lineFJ.junction[-4:]\n        # addAS = 0.0\n        #            addNumofBases = 0.0\n        #\n        #        TargetDict[lineFJ.junction][2] += addAS\n        #        TargetDict[lineFJ.junction][3] += addNumofBases\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n    if inputtype == \"reg\" or inputtype == \"junc\":  # if reg or junc read and meets refstrand criteria below\n        line2 = ReadInfoJunc(line_raw_comparison)\n\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction[\n                                                                                        :-5] + \"\\t\" + lineFJ.refstrand\n        IDfileoutputR2 = str(line2.offset) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(\n            line2.NumOfBases) + \"\\t\" + line2.junction + \"\\t\" + line2.refstrand\n\n        if inputtype == \"junc\":\n            IDfiletype = \"FJbad,Junction,\" + lineFJ.junction[-4:]\n\n        if inputtype == \"reg\":\n            IDfiletype = \"FJbad,RegAnomaly,\" + lineFJ.junction[-4:]\n\n            if lineFJ.chr_left == line2.chr:\n                if lineFJ.strand_left == line2.strand:\n                    if lineFJ.strand_left == \"-\":\n                        if lineFJ.refstrand == line2.refstrand:\n                            if int(lineFJ.loc_left) <= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n                    elif lineFJ.strand_left == \"+\":\n                        if lineFJ.refstrand != line2.refstrand:\n                            if int(lineFJ.loc_left) >= int(line2.loc_2):\n                                IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n            if IDfiletype == \"FJbad,RegAnomaly,\" + lineFJ.junction[-4:]:\n                if lineFJ.chr_right == line2.chr:\n                    if lineFJ.strand_right == line2.strand:\n                        if lineFJ.strand_right == \"-\":\n                            if lineFJ.refstrand == line2.refstrand:\n                                if int(lineFJ.loc_right) >= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n                        elif lineFJ.strand_right == \"+\":\n                            if lineFJ.refstrand != line2.refstrand:\n                                if int(lineFJ.loc_right) <= int(line2.loc_1):\n                                    IDfiletype = \"FJgood,Regular,\" + lineFJ.junction[-4:]\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n        IDfile.flush()\n\n    if inputtype == \"genome\":  # comparing FJ to genome, has to be within 100Kbp, meet ref strand criteria (opp refstrand if + read, same refstrand if - read)\n\n        line2 = ReadInfoGenome(line_raw_comparison)\n\n        ## output R1 -  offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR1 = str(lineFJ.offset) + \"\\t\" + str(lineFJ.MAPQ) + \"\\t\" + str(\n            lineFJ.adjAS) + \"\\t\" + lineFJ.NumN + \"\\t\" + str(lineFJ.NumOfBases) + \"\\t\" + lineFJ.junction[\n                                                                                        :-5] + \"\\t\" + lineFJ.refstrand\n        ## output R1 - offset, MAPQ, AS, #N, readlen, junc name, strand\n        IDfileoutputR2 = str(line2.loc) + \"\\t\" + str(line2.MAPQ) + \"\\t\" + str(\n            line2.adjAS) + \"\\t\" + line2.NumN + \"\\t\" + str(line2.NumOfBases) + \"\\t\" + line2.chr + \"\\t\" + line2.refstrand\n\n        IDfiletype = \"FJbad,genomAnomaly,\" + lineFJ.junction[-4:]\n        # compare left\n        if lineFJ.chr_left == line2.chr:\n            if lineFJ.strand_left == \"-\":\n                if lineFJ.refstrand == line2.refstrand:\n                    if int(lineFJ.loc_left) <= int(line2.loc):\n                        IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n            elif lineFJ.strand_left == \"+\":\n                if lineFJ.refstrand != line2.refstrand:\n                    if int(lineFJ.loc_left) >= int(line2.loc):\n                        IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n                        ## if left not the same, then compare right\n        if IDfiletype == \"FJbad,genomAnomaly,\" + lineFJ.junction[-4:]:\n            if lineFJ.chr_right == line2.chr:\n                if lineFJ.strand_right == \"-\":\n                    if lineFJ.refstrand == line2.refstrand:\n                        if int(lineFJ.loc_right) >= int(line2.loc):\n                            IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n                elif lineFJ.strand_right == \"+\":\n                    if lineFJ.refstrand != line2.refstrand:\n                        if int(lineFJ.loc_right) <= int(line2.loc):\n                            IDfiletype = \"FJgood,genome,\" + lineFJ.junction[-4:]\n\n        IDfile.write(\n            line_raw_FJ.split(\"\\t\")[0] + \"\\t\" + IDfiletype + \"\\t\" + IDfileoutputR1 + \"\\t\" + IDfileoutputR2 + \"\\n\")\n\n\n#\ndef ID(string):\n    #if string[-2:] == \"/1\" or string[-2:] == \"/2\":\n    #    return string[:-2]\n    if args.mode == \"appended\":\n        return string[:-2]\n    else:\n        return string\n\n\nclass ReadInfoFJ:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        if self.junction[-4:-1] == \"DEL\":\n            self.indel = -int(self.junction[-1:])\n        elif self.junction[-4:-1] == \"INS\":\n            self.indel = int(self.junction[-1:])\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n        JuncInfo = line[2].replace(\":\", \" \").replace(\"|\", \" \").split(\" \")\n        self.chr_left = JuncInfo[0]\n        self.loc_left = JuncInfo[2]\n        self.strand_left = JuncInfo[3]\n        self.chr_right = JuncInfo[4]\n        self.loc_right = JuncInfo[6]\n        self.strand_right = JuncInfo[7]\n\n\nclass ReadInfoGenome:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.chr = line[2]\n        self.loc = line[3]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\nclass ReadInfoJunc:\n    def __init__(self, line_raw):\n        line = line_raw.strip().split(\"\\t\")\n        self.ID = ID(line[0])\n        self.refstrand = line[1]\n        self.junction = line[2]\n        self.chr = line[2].split(\"|\")[0]\n        self.loc_1 = line[2].replace(\":\", \"|\").split(\"|\")[2]\n        self.loc_2 = line[2].replace(\":\", \"|\").split(\"|\")[4]\n        self.strand = line[2][-1]\n        self.MAPQ = int(line[4])\n        self.AS = int(line[11].split(\":\")[2])\n        self.NumOfBases = len(line[9])\n        self.offset = int(line[3])\n        if \"XS:i:\" in line[12]:\n            self.NumN = line[13][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[13][5:])\n        else:\n            self.NumN = line[12][5:]\n            self.adjAS = int(line[11].split(\":\")[2]) + int(line[12][5:])\n\n\n# =========================================\n# start here\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name of file to generate report\")\n#parser.add_argument(\"-c\", \"--circReads\", required=True, help=\"path to circReads Dir\")\n#parser.add_argument(\"-f\", \"--FJDir\", required=True, help=\"path to aligned junction reads\")\n#parser.add_argument(\"-i\", \"--origDir\", required=True, help=\"path to orig dir containing genome reads\")\nparser.add_argument(\"-w\", \"--window\", required=True, help=\"# of bases needed on each side of the junction\")\n\n\nparser.add_argument(\"-fusj1\", \"--fusionJuncSAM1\", required=True, help=\"unaligned reads1 to fusion junctions\")\nparser.add_argument(\"-fusj2\", \"--fusionJuncSAM2\", required=True, help=\"unaligned reads2 to fusion junctions\")\n\nparser.add_argument(\"-asufji1\", \"--allStillUnalignedFusionJuncSAM1\", required=True, help=\"All still unaligned reads1 to fusion junction indels\")\nparser.add_argument(\"-asufji2\", \"--allStillUnalignedFusionJuncSAM2\", required=True, help=\"All still unaligned reads2 to fusion junction indels\")\n\nparser.add_argument(\"-m\", \"--mode\", required=True, help=\"appended or complete\")\n\nparser.add_argument(\"-gens1\", \"--genomeSAM1\", required=True, help=\"read1 to genome\")\nparser.add_argument(\"-gens2\", \"--genomeSAM2\", required=True, help=\"read2 to genome\")\nparser.add_argument(\"-regs1\", \"--regularSAM1\", required=True, help=\"read1 to regular junction\")\nparser.add_argument(\"-regs2\", \"--regularSAM2\", required=True, help=\"read2 to regular junction\")\nparser.add_argument(\"-scrs1\", \"--scrambledSAM1\", required=True, help=\"read1 to ribosomal junction\")\nparser.add_argument(\"-scrs2\", \"--scrambledSAM2\", required=True, help=\"read2 to ribosomal junction\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\nwindow = int(args.window)\njunction_length = int(args.farJunctionLength)\n\n# f1 = open(\"/Users/Gillian/Desktop/sherlock/unaligned_ENCFF000HOC1_1.sam\", mode =\"rU\")\n# f2 = open(\"/Users/Gillian/Desktop/sherlock/20000_ENCFF000HOC2_1_genome_output.sam\", mode =\"rU\")\n\n#if args.FJDir[-1] != \"/\":\n#    args.FJDir += \"/\"\n#if args.origDir[-1] != \"/\":\n#    args.origDir += \"/\"\n#if args.circReads[-1] != \"/\":\n#    args.circReads += \"/\"\n\n#stem = args.stem\n\n#FarJunctionfiles = []\nFarJunction_noIndelfiles = []\ngenomefiles = []\nregfiles = []\njunctionfiles = []\n\n#for name in glob.glob(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + stem + \"/*.sam\"):\n#    print name\n#    if \"All_\" not in name:\n#        FarJunctionfiles.append(name)\n        # FarJunctionFiles contains indel alignments for _1 and _2 files to indels 1-5\n\n\n\n#for name in glob.glob(args.FJDir + \"FarJunctionAlignments/\" + stem + \"/*.sam\"):\n#    FarJunction_noIndelfiles.append(name)\n\n#for name in glob.glob(os.path.join(args.origDir, \"genome/*\" + stem + \"*.sam\")):\n#    #    print name\n#    if \"sorted\" not in name:\n#        genomefiles.append(name)\n\n#for name in glob.glob(os.path.join(args.origDir, \"reg/*\" + stem + \"*.sam\")):\n    #    print name\n#    if \"sorted\" not in name:\n#        regfiles.append(name)\n#for name in glob.glob(os.path.join(args.origDir, \"junction/*\" + stem + \"*.sam\")):\n#    #    print name\n#    if \"sorted\" not in name:\n#        junctionfiles.append(name)\n        # for name in glob.glob(os.path.join(args.origDir,\"unaligned/*\" + stem + \"*.fq\")):\n##    print name\n#    if \"sorted\" not in name:\n#        unalignedfiles.append(name)\n\n\n# opening all files for a particular stem\n#print sorted(FarJunction_noIndelfiles)\n#print sorted(genomefiles)\n#print sorted(regfiles)\n#print sorted(junctionfiles)\n\n## open big indels files\n\n#f1_FarJunc = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + stem + \"/All_\" + stem + \"_1_indels.sam\", mode=\"rB\")\n#f2_FarJunc = open(args.FJDir + \"FarJuncSecondary/AlignedIndels/\" + stem + \"/All_\" + stem + \"_2_indels.sam\", mode=\"rB\")\n\nf1_FarJunc = open(args.allStillUnalignedFusionJuncSAM1, mode = \"rB\")\nf2_FarJunc = open(args.allStillUnalignedFusionJuncSAM2, mode = \"rB\")\n\n#f1_FJ_noIndel = open(sorted(FarJunction_noIndelfiles)[0], mode=\"rB\")\n#f2_FJ_noIndel = open(sorted(FarJunction_noIndelfiles)[1], mode=\"rB\")\n\nf1_FJ_noIndel = open(args.fusionJuncSAM1, mode = \"rB\")\nf2_FJ_noIndel = open(args.fusionJuncSAM2, mode = \"rB\")\n\nIDfile = open(args.sample + \"_temp_output_FJIndels.txt\", mode=\"w\")\nIDfile.write(\"ID\\tclass\\tR1_offset\\tR1_MAPQ\\tR1_AS\\tR1_NumN\\tR1_Readlength\\tR1_JuncName\\tR1_strand\\tR2_offset\\tR2_MAPQ\\tR2_AS\\tR2_NumN\\tR2_Readlength\\tR2_JuncName\\tR2_strand\\n\")\n\n# populate all reads and junctions into separate dictionaries\nAllFJRead1 = {}\nAllFJRead2 = {}\n\n# populate AllFJRead1 dictionary - all read 1's from FarJunction alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening FarJunc _1 file\"\n\nfor line_raw in f1_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n\n    FJ1read = ReadInfoFJ(line_raw)\n\n    if FJ1read.offset <= (junction_length/2 + FJ1read.indel - window) and (\n        FJ1read.offset + FJ1read.NumOfBases) >= junction_length/2 + FJ1read.indel + window:\n        AllFJRead1[FJ1read.ID] = [line_raw, 0]\n\nf1_FarJunc.close()\nIDfile.flush()\n\n# populate AllFJRead2 dictionary - all read 2's from FarJunc alignments\n# in order for R1 to feed into dictionary, must overlap entire offset (userspecified)\nprint \"opening farJunc _2 file\"\nfor line_raw in f2_FarJunc:\n    if line_raw[0] == \"@\":\n        continue\n\n    FJ2read = ReadInfoFJ(line_raw)\n\n    # if R1 and R2 both in Far Junc, then add to FJ-FJ list\n    if FJ2read.ID in AllFJRead1:\n        if FJ2read.offset <= (junction_length/2 + FJ2read.indel - window) and (\n            FJ2read.offset + FJ2read.NumOfBases) >= junction_length/2 + FJ2read.indel + window and AllFJRead1[FJ2read.ID][1] == 0:\n            AddToDict(\"FJ\", line_raw, AllFJRead1[FJ2read.ID][0])\n            AllFJRead1[FJ2read.ID][1] = \"FJ\"\n    else:\n        AllFJRead2[FJ2read.ID] = [line_raw, 0]\n\n# if FJ2read.junction not in AllJunctions:\n#        AllJunctions[FJ2read.junction]=0\n#\n#    AllJunctions[FJ2read.junction]+=1\nf2_FarJunc.close()\nIDfile.flush()\n\n# compare FJ with indels_1 to FJ with no indels _ 2\nprint \"comparing indels with FJ _2\"\nfor line_raw in f2_FJ_noIndel:\n    if line_raw[0] == \"@\":\n        continue\n    FJ2read = ReadInfoFJ(line_raw)\n\n    if FJ2read.ID in AllFJRead1 and AllFJRead1[FJ2read.ID][1] == 0:\n        AddToDict(\"FJ\", line_raw, AllFJRead1[FJ2read.ID][0])\n        AllFJRead1[FJ2read.ID][1] = \"FJ\"\n\nf2_FJ_noIndel.close()\nIDfile.flush()\n\n# compare FJ with indels _2 to FJ with no indels _1\n\nprint \"comparing indels with FJ _1\"\n\nfor line_raw in f1_FJ_noIndel:\n    if line_raw[0] == \"@\":\n        continue\n    FJ1read = ReadInfoFJ(line_raw)\n\n    if FJ1read.ID in AllFJRead2 and AllFJRead2[FJ1read.ID][1] == 0:\n        # print \"found genome R1\"+g1read.ID\n        #        if g1read.ID in unmappedDict:\n        #            del unmappedDict[g1read.ID]\n        AddToDict(\"FJ\", line_raw, AllFJRead2[FJ1read.ID][0])\n        AllFJRead2[FJ1read.ID][1] = \"FJ\"\nf1_FJ_noIndel.close()\nIDfile.flush()\n\n#f2_genome = open(sorted(genomefiles)[1], mode=\"rB\")\nf2_genome = open(args.genomeSAM2, mode = \"rB\")\n\n# compare FJ read 1 to genome read 2\nprint \"comparing indels with genome_2\"\n\nfor line_raw in f2_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g2read = ReadInfoGenome(line_raw)\n\n    if g2read.ID in AllFJRead1 and AllFJRead1[g2read.ID][1] == 0:\n        AddToDict(\"genome\", line_raw, AllFJRead1[g2read.ID][0])\n        AllFJRead1[g2read.ID][1] = \"genome\"\n\nf2_genome.close()\n\nIDfile.flush()\n\n#f1_genome = open(sorted(genomefiles)[0], mode=\"rB\")\nf1_genome = open(args.genomeSAM1, mode = \"rB\")\n\n# compare FJ read 2 to genome read 1\nprint \"comparing indels with genome _1\"\nfor line_raw in f1_genome:\n    if line_raw[0] == \"@\":\n        continue\n    g1read = ReadInfoGenome(line_raw)\n\n    if g1read.ID in AllFJRead2 and AllFJRead2[g1read.ID][1] == 0:\n        # print \"found genome R1\"+g1read.ID\n        #        if g1read.ID in unmappedDict:\n        #            del unmappedDict[g1read.ID]\n        AddToDict(\"genome\", line_raw, AllFJRead2[g1read.ID][0])\n        AllFJRead2[g1read.ID][1] = \"genome\"\nf1_genome.close()\n\nIDfile.flush()\n\n#f2_reg = open(sorted(regfiles)[1], mode=\"rB\")\nf2_reg = open(args.regularSAM2, mode=\"rB\")\n\n# compare FJ read 1 to reg read 2\nprint \"comparing indels with reg _2\"\n\nfor line_raw in f2_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg2read = ReadInfoJunc(line_raw)\n\n    if reg2read.offset <= (junction_length/2 - window) and (reg2read.offset + reg2read.NumOfBases) >= (junction_length/2 + window):\n        if reg2read.ID in AllFJRead1 and AllFJRead1[reg2read.ID][1] == 0:\n            #            print \"found reg R2:\" + reg2read.ID\n            #            if reg2read.ID in unmappedDict:\n            #                del unmappedDict[reg2read.ID]\n            AddToDict(\"reg\", line_raw, AllFJRead1[reg2read.ID][0])\n            AllFJRead1[reg2read.ID][1] = \"reg\"\nf2_reg.close()\nIDfile.flush()\n\n#f1_reg = open(sorted(regfiles)[0], mode=\"rB\")\nf1_reg = open(args.regularSAM1, mode=\"rB\")\n\n# compare FJ read 2 to reg read 1\nprint \"comparing indels with reg _1\"\n\nfor line_raw in f1_reg:\n    if line_raw[0] == \"@\":\n        continue\n    reg1read = ReadInfoJunc(line_raw)\n\n    if reg1read.offset <= (junction_length/2 - window) and (reg1read.offset + reg1read.NumOfBases) >= (junction_length/2 + window):\n        if reg1read.ID in AllFJRead2 and AllFJRead2[reg1read.ID][1] == 0:\n            #            print \"found reg R1: \" + reg1read.ID\n            #            if reg1read.ID in unmappedDict:\n            #                del unmappedDict[reg1read.ID]\n            AddToDict(\"reg\", line_raw, AllFJRead2[reg1read.ID][0])\n            AllFJRead2[reg1read.ID][1] = \"reg\"\nf1_reg.close()\nIDfile.flush()\n\n#f2_junc = open(sorted(junctionfiles)[1], mode=\"rB\")\nf2_junc = open(args.scrambledSAM2, mode=\"rB\")\n\n# compare FJ read 1 to junc read 2\nprint \"comparing indels with junc _2\"\n\nfor line_raw in f2_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc2read = ReadInfoJunc(line_raw)\n\n    if junc2read.offset <= (junction_length/2 - window) and (junc2read.offset + junc2read.NumOfBases) >= (junction_length/2 + window):\n        if junc2read.ID in AllFJRead1 and AllFJRead1[junc2read.ID][1] == 0:\n            # print \"found junc R2 \" + junc2read.ID\n            #            if junc2read.ID in unmappedDict:\n            #                del unmappedDict[junc2read.ID]\n            AddToDict(\"junc\", line_raw, AllFJRead1[junc2read.ID][0])\n            AllFJRead1[junc2read.ID][1] = \"junc\"\nf2_junc.close()\nIDfile.flush()\n\n#f1_junc = open(sorted(junctionfiles)[0], mode=\"rB\")\nf1_junc = open(args.scrambledSAM1, mode=\"rB\")\n\n# compare FJ read 2 to junc read 1\nprint \"comparing indels with junc _1\"\n\nfor line_raw in f1_junc:\n    if line_raw[0] == \"@\":\n        continue\n    junc1read = ReadInfoJunc(line_raw)\n\n    if junc1read.offset <= (junction_length/2 - window) and (junc1read.offset + junc1read.NumOfBases) >= (junction_length/2 + window):\n        if junc1read.ID in AllFJRead2 and AllFJRead2[junc1read.ID][1] == 0:\n            # print \"found junc R1: \" + junc1read.ID\n            #            if junc1read.ID in unmappedDict:\n            #                del unmappedDict[junc1read.ID]\n            AddToDict(\"junc\", line_raw, AllFJRead2[junc1read.ID][0])\n            AllFJRead2[junc1read.ID][1] = \"junc\"\nf1_junc.close()\nIDfile.flush()\n\nIDfile.close()\n\n#############################################################################\n## This section of code takes the written ID file above (temp_IDs_STEM.txt) and\n## removes duplicate entries of genome and reg. The same readID may be found\n## in both libraries and would both be in the ID file.\n## The new ID file removes duplicates and only keeps the readID with the\n## best alignment score.\n#tempIDfile = open(args.FJDir + \"GLM_classInput/\" + args.stem + \"_temp_output_FJIndels.txt\", mode=\"rU\")\n#newIDfile = open(args.FJDir + \"GLM_classInput/\" + args.stem + \"_output_FJIndels.txt\", mode=\"w\")\n\ntempIDfile = open(args.sample + \"_temp_output_FJIndels.txt\", mode=\"rU\")\nnewIDfile = open(args.sample + \"__output_FJIndels.txt\", mode=\"w\")\n\n##grep col 2 for \"genom\", \"Regular\" or \"RegAnomaly\". if not found ,write to\n## new file immediately.\n## if found, feed into dictionary (key=readID, value= entire line from temp file)\n## if duplicate entry, then compare R2 AS. if AS larger, then replace\n## value with new value from new R2\n## at completion of file, write entire dictionary into new ID file.\n\nGenomeAndRegReadIDs = {}\n\nfor line in tempIDfile:\n    line = line.strip()\n    if \"unaligned\" in line:\n        continue\n\n    if \"Unmapped\" in line:\n        continue\n\n    readID = line.split(\"\\t\")[0]\n    classID = line.split(\"\\t\")[1]\n    AS_new = line.split(\"\\t\")[11]\n\n    if \"genom\" in classID:\n        ## if readID has been seen previously, then replace value in dictionary\n        ## only if AS is greater.\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"Regular\" in classID:\n        ## do the same if reg\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    elif \"RegAnomaly\" in classID:\n        ## do the same if reg anomaly\n        if readID in GenomeAndRegReadIDs:\n            AS_old = GenomeAndRegReadIDs[readID].split(\"\\t\")[11]\n            if int(AS_new) > int(AS_old):\n                GenomeAndRegReadIDs[readID] = line\n        else:\n            GenomeAndRegReadIDs[readID] = line\n    else:\n        ## if not genome/genome anomaly/ reg/ reg anomaly then\n        ## write line directly in new file.\n        newIDfile.write(line + \"\\n\")\n\nfor entry in GenomeAndRegReadIDs:\n    newIDfile.write(GenomeAndRegReadIDs[entry] + \"\\n\")\n\ntempIDfile.close()\nnewIDfile.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "allStillUnalignedFusionJuncSAM2": {
              "path": "/path/to/allStillUnalignedFusionJuncSAM2.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "junction_length": 9,
            "mode": "complete",
            "overlap": 4,
            "regular_sam": [
              {
                "path": "/path/to/regular_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/regular_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "allStillUnalignedFusionJuncSAM1": {
              "path": "/path/to/allStillUnalignedFusionJuncSAM1.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "genome_sam": [
              {
                "path": "/path/to/genome_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "sample_id": "sample_name",
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/genome_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "fusion_junction_sam": [
              {
                "path": "/path/to/fusion_junction_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/fusion_junction_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ],
            "scrambled_sam": [
              {
                "path": "/path/to/scrambled_sam-1.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "1"
                }
              },
              {
                "path": "/path/to/scrambled_sam-2.ext",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "paired_end": "2"
                }
              }
            ]
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434004,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": null,
            "sbg:revision": 0
          },
          {
            "sbg:modifiedOn": 1520434028,
            "sbg:modifiedBy": "milos_jordanski",
            "sbg:revisionNotes": "revision 7 copied",
            "sbg:revision": 1
          },
          {
            "sbg:modifiedOn": 1532513049,
            "sbg:modifiedBy": "jordanski.milos",
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:revision": 2
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "glob": "*_temp_output_FJIndels.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#temp_output_FJIndels"
          },
          {
            "outputBinding": {
              "glob": "*__output_FJIndels.txt",
              "sbg:metadata": {
                "sample_id": {
                  "class": "Expression",
                  "script": "{\n  \tsample_id = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.sample_id)\n          sample_id =inputs[i].metadata.sample_id\n          break\n    }\n\treturn sample_id\n}\n",
                  "engine": "#cwl-js-engine"
                }
              }
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#output_FJIndels"
          }
        ],
        "label": "MACHETE FJIndels_ClassIDFile Known",
        "sbg:latestRevision": 2,
        "sbg:revisionNotes": "junction_length parameter added",
        "y": 856.0369726630211,
        "inputs": [
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.scrambled_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -scrs1 \" + inputs[i].path\n        else\n          cmd += \" -scrs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#scrambled_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.regular_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -regs1 \" + inputs[i].path\n        else\n          cmd += \" -regs2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#regular_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "id": "#overlap",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.overlap)\n    {\n    \treturn \" -w \" + $job.inputs.overlap + \" \"\n    }\n  \telse\n    {\n    \treturn \" -w 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": true,
            "required": false,
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mode",
                "symbols": [
                  "complete",
                  "appended"
                ]
              }
            ],
            "id": "#mode",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-m"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.genome_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -gens1 \" + inputs[i].path\n        else\n          cmd += \" -gens2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#genome_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  \tcmd = \"\"\n    inputs = [].concat($job.inputs.fusion_junction_sam)\n    for (i = 0; i < inputs.length; i++)\n    {\n    \tif (inputs[i].metadata.paired_end == \"1\")\n          cmd +=  \" -fusj1 \" + inputs[i].path\n        else\n          cmd += \" -fusj2 \" + inputs[i].path\n    }\n\treturn cmd\n}",
                "engine": "#cwl-js-engine"
              },
              "separate": true,
              "sbg:cmdInclude": true,
              "itemSeparator": null
            },
            "id": "#fusion_junction_sam",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--allStillUnalignedFusionJuncSAM2",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-asufji2"
            },
            "id": "#allStillUnalignedFusionJuncSAM2",
            "type": [
              "null",
              "File"
            ],
            "required": false
          },
          {
            "sbg:altPrefix": "--allStillUnalignedFusionJuncSAM1",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-asufji1"
            },
            "id": "#allStillUnalignedFusionJuncSAM1",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "FJIndels_ClassIDFile.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 2,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520434004
      },
      "inputs": [
        {
          "id": "#MACHETE_FJIndels_ClassIDFile_Known.scrambled_sam",
          "source": [
            "#getUnalignedReads_2.mate_scrambled_sam",
            "#getUnalignedReads_1.mate_scrambled_sam"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile_Known.regular_sam",
          "source": [
            "#getUnalignedReads_2.mate_regular_sam",
            "#getUnalignedReads_1.mate_regular_sam"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile_Known.overlap",
          "source": [
            "#Determine_mode.junction_overlap"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile_Known.mode",
          "source": [
            "#Determine_mode.output_mode"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile_Known.junction_length",
          "default": 300
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile_Known.genome_sam",
          "source": [
            "#getUnalignedReads_1.mate_genome_sam",
            "#getUnalignedReads_2.mate_genome_sam"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile_Known.fusion_junction_sam",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.result_sam_file"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile_Known.allStillUnalignedFusionJuncSAM2",
          "source": [
            "#MACHETE_MakeIndelsHisto_Known.all_indels_sam_2"
          ]
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile_Known.allStillUnalignedFusionJuncSAM1",
          "source": [
            "#MACHETE_MakeIndelsHisto_Known.all_indels_sam_1"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_FJIndels_ClassIDFile_Known.temp_output_FJIndels"
        },
        {
          "id": "#MACHETE_FJIndels_ClassIDFile_Known.output_FJIndels"
        }
      ],
      "sbg:x": 4990.499752374064,
      "sbg:y": 856.0369726630211
    },
    {
      "id": "#MACHETE_makeJunctions_new",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -zxvf /path/to/pickle_tar.tar.gz && python makeJunctions.py  -p pickle_tar  -s sample_name",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/makejunctions-new/5",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \tcmd = \"\"\n    \n    if ($job.inputs.input_file.metadata && $job.inputs.input_file.metadata.sample_id)\n      cmd = \"-s \" + $job.inputs.input_file.metadata.sample_id\n    \n    return cmd\n}\n\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          }
        ],
        "x": 2121.7069410665035,
        "id": "milos_jordanski/spachete-salzman-collaboration/makejunctions-new/5",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532538496,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "makeJunctions.py",
                "fileContent": "# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Wed Aug 19 10:24:15 2015\n\n@author: Gillian\n\"\"\"\nfrom itertools import islice\nimport os\nimport glob\nimport cPickle as pickle\nimport re\nfrom Bio import SeqIO\nimport time\nimport argparse\nimport sys\n\nnumber_of_chromosomes = 0\nclass locationparameters:\n    def __init__(self, read):\n        if read[-1] == \"-\":\n            self.strand = \"-\"\n        else:\n            self.strand = \"+\"\n\n        read = read.replace(\":\", \" \").replace(\"-\", \" \").replace(\"strand=\", \" \").split(\" \")\n        self.chr = read[0]\n        self.start = int(read[1])\n        self.stop = int(read[2])\n\n\n        # make a list of 26 dictionaries with each bin representing a different chromosome\n        # each dictionary contains key, value with UI, start/stop tuple respectively\n\ndef SortedLocation(UI, Chr, Start, Stop):\n    #try:\n    #    ChrBin = int(Chr) - 1\n    #except:\n    #    x = {\"X\": 23, \"Y\": 24, \"M\": 25}\n    #    ChrBin = x[Chr]\n        # each chromosome has a dictionary. Add location of read to chromosome dictionary\n    #    print ChrBin\n    #try:\n    #    LocationTuples_AllChr[ChrBin][UI] = (Start, Stop)\n    #except:\n    #    LocationTuples_AllChr[ChrBin] = {UI: (Start, Stop)}\n\n\n    #print chromosome_to_number\n    chr_num = chromosome_to_number[Chr]\n    #print Chr\n    #print chr_num\n    #print UI\n\n    try:\n        LocationTuples_AllChr[chr_num][UI] = (Start, Stop)\n    except:\n        LocationTuples_AllChr[chr_num] = {UI: (Start, Stop)}\n\n\n# print LocationTuples_AllChr[ChrBin]\n\ndef ChrAdjuster(chrname):\n\n    return 200000 * chromosome_to_number[chrname]\n\n\ndef reverseChrAdjuster(input):\n    x = {22: \"X\", 23: \"Y\", 24: \"M\"}\n    if int(input) >= 23:\n        chrname = x[input]\n    else:\n        chrname = str(int + 1)\n    return \"chr\" + chrname\n\n\ndef StrandAdjuster(strand):\n    if strand == 1:\n        return 0\n    if strand == -1:\n        return 200000 * number_of_chromosomes\n\n\ndef UnpickleExons(LocationDict, Picklefile, chrID):\n    AllExonsPos = []\n    AllExonsNeg = []\n\n\n    if LocationDict == 0:\n        return AllExonsPos, AllExonsNeg\n\n    ExonPickle = pickle.load(Picklefile)\n\n    for read in ExonPickle:\n        chrID, strand, exons = read\n        ExonsInRange = exons.keys()\n        if strand == 1:\n            #            print \"unpickling pos strand\"\n            AllExonsPos = exons\n        else:\n            #            print \"unpickling neg strand\"\n            AllExonsNeg = exons\n\n        if len(ExonsInRange) > 0:\n            for index in LocationDict:\n                start, stop = LocationDict[index]\n                #                print index + \":\" + str(start)+ \"-\" + str(stop)\n                #if chrID==\"Y\":\n                #    print str(start) + \":\" + str(stop) + \" \" + str(strand) + \"\\n\"\n                #print index\n                #print chrID\n                #print chromosome_to_number[chrID]\n                #print int(index[:-1]) + ChrAdjuster(chrID) + StrandAdjuster(strand)\n                if index[-1] == \"A\":\n                    ExonsListA[int(index[:-1]) + ChrAdjuster(chrID) + StrandAdjuster(strand)] = [x for x in ExonsInRange\n                                                                                                 if (\n                                                                                                 x[0] >= start and x[\n                                                                                                     0] <= stop) or (\n                                                                                                 x[1] >= start and x[\n                                                                                                     1] <= stop)]\n                # print \"# exons going into list A\"\n                #                    print len(ExonsListA[int(index[:-1])+ChrAdjuster(chrID)+StrandAdjuster(strand)])\n                #                    print int(index[:-1])+ChrAdjuster(chrID)+StrandAdjuster(strand)\n                if index[-1] == \"B\":\n                    ExonsListB[int(index[:-1]) + ChrAdjuster(chrID) + StrandAdjuster(strand)] = [x for x in ExonsInRange\n                                                                                                 if (\n                                                                                                 x[0] >= start and x[\n                                                                                                     0] <= stop) or (\n                                                                                                 x[1] >= start and x[\n                                                                                                     1] <= stop)]\n                    #                    print \"# exons going into list B\"\n                    #                    print len(ExonsListB[int(index[:-1])+ChrAdjuster(chrID)+StrandAdjuster(strand)])\n                    #                    print int(index[:-1])+ChrAdjuster(chrID)+StrandAdjuster(strand)\n                    #    print \"A plus strand\"\n                    #    print ExonsListA[ChrAdjuster(chrID):UI_counter+ChrAdjuster(chrID)]\n                    #    print \"A minus strand\"\n                    #    print ExonsListA[ChrAdjuster(chrID)+StrandAdjuster(-1):UI_counter+ChrAdjuster(chrID)+StrandAdjuster(-1)]\n                    #    print \"B plus strand\"\n                    #    print ExonsListB[ChrAdjuster(chrID):UI_counter+ChrAdjuster(chrID)]\n                    #    print \"B minus strand\"\n                    #    print ExonsListB[ChrAdjuster(chrID)+StrandAdjuster(-1):UI_counter+ChrAdjuster(chrID)+StrandAdjuster(-1)]\n    Picklefile.close()\n\n    #    print \"All Exons Pos:\"\n    #    print AllExonsPos\n    #    print \"All Exons Neg:\"\n    #    print AllExonsNeg\n    return AllExonsPos, AllExonsNeg\n\n\n#\n\n\ndef UnpickleSequence(chrnum, PickleRecfile, AllExonsPos, AllExonsNeg):\n    exonSeqRec = pickle.load(PickleRecfile)\n\n    # Exons A, + strand\n    counter = 0\n    for x in ExonsListA[ChrAdjuster(chrnum):ChrAdjuster(chrnum) + UI_counter]:\n        if x != 0 and len(x) > 0:\n            for i in x:\n                # print i\n                if NameListA[ChrAdjuster(chrnum) + counter] == 0:\n                    NameListA[ChrAdjuster(chrnum) + counter] = []\n                if SeqListA[ChrAdjuster(chrnum) + counter] == 0:\n                    SeqListA[ChrAdjuster(chrnum) + counter] = []\n\n                NameListA[ChrAdjuster(chrnum) + counter] += [AllExonsPos[i].qualifiers[\"gene_name\"][0]]\n                SeqListA[ChrAdjuster(chrnum) + counter] += [AllExonsPos[i].extract(exonSeqRec.seq)]\n\n                # print SeqListA[ChrAdjuster(chrnum)+counter]\n        counter += 1\n    # Exons A, - strand\n    counter = 0\n    for x in ExonsListA[ChrAdjuster(chrnum) + StrandAdjuster(-1):ChrAdjuster(chrnum) + UI_counter + StrandAdjuster(-1)]:\n        if x != 0 and len(x) > 0:\n            for i in x:\n                # print i\n                if NameListA[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] == 0:\n                    NameListA[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] = []\n                if SeqListA[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] == 0:\n                    SeqListA[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] = []\n\n                NameListA[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] += [\n                    AllExonsNeg[i].qualifiers[\"gene_name\"][0]]\n                SeqListA[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] += [AllExonsNeg[i].extract(exonSeqRec.seq)]\n\n                # print SeqListA[ChrAdjuster(chrnum)+counter+StrandAdjuster(-1)]\n        counter += 1\n\n    # # Exons B, + strand\n    counter = 0\n    for x in ExonsListB[ChrAdjuster(chrnum):ChrAdjuster(chrnum) + UI_counter]:\n        if x != 0 and len(x) > 0:\n            for i in x:\n\n                if NameListB[ChrAdjuster(chrnum) + counter] == 0:\n                    NameListB[ChrAdjuster(chrnum) + counter] = []\n                if SeqListB[ChrAdjuster(chrnum) + counter] == 0:\n                    SeqListB[ChrAdjuster(chrnum) + counter] = []\n\n                NameListB[ChrAdjuster(chrnum) + counter] += [AllExonsPos[i].qualifiers[\"gene_name\"][0]]\n                SeqListB[ChrAdjuster(chrnum) + counter] += [AllExonsPos[i].extract(exonSeqRec.seq)]\n        counter += 1\n    #\n    #    # exons B, - strand\n    counter = 0\n    for x in ExonsListB[ChrAdjuster(chrnum) + StrandAdjuster(-1):ChrAdjuster(chrnum) + UI_counter + StrandAdjuster(-1)]:\n        if x != 0 and len(x) > 0:\n            for i in x:\n                if NameListB[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] == 0:\n                    NameListB[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] = []\n                if SeqListB[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] == 0:\n                    SeqListB[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] = []\n\n                NameListB[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] += [\n                    AllExonsNeg[i].qualifiers[\"gene_name\"][0]]\n                SeqListB[ChrAdjuster(chrnum) + counter + StrandAdjuster(-1)] += [AllExonsNeg[i].extract(exonSeqRec.seq)]\n        counter += 1\n    PickleRecfile.close()\n\n\ndef JunctionEmpty(ExonsA, ExonsB):\n    if ExonsA in [0, []] or ExonsB in [0, []]:\n        return True\n    else:\n        return False\n\n\ndef MakeJunc(chrA, strandA, NameA, LocA, chrB, strandB, NameB, LocB):\n    x = {1: \"+\", -1: \"-\"}\n    if chrA != chrB:\n        JuncType = \"fusion\"\n    elif strandA != strandB:\n        JuncType = \"strandcross\"\n    elif strandA == 1 and strandB == 1:\n        if int(LocA) < int(LocB):\n            JuncType = \"reg\"\n        else:\n            JuncType = \"rev\"\n    else:\n        if int(LocA) > int(LocB):\n            JuncType = \"reg\"\n        else:\n            JuncType = \"rev\"\n\n    trueLocA = int(LocA)\n    trueLocB = int(LocB)\n\n    if strandA == -1:\n        trueLocA += 1\n    if strandB == 1:\n        trueLocB += 1\n\n    return str(chrA) + \":\" + str(NameA) + \":\" + str(trueLocA) + \":\" + x[strandA] + \"|\" + str(\n        chrB) + \":\" + str(NameB) + \":\" + str(trueLocB) + \":\" + x[strandB] + \"|\" + JuncType\n\n\ndef MakeSeq(seqA, seqB):\n    pad = \"N\" * (junction_length/2)\n    boundary = junction_length/2 + len(seqA)\n    Sequence = pad + seqA + seqB + pad\n    return Sequence[boundary - junction_length/2:boundary + junction_length/2]\n\n\n# def AddToLib(AllJunctions, Junction, Sequence, outputfile):\n#    if Junction not in AllJunctions:\n#        AllJunctions.append(Junction)\n#        outputfile.write(\">\"+str(Junction)+\"\\n\"+str(Sequence)+\"\\n\")\n#        return AllJunctions\n#    else:\n#        return AllJunctions\n\n\ndef MakePairs(outputfile, AllJunctions, UI, chrA, chrB, ExonsApos, ExonsAneg, ExonsBpos, ExonsBneg, SeqApos, SeqAneg,\n              SeqBpos, SeqBneg, NameApos, NameAneg, NameBpos, NameBneg):\n    #    print \"MakePairs\"\n    #    print ExonsApos\n    #    print ExonsAneg\n    #    print ExonsBpos\n    #    print ExonsBneg\n    #    print NameApos\n    #    print NameAneg\n    #    print NameBpos\n    #    print NameBneg\n    #\n    # case A pos, B pos\n    if not JunctionEmpty(ExonsApos, ExonsBpos):\n        #        print \"Making all pairs for A pos, B pos\"\n        for i in range(0, len(ExonsApos)):\n            for j in range(0, len(ExonsBpos)):\n                ABJunc = MakeJunc(chrA, 1, NameApos[i], ExonsApos[i][1], chrB, 1, NameBpos[j], ExonsBpos[j][0])\n                BAJunc = MakeJunc(chrB, 1, NameBpos[j], ExonsBpos[j][1], chrA, 1, NameApos[i], ExonsApos[i][0])\n                ABSeq = MakeSeq(SeqApos[i], SeqBpos[j])\n                BASeq = MakeSeq(SeqBpos[j], SeqApos[i])\n                #               AllJunctions = AddToLib(AllJunctions, ABJunc, ABSeq, outputfile)\n                #               AllJunctions = AddToLib(AllJunctions, BAJunc, BASeq, outputfile)\n                outputfile.write(\">\" + str(ABJunc) + \"\\n\" + str(ABSeq) + \"\\n\")\n                outputfile.write(\">\" + str(BAJunc) + \"\\n\" + str(BASeq) + \"\\n\")\n\n    # CASE A pos and B neg\n    if not JunctionEmpty(ExonsApos, ExonsBneg):\n        #        print \"Making all pairs for A pos, B neg\"\n        for i in range(0, len(ExonsApos)):\n            for j in range(0, len(ExonsBneg)):\n                ABJunc = MakeJunc(chrA, 1, NameApos[i], ExonsApos[i][1], chrB, -1, NameBneg[j], ExonsBneg[j][1])\n                BAJunc = MakeJunc(chrB, -1, NameBneg[j], ExonsBneg[j][0], chrA, 1, NameApos[i], ExonsApos[i][0])\n                ABSeq = MakeSeq(SeqApos[i], SeqBneg[j])\n                BASeq = MakeSeq(SeqBneg[j], SeqApos[i])\n                #               AllJunctions = AddToLib(AllJunctions, ABJunc, ABSeq, outputfile)\n                #               AllJunctions = AddToLib(AllJunctions, BAJunc, BASeq, outputfile)\n                outputfile.write(\">\" + str(ABJunc) + \"\\n\" + str(ABSeq) + \"\\n\")\n                outputfile.write(\">\" + str(BAJunc) + \"\\n\" + str(BASeq) + \"\\n\")\n\n                # CASE A neg and B pos\n    if not JunctionEmpty(ExonsAneg, ExonsBpos):\n        #        print \"Making all pairs for A neg, B pos\"\n        for i in range(0, len(ExonsAneg)):\n            for j in range(0, len(ExonsBpos)):\n                ABJunc = MakeJunc(chrA, -1, NameAneg[i], ExonsAneg[i][0], chrB, 1, NameBpos[j], ExonsBpos[j][0])\n                BAJunc = MakeJunc(chrB, 1, NameBpos[j], ExonsBpos[j][1], chrA, -1, NameAneg[i], ExonsAneg[i][1])\n                ABSeq = MakeSeq(SeqAneg[i], SeqBpos[j])\n                BASeq = MakeSeq(SeqBpos[j], SeqAneg[i])\n                #               AllJunctions = AddToLib(AllJunctions, ABJunc, ABSeq, outputfile)\n                #               AllJunctions = AddToLib(AllJunctions, BAJunc, BASeq, outputfile)\n                outputfile.write(\">\" + str(ABJunc) + \"\\n\" + str(ABSeq) + \"\\n\")\n                outputfile.write(\">\" + str(BAJunc) + \"\\n\" + str(BASeq) + \"\\n\")\n\n                # CASE A neg and B neg\n    if not JunctionEmpty(ExonsAneg, ExonsBneg):\n        #        print \"Making all pairs for A neg, B neg\"\n        for i in range(0, len(ExonsAneg)):\n            for j in range(0, len(ExonsBneg)):\n                ABJunc = MakeJunc(chrA, -1, NameAneg[i], ExonsAneg[i][0], chrB, -1, NameBneg[j], ExonsBneg[j][1])\n                BAJunc = MakeJunc(chrB, -1, NameBneg[j], ExonsBneg[j][0], chrA, -1, NameAneg[i], ExonsAneg[i][1])\n                ABSeq = MakeSeq(SeqAneg[i], SeqBneg[j])\n                BASeq = MakeSeq(SeqBneg[j], SeqAneg[i])\n                #               AllJunctions = AddToLib(AllJunctions, ABJunc, ABSeq, outputfile)\n                #               AllJunctions = AddToLib(AllJunctions, BAJunc, BASeq, outputfile)\n                outputfile.write(\">\" + str(ABJunc) + \"\\n\" + str(ABSeq) + \"\\n\")\n                outputfile.write(\">\" + str(BAJunc) + \"\\n\" + str(BASeq) + \"\\n\")\n\n\n\n\n                # ==================PROGRAM START ==============\n\n\nparser = argparse.ArgumentParser()\nparser.add_argument(\"-p\", \"--pickle\", required=True, help=\"path to pickle directory\")\nparser.add_argument(\"-f\", \"--infile\", required=True, help=\"file to unpickle\")\n#parser.add_argument(\"-nc\",\"--number_of_chromosomes\", required=True, help=\"number of chromosomes in PE_frequency file\")\n#parser.add_argument(\"-o\", \"--outDir\", required=True, help=\" directory to output files\")\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"unique identifying of sample\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\n\njunction_length = int(args.farJunctionLength)\n\nif args.pickle[-1] != \"/\":\n    path = args.pickle + \"/\"\nelse:\n    path = args.pickle\n\n#if args.outDir[-1] != \"/\":\n#    outDir = args.outDir + \"/\"\n#else:\n#    outDir = args.outDir\n\n##TEST ENVIRONMENT\n# path = \"/Users/Gillian/Desktop/pickles/\"\n# fastaDir = \"/Users/Gillian/Desktop/ERP000710output/\"\n\n\ninfilepath, infilename = os.path.split(args.infile)\nchromosome = infilename.split(\"_\")[1]\n\n#os.chdir(path)\nexonDir = path + \"exons\"\nrecordDir = path + \"records\"\nEMPTY_SEQUENCE = \"NOSEQUENCE\"\npatt_exonfilename = re.compile(\".+?exonsByStrand_(.+?)\\.pkl\")\npatt_exonfile = re.compile(\"exonsByStrand_.+\\.pkl\")\n\nfout = open(args.sample + \"_\" + chromosome + \"_FarJunctions_duplicates.fa\", mode=\"wb\")\n\n# ****SLICE FILE\nchromosome_to_number = {}\ncurrent_number = 0\nwith open(args.infile, mode=\"rU\") as f1:\n    number_of_chromosomes = int(f1.readline()) + 1\n    while True:\n        next_n_lines = list(islice(f1, 50000))\n        print \"next \" + str(len(next_n_lines)) + \"lines\"\n        if not next_n_lines: break\n        #        print next_n_lines\n        #        sys.stdout.flush()\n\n        UI_counter = 0  # UI stands for unique identifier\n        AllChrA = [0] * 200000*2*number_of_chromosomes  # 10 million possible read differences\n        AllChrB = [0] * 200000*2*number_of_chromosomes\n        LocationTuples_AllChr = [0] * number_of_chromosomes\n        ExonsListA = [0] * 200000*2*number_of_chromosomes  # 5 mill possible tuples, add batch of additional 1 mill slots if necessary\n        ExonsListB = [0] * 200000*2*number_of_chromosomes\n        SeqListA = [0] * 200000*2*number_of_chromosomes\n        SeqListB = [0] * 200000*2*number_of_chromosomes\n        NameListA = [0] * 200000*2*number_of_chromosomes\n        NameListB = [0] * 200000*2*number_of_chromosomes\n        AllJunctions = [0]\n        runtimestart = time.clock()\n\n        #        print \"reading in lines\"\n        for line_raw in next_n_lines:\n            line = line_raw.strip().split(\"\\t\")\n            #           print line\n            #           sys.stdout.flush()\n            AllChrA[UI_counter] = line[0]\n            AllChrB[UI_counter] = line[1]\n            RangeA = locationparameters(line[0])\n            RangeB = locationparameters(line[1])\n\n            if RangeA.chr not in chromosome_to_number:\n                chromosome_to_number[RangeA.chr] = current_number\n                current_number += 1\n\n            if RangeB.chr not in chromosome_to_number:\n                chromosome_to_number[RangeB.chr] = current_number\n                current_number += 1\n\n            SortedLocation(str(UI_counter) + \"A\", RangeA.chr, RangeA.start, RangeA.stop)\n            SortedLocation(str(UI_counter) + \"B\", RangeB.chr, RangeB.start, RangeB.stop)\n            UI_counter += 1\n        # if UI_counter==20: break\n\n        print(len(chromosome_to_number.keys()))\n\n        for chrname in chromosome_to_number.keys():\n            #if i < 22: chrnum = \"chr\" + str(i + 1)\n            #if i == 22: chrnum = \"chrX\"\n            #if i == 23: chrnum = \"chrY\"\n            #if i == 24: chrnum = \"chrM\"\n\n            exonfile = exonDir + \"/exonsByStrand_\" + chrname + \".pkl\"\n            recordfile = recordDir + \"/rec_\" + chrname + \".pkl\"\n\n            if patt_exonfile.search(exonfile):  # only parse if this is an exon pickled file\n                Picklefile = open(exonfile, 'rb')\n                PickleRecfile = open(recordfile, 'rb')\n\n                #                print \"getting Exon pickle \" + str(i)\n                #print chrname + \"\\n\"\n                #print chromosome_to_number\n                #print exonfile\n                ExonsOfChrPos, ExonsOfChrNeg = UnpickleExons(LocationTuples_AllChr[chromosome_to_number[chrname]], Picklefile, chromosome_to_number[chrname])\n\n                if len(ExonsOfChrPos) > 0 or len(ExonsOfChrNeg) > 0:\n                    #                    print \"getting sequence from pickle \" + str(i)\n                    UnpickleSequence(chrname, PickleRecfile, ExonsOfChrPos, ExonsOfChrNeg)\n\n        #print len(chromosome_to_number)\n                    #        print \"outputting junctions\"\n        for i in range(0, UI_counter):\n            RangeA = locationparameters(AllChrA[i])\n            RangeB = locationparameters(AllChrB[i])\n            APosStart = ChrAdjuster(RangeA.chr)\n            APosStop = ChrAdjuster(RangeA.chr) + UI_counter\n            ANegStart = ChrAdjuster(RangeA.chr) + StrandAdjuster(-1)\n            ANegStop = ChrAdjuster(RangeA.chr) + UI_counter + StrandAdjuster(-1)\n            BPosStart = ChrAdjuster(RangeB.chr)\n            BPosStop = ChrAdjuster(RangeB.chr) + UI_counter\n            BNegStart = ChrAdjuster(RangeB.chr) + StrandAdjuster(-1)\n            BNegStop = ChrAdjuster(RangeB.chr) + UI_counter + StrandAdjuster(-1)\n            MakePairs(fout, AllJunctions, i, RangeA.chr, RangeB.chr, ExonsListA[APosStart:APosStop][i],\n                      ExonsListA[ANegStart:ANegStop][i], ExonsListB[BPosStart:BPosStop][i],\n                      ExonsListB[BNegStart:BNegStop][i], SeqListA[APosStart:APosStop][i],\n                      SeqListA[ANegStart:ANegStop][i], SeqListB[BPosStart:BPosStop][i], SeqListB[BNegStart:BNegStop][i],\n                      NameListA[APosStart:APosStop][i], NameListA[ANegStart:ANegStop][i],\n                      NameListB[BPosStart:BPosStop][i], NameListB[BNegStart:BNegStop][i])\n        # print NameListA[APosStart:APosStop][i]\n        #            print NameListA[ANegStart:ANegStop][i]\n        #            print NameListB[BPosStart:BPosStop][i]\n        #            print NameListB[BNegStart:BNegStop][i]\n        #\n        #            print ExonsListA[APosStart:APosStop][i]\n        #            print ExonsListA[ANegStart:ANegStop][i]\n        #            print ExonsListB[BPosStart:BPosStop][i]\n        #            print ExonsListB[BNegStart:BNegStop][i]\n\n\n        fout.flush()\n        runtimestop = time.clock()\n        print \"Unpickler run time: \" + str(runtimestop - runtimestart)\n\n        del UI_counter  # UI stands for unique identifier\n        del AllChrA  # 10 million possible read differences\n        del AllChrB\n        del LocationTuples_AllChr\n        del ExonsListA  # 5 mill possible tuples, add batch of additional 1 mill slots if necessary\n        del ExonsListB\n        del SeqListA\n        del SeqListB\n        del NameListA\n        del NameListB\n        del AllJunctions\n\nfout.close()\nf1.close()\n\n## ===========REMOVE DUPLICATES====================\n\nf1 = open(args.sample + \"_\" + chromosome + \"_FarJunctions_duplicates.fa\", mode=\"rb\")\nfout = open(args.sample + \"_\" + chromosome + \"FarJunctions.fa\", mode=\"wb\")\n\njunctiondict = {}\n\ncounter = 0\n\nfor line in f1:\n    start = time.clock()\n    if line not in junctiondict and line[0] == \">\":\n        junctiondict[line] = 1\n        fout.write(line + f1.next())\n        counter += 1\n        if counter % 50000 == 0:\n            fout.flush()\n# print \"flushing, \" + str(time.clock()-start)\nf1.close()\nfout.close()"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "junction_length": 10,
            "pickle_tar": {
              "path": "/path/to/pickle_tar.tar.gz",
              "class": "File",
              "size": 0,
              "secondaryFiles": []
            },
            "input_file": {
              "path": "/path/to/input_file.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "sample_name"
              }
            }
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520437962,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520437982,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 12 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520438121,
            "sbg:revision": 2,
            "sbg:revisionNotes": "tar.gz pickle_tar input file",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1527759656,
            "sbg:revision": 3,
            "sbg:revisionNotes": "only one end of exon need to be in the range",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1532512296,
            "sbg:revision": 4,
            "sbg:revisionNotes": "junction_length as parameter",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1532538496,
            "sbg:revision": 5,
            "sbg:revisionNotes": "() fixed",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#input_file",
              "glob": "*FarJunctions.fa"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#far_junctions"
          }
        ],
        "label": "MACHETE makeJunctions new",
        "sbg:latestRevision": 5,
        "sbg:revisionNotes": "() fixed",
        "y": 367.61308364883587,
        "inputs": [
          {
            "type": [
              "null",
              "File"
            ],
            "id": "#pickle_tar",
            "required": false,
            "sbg:fileTypes": "TAR.GZ, tar.gz"
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_file",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n\treturn \"tar -zxvf \" + $job.inputs.pickle_tar.path\n}",
            "engine": "#cwl-js-engine"
          },
          "&&",
          "python",
          "makeJunctions.py",
          {
            "class": "Expression",
            "script": "{\n  \tname = $job.inputs.pickle_tar.path.split('/').pop()\n\treturn \" -p \" + name.split('.').slice(0, 1)\n}",
            "engine": "#cwl-js-engine"
          }
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 5,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/makejunctions:machete"
          }
        ],
        "sbg:createdOn": 1520437962
      },
      "inputs": [
        {
          "id": "#MACHETE_makeJunctions_new.pickle_tar",
          "source": [
            "#pickle_tar"
          ]
        },
        {
          "id": "#MACHETE_makeJunctions_new.junction_length",
          "default": 300
        },
        {
          "id": "#MACHETE_makeJunctions_new.input_file",
          "source": [
            "#MACHETE_DistantPE_devide_equally.distant_pe_frequency"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_makeJunctions_new.far_junctions"
        }
      ],
      "sbg:x": 2121.7069410665035,
      "sbg:y": 367.61308364883587,
      "scatter": "#MACHETE_makeJunctions_new.input_file"
    },
    {
      "id": "#MACHETE_GetBasesAroundJunctionPoint_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python get_bases_around_junction_point.py  -s SAMPLE",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/getbasesaroundjunctionpoint/3",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.far_junctions && $job.inputs.far_junctions.metadata && $job.inputs.far_junctions.metadata.sample_id)\n    {\n    \treturn \"-s \" + $job.inputs.far_junctions.metadata.sample_id\n    }\n  \treturn \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 10
          }
        ],
        "x": 3276.4708667016002,
        "id": "milos_jordanski/spachete-salzman-collaboration/getbasesaroundjunctionpoint/3",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532558915,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "get_bases_around_junction_point.py",
                "fileContent": "import argparse\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\"-fj\", \"--farJunctions\", required=True, help=\"farJunctions\")\nparser.add_argument(\"-nb\", \"--number_of_bases\", required=True)\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\n\nnum_bases = int(args.number_of_bases)\njunction_length = int(args.farJunctionLength)\n\nwith open(args.sample + \"_FarJunctions_3prime.fa\", \"w\") as f3prime:\n    with open(args.sample + \"_FarJunctions_5prime.fa\", \"w\") as f5prime:\n        with open(args.farJunctions) as f:\n            while True:\n                line1 = f.readline()\n                if not line1:\n                    break\n                line2 = f.readline()\n                if not line2:\n                    break\n                f3prime.write(line1)\n                f3prime.write(line2[junction_length/2 : junction_length/2 + num_bases] + \"\\n\")\n\n                f5prime.write(line1)\n                f5prime.write(line2[junction_length/2 - num_bases : junction_length/2] + \"\\n\")"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "junction_length": 6,
            "number_of_bases": 8,
            "far_junctions": {
              "path": "/path/to/far_junctions.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "SAMPLE"
              }
            }
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520889839,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520889871,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1532513340,
            "sbg:revision": 2,
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1532558915,
            "sbg:revision": 3,
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#far_junctions",
              "glob": "*5prime.fa"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#5prime_fasta"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#far_junctions",
              "glob": "*3prime.fa"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#3prime_fasta"
          }
        ],
        "label": "MACHETE GetBasesAroundJunctionPoint Known",
        "sbg:latestRevision": 3,
        "sbg:revisionNotes": "junction_length parameter added",
        "y": 1284.7244511051824,
        "inputs": [
          {
            "sbg:includeInPorts": false,
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_bases",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-nb"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "--farJunctions",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fj"
            },
            "id": "#far_junctions",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "get_bases_around_junction_point.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 3,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520889839
      },
      "inputs": [
        {
          "id": "#MACHETE_GetBasesAroundJunctionPoint_Known.number_of_bases",
          "default": 20
        },
        {
          "id": "#MACHETE_GetBasesAroundJunctionPoint_Known.junction_length",
          "default": 300
        },
        {
          "id": "#MACHETE_GetBasesAroundJunctionPoint_Known.far_junctions",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate_Known.far_junctions"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_GetBasesAroundJunctionPoint_Known.5prime_fasta"
        },
        {
          "id": "#MACHETE_GetBasesAroundJunctionPoint_Known.3prime_fasta"
        }
      ],
      "sbg:x": 3276.4708667016002,
      "sbg:y": 1284.7244511051824
    },
    {
      "id": "#MACHETE_GetBasesAroundJunctionPoint",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "python get_bases_around_junction_point.py  -s SAMPLE",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/getbasesaroundjunctionpoint/3",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.far_junctions && $job.inputs.far_junctions.metadata && $job.inputs.far_junctions.metadata.sample_id)\n    {\n    \treturn \"-s \" + $job.inputs.far_junctions.metadata.sample_id\n    }\n  \treturn \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 10
          }
        ],
        "x": 3683.530231963491,
        "id": "milos_jordanski/spachete-salzman-collaboration/getbasesaroundjunctionpoint/3",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1532558915,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "class": "CreateFileRequirement",
            "fileDef": [
              {
                "filename": "get_bases_around_junction_point.py",
                "fileContent": "import argparse\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\"-fj\", \"--farJunctions\", required=True, help=\"farJunctions\")\nparser.add_argument(\"-nb\", \"--number_of_bases\", required=True)\nparser.add_argument(\"-s\", \"--sample\", required=True, help=\"sample name\")\nparser.add_argument(\"-fjl\", \"--farJunctionLength\", required=True, help=\"length of fusion junction candidates\")\n\nargs = parser.parse_args()\n\nnum_bases = int(args.number_of_bases)\njunction_length = int(args.farJunctionLength)\n\nwith open(args.sample + \"_FarJunctions_3prime.fa\", \"w\") as f3prime:\n    with open(args.sample + \"_FarJunctions_5prime.fa\", \"w\") as f5prime:\n        with open(args.farJunctions) as f:\n            while True:\n                line1 = f.readline()\n                if not line1:\n                    break\n                line2 = f.readline()\n                if not line2:\n                    break\n                f3prime.write(line1)\n                f3prime.write(line2[junction_length/2 : junction_length/2 + num_bases] + \"\\n\")\n\n                f5prime.write(line1)\n                f5prime.write(line2[junction_length/2 - num_bases : junction_length/2] + \"\\n\")"
              }
            ]
          },
          {
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 1,
            "mem": 1000
          },
          "inputs": {
            "junction_length": 6,
            "number_of_bases": 8,
            "far_junctions": {
              "path": "/path/to/far_junctions.ext",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "sample_id": "SAMPLE"
              }
            }
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520889839,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520889871,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1532513340,
            "sbg:revision": 2,
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1532558915,
            "sbg:revision": 3,
            "sbg:revisionNotes": "junction_length parameter added",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#far_junctions",
              "glob": "*5prime.fa"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#5prime_fasta"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#far_junctions",
              "glob": "*3prime.fa"
            },
            "type": [
              "null",
              "File"
            ],
            "id": "#3prime_fasta"
          }
        ],
        "label": "MACHETE GetBasesAroundJunctionPoint",
        "sbg:latestRevision": 3,
        "sbg:revisionNotes": "junction_length parameter added",
        "y": 1292.597718062921,
        "inputs": [
          {
            "sbg:includeInPorts": false,
            "required": false,
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_bases",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-nb"
            },
            "sbg:stageInput": null
          },
          {
            "sbg:includeInPorts": false,
            "sbg:altPrefix": "--farJunctionLength",
            "required": false,
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fjl"
            },
            "id": "#junction_length",
            "type": [
              "null",
              "int"
            ],
            "sbg:stageInput": null
          },
          {
            "sbg:altPrefix": "--farJunctions",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-fj"
            },
            "id": "#far_junctions",
            "type": [
              "null",
              "File"
            ],
            "required": false
          }
        ],
        "description": "",
        "class": "CommandLineTool",
        "sbg:modifiedBy": "jordanski.milos",
        "sbg:image_url": null,
        "appUrl": "/u/milos_jordanski/spachete-salzman-collaboration/apps/#milos_jordanski/spachete-salzman-collaboration/getbasesaroundjunctionpoint/3",
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          "python",
          "get_bases_around_junction_point.py"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:revision": 3,
        "sbg:publisher": "sbg",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "hints": [
          {
            "class": "sbg:CPURequirement",
            "value": 1
          },
          {
            "class": "sbg:MemRequirement",
            "value": 1000
          },
          {
            "class": "DockerRequirement",
            "dockerImageId": "",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/python:2.7"
          }
        ],
        "sbg:createdOn": 1520889839
      },
      "inputs": [
        {
          "id": "#MACHETE_GetBasesAroundJunctionPoint.number_of_bases",
          "default": 20
        },
        {
          "id": "#MACHETE_GetBasesAroundJunctionPoint.junction_length",
          "default": 300
        },
        {
          "id": "#MACHETE_GetBasesAroundJunctionPoint.far_junctions",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate.far_junctions"
          ]
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_GetBasesAroundJunctionPoint.5prime_fasta"
        },
        {
          "id": "#MACHETE_GetBasesAroundJunctionPoint.3prime_fasta"
        }
      ],
      "sbg:x": 3683.530231963491,
      "sbg:y": 1292.597718062921
    },
    {
      "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 615.0001559074178,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "KNIFE Bowtie2-2.3.4.1 Aligner SCRAMBLED JUNCTIONS",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 406.4772201298409,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.unpaired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.unpaired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.trim_from_5"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.trim_from_3"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.threads",
          "default": 16
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.suppress_sam_records",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.suppress_header_lines"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.sort_sam"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.skip_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.set_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.set_match_bonus"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.seed_substring_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.seed_extension_attempts"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.report_k_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.report_all_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.reorder_output"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.read_sequence",
          "source": [
            "#Trim_Galore_Skip_New.merged"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.quality_scale"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.preset_option"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.paired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.paired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.output_file_suffix",
          "default": "scrambled"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.omit_seq_and_qual"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.number_of_cpu",
          "default": 6
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.non_deterministic"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.minimum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.maximum_mismatch_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.maximum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.max_number_of_re_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.mates_alignment_orientation"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.integer_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.input_fasta_files"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.ignore_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.function_i"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.dynamic_padding"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.dont_align_reverse_complement"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.dont_align_forward"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.disallow_gaps"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.disable_unpaired_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.disable_overlapping_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.disable_dovetail_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.disable_discordant_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.disable_containing_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.disable_1_mismatch_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.constant_i_a"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.coefficient_nceil_b",
          "default": 1
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.coefficient_i_b"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_scrambled_junctions"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.ambiguous_character_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.allowed_mismatch_number"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.alignment_mode"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.unaligned_reads_only"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.result_sam_file"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.aligned_reads_only"
        }
      ],
      "sbg:x": 615.0001559074178,
      "sbg:y": 406.4772201298409,
      "scatter": "#KNIFE_Bowtie2_2_3_4_1_Aligner_SCRAMBLED_JUNCTIONS.read_sequence"
    },
    {
      "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 609.9999999999999,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "KNIFE Bowtie2-2.3.4.1 Aligner REGULAR JUNCTIONS",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 252.01562499999991,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.unpaired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.unpaired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.trim_from_5"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.trim_from_3"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.threads",
          "default": 16
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.suppress_sam_records",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.suppress_header_lines"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.sort_sam",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.skip_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.set_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.set_match_bonus"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.seed_substring_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.seed_extension_attempts"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.report_k_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.report_all_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.reorder_output"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.read_sequence",
          "source": [
            "#Trim_Galore_Skip_New.merged"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.quality_scale"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.preset_option"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.paired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.paired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.output_file_suffix",
          "default": "regular"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.omit_seq_and_qual"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.number_of_cpu",
          "default": 7
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.non_deterministic"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.minimum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.maximum_mismatch_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.maximum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.max_number_of_re_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.mates_alignment_orientation"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.integer_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.input_fasta_files"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.ignore_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.function_i"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.dynamic_padding"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.dont_align_reverse_complement"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.dont_align_forward"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.disallow_gaps"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.disable_unpaired_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.disable_overlapping_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.disable_dovetail_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.disable_discordant_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.disable_containing_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.disable_1_mismatch_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.constant_i_a"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.coefficient_nceil_b",
          "default": 1
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.coefficient_i_b"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_junctions"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.ambiguous_character_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.allowed_mismatch_number"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.alignment_mode"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.unaligned_reads_only"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.result_sam_file"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.aligned_reads_only"
        }
      ],
      "sbg:x": 609.9999999999999,
      "sbg:y": 252.01562499999991,
      "scatter": "#KNIFE_Bowtie2_2_3_4_1_Aligner_REGULAR_JUNCTIONS.read_sequence"
    },
    {
      "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 608,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "KNIFE Bowtie2-2.3.4.1 Aligner RIBOSOMAL",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 110.015625,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.unpaired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.unpaired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.trim_from_5"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.trim_from_3"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.threads",
          "default": 16
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.suppress_sam_records",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.suppress_header_lines"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.sort_sam"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.skip_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.set_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.set_match_bonus"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.seed_substring_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.seed_extension_attempts"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.report_k_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.report_all_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.reorder_output"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.read_sequence",
          "source": [
            "#Trim_Galore_Skip_New.merged"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.quality_scale"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.preset_option"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.paired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.paired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.output_file_suffix",
          "default": "ribosomal"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.omit_seq_and_qual"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.number_of_cpu",
          "default": 5
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.non_deterministic"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.minimum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.maximum_mismatch_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.maximum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.max_number_of_re_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.mates_alignment_orientation"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.integer_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.input_fasta_files"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.ignore_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.function_n_ceil"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.function_i"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.dynamic_padding"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.dont_align_reverse_complement"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.dont_align_forward"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.disallow_gaps"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.disable_unpaired_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.disable_overlapping_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.disable_dovetail_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.disable_discordant_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.disable_containing_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.disable_1_mismatch_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.constant_nceil_a"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.constant_i_a"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.coefficient_nceil_b"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.coefficient_i_b"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_ribosomal"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.ambiguous_character_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.allowed_mismatch_number"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.alignment_mode"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.unaligned_reads_only"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.result_sam_file"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.aligned_reads_only"
        }
      ],
      "sbg:x": 608,
      "sbg:y": 110.015625,
      "scatter": "#KNIFE_Bowtie2_2_3_4_1_Aligner_RIBOSOMAL.read_sequence"
    },
    {
      "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 603.9999999999998,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "KNIFE Bowtie2-2.3.4.1 Aligner GENOME",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": -32.984374999999964,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.unpaired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.unpaired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.trim_from_5"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.trim_from_3"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.threads",
          "default": 16
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.suppress_sam_records",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.suppress_header_lines"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.sort_sam",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.skip_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.set_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.set_match_bonus"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.seed_substring_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.seed_extension_attempts"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.report_k_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.report_all_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.reorder_output"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.read_sequence",
          "source": [
            "#Trim_Galore_Skip_New.merged"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.quality_scale"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.preset_option"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.paired_unaligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.paired_aligned_reads"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.output_file_suffix",
          "default": "genome"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.omit_seq_and_qual"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.number_of_cpu",
          "default": 9
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.non_deterministic"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.minimum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.maximum_mismatch_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.maximum_fragment_length"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.max_number_of_re_seed"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.mates_alignment_orientation"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.integer_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.input_fasta_files"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.ignore_qualities"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.function_n_ceil"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.function_i"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.dynamic_padding"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.dont_align_reverse_complement"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.dont_align_forward"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.disallow_gaps"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.disable_unpaired_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.disable_overlapping_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.disable_dovetail_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.disable_discordant_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.disable_containing_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.disable_1_mismatch_alignments"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.constant_nceil_a"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.constant_i_a"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.coefficient_nceil_b"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.coefficient_i_b"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.ambiguous_character_penalty"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.allowed_mismatch_number"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.alignment_mode"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.unaligned_reads_only"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.result_sam_file"
        },
        {
          "id": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.aligned_reads_only"
        }
      ],
      "sbg:x": 603.9999999999998,
      "sbg:y": -32.984374999999964,
      "scatter": "#KNIFE_Bowtie2_2_3_4_1_Aligner_GENOME.read_sequence"
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 2590.0589105398194,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner unaligned to FJ",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 371.4862324329658,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.unpaired_unaligned_reads",
          "default": "raw"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.threads",
          "default": 16
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.read_sequence",
          "source": [
            "#getUnalignedReads_2.unaligned_fastq",
            "#getUnalignedReads_1.unaligned_fastq"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.output_file_suffix"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.number_of_cpu",
          "default": 1
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.input_fasta_files"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.coefficient_nceil_b",
          "default": 1
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.bowtie_index_archive",
          "source": [
            "#MACHETE_Bowtie2_2_3_4_1_Indexer_Far_Junctions.bowtie_index_archive"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.aligned_reads_only"
        }
      ],
      "sbg:x": 2590.0589105398194,
      "sbg:y": 371.4862324329658,
      "scatter": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_FJ.read_sequence"
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3380.412074843086,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner unaligned to Filtered FJ",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 351.7803555397276,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.unpaired_unaligned_reads",
          "default": "raw"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.threads",
          "default": 16
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.read_sequence",
          "source": [
            "#getUnalignedReads_2.unaligned_fastq",
            "#getUnalignedReads_1.unaligned_fastq"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.output_file_suffix"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.number_of_cpu",
          "default": 1
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.input_fasta_files"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.coefficient_nceil_b",
          "default": 1
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.bowtie_index_archive",
          "source": [
            "#MACHETE_Bowtie2_Indexer_Filtered_FJ.bowtie_index_archive"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.aligned_reads_only"
        }
      ],
      "sbg:x": 3380.412074843086,
      "sbg:y": 351.7803555397276,
      "scatter": "#MACHETE_Bowtie2_2_3_4_1_Aligner_unaligned_to_Filtered_FJ.read_sequence"
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3659.706584018012,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Genome FJ",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 147.7803472635509,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.threads",
          "default": 5
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.read_sequence",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.output_file_suffix",
          "default": "genome_FJ_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.number_of_cpu",
          "default": 5
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.coefficient_nceil_b",
          "default": 100
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.aligned_reads_only"
        }
      ],
      "sbg:x": 3659.706584018012,
      "sbg:y": 147.7803472635509
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3992.058936427622,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Genome PE",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 145.19210523761373,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.threads",
          "default": 6
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.read_sequence",
          "source": [
            "#MACHETE_SplitFastaforBadFJ.fusion_junction_fq1",
            "#MACHETE_SplitFastaforBadFJ.fusion_junction_fq2"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.output_file_suffix",
          "default": "genome_PE_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.number_of_cpu",
          "default": 6
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.maximum_fragment_length",
          "default": 50000
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.ignore_paired_end_metadata",
          "default": false
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Genome_PE.aligned_reads_only"
        }
      ],
      "sbg:x": 3992.058936427622,
      "sbg:y": 145.19210523761373
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3988.000518957236,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Transcriptome PE",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 275.95682746607696,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.threads",
          "default": 6
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.read_sequence",
          "source": [
            "#MACHETE_SplitFastaforBadFJ.fusion_junction_fq2",
            "#MACHETE_SplitFastaforBadFJ.fusion_junction_fq1"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.output_file_suffix",
          "default": "transcriptome_PE_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.number_of_cpu",
          "default": 6
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.maximum_fragment_length",
          "default": 50000
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.ignore_paired_end_metadata"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_transcriptome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Transcriptome_PE.aligned_reads_only"
        }
      ],
      "sbg:x": 3988.000518957236,
      "sbg:y": 275.95682746607696
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3660.1767888036215,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Transcriptome FJ",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 271.83917802801744,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.threads",
          "default": 5
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.read_sequence",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.output_file_suffix",
          "default": "transcriptome_FJ_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.number_of_cpu",
          "default": 5
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.coefficient_nceil_b",
          "default": 100
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_transcriptome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.aligned_reads_only"
        }
      ],
      "sbg:x": 3660.1767888036215,
      "sbg:y": 271.83917802801744
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3999.058936623966,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Regular PE",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 438.2509351061548,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.read_sequence",
          "source": [
            "#MACHETE_SplitFastaforBadFJ.fusion_junction_fq2",
            "#MACHETE_SplitFastaforBadFJ.fusion_junction_fq1"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.output_file_suffix",
          "default": "regular_PE_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.number_of_cpu",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.maximum_fragment_length",
          "default": 50000
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.ignore_paired_end_metadata"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Regular_PE.aligned_reads_only"
        }
      ],
      "sbg:x": 3999.058936623966,
      "sbg:y": 438.2509351061548
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3665.413142828004,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Regular Junction FJ",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 405.309843304689,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.read_sequence",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.output_file_suffix",
          "default": "regular_FJ_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.number_of_cpu",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.coefficient_nceil_b",
          "default": 100
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.aligned_reads_only"
        }
      ],
      "sbg:x": 3665.413142828004,
      "sbg:y": 405.309843304689
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3995.1772217664557,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Scrambled PE",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 563.5045051809947,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.read_sequence",
          "source": [
            "#MACHETE_SplitFastaforBadFJ.fusion_junction_fq1",
            "#MACHETE_SplitFastaforBadFJ.fusion_junction_fq2"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.output_file_suffix",
          "default": "scrambled_PE_SCRAMBLED"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.number_of_cpu",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.maximum_fragment_length",
          "default": 50000
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.ignore_paired_end_metadata"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_scrambled_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Scrambled_PE.aligned_reads_only"
        }
      ],
      "sbg:x": 3995.1772217664557,
      "sbg:y": 563.5045051809947
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3667.2359964559,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Scrambled Junction FJ",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 539.9568505324567,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.read_sequence",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.output_file_suffix",
          "default": "scrambled_FJ_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.number_of_cpu",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.coefficient_nceil_b",
          "default": 100
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_scrambled_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.aligned_reads_only"
        }
      ],
      "sbg:x": 3667.2359964559,
      "sbg:y": 539.9568505324567
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 4004.7061070438954,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Genome PE Known",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 690.6067323392884,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.threads",
          "default": 6
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.read_sequence",
          "source": [
            "#SplitFastaforBadFJ.fusion_junction_fq1",
            "#SplitFastaforBadFJ.fusion_junction_fq2"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.output_file_suffix",
          "default": "genome_PE_Known_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.number_of_cpu",
          "default": 6
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.maximum_fragment_length",
          "default": 50000
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.ignore_paired_end_metadata"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_PE_Known.aligned_reads_only"
        }
      ],
      "sbg:x": 4004.7061070438954,
      "sbg:y": 690.6067323392884
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3680.000833960161,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Genome FJ Known",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 694.1363776321114,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.threads",
          "default": 5
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.read_sequence",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate_Known.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.output_file_suffix",
          "default": "genome_FJ_Known_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.number_of_cpu",
          "default": 5
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.coefficient_nceil_b",
          "default": 100
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.aligned_reads_only"
        }
      ],
      "sbg:x": 3680.000833960161,
      "sbg:y": 694.1363776321114
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 4004.7067415310235,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Transcriptome PE Known",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 817.6655144416145,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.threads",
          "default": 6
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.read_sequence",
          "source": [
            "#SplitFastaforBadFJ.fusion_junction_fq2",
            "#SplitFastaforBadFJ.fusion_junction_fq1"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.output_file_suffix",
          "default": "transcriptome_PE_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.number_of_cpu",
          "default": 6
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.maximum_fragment_length",
          "default": 50000
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.ignore_paired_end_metadata"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_transcriptome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_PE_Known.aligned_reads_only"
        }
      ],
      "sbg:x": 4004.7067415310235,
      "sbg:y": 817.6655144416145
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3677.64755679993,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Transcriptome FJ Known",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 810.6068427015185,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.threads",
          "default": 5
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.read_sequence",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate_Known.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.output_file_suffix",
          "default": "transcriptome_FJ_Known_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.number_of_cpu",
          "default": 5
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.coefficient_nceil_b",
          "default": 1
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_transcriptome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.aligned_reads_only"
        }
      ],
      "sbg:x": 3677.64755679993,
      "sbg:y": 810.6068427015185
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3675.2947662644065,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Regular Junction FJ Known",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 932.9597608842083,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.read_sequence",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate_Known.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.output_file_suffix",
          "default": "regular_FJ_Known_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.number_of_cpu",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.coefficient_nceil_b",
          "default": 100
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.aligned_reads_only"
        }
      ],
      "sbg:x": 3675.2947662644065,
      "sbg:y": 932.9597608842083
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 4005.8826963233364,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Regular Junctions PE Known",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 937.6655351650572,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.read_sequence",
          "source": [
            "#SplitFastaforBadFJ.fusion_junction_fq1",
            "#SplitFastaforBadFJ.fusion_junction_fq2"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.output_file_suffix",
          "default": "regular_PE_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.number_of_cpu",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.maximum_fragment_length",
          "default": 50000
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.ignore_paired_end_metadata"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junctions_PE_Known.aligned_reads_only"
        }
      ],
      "sbg:x": 4005.8826963233364,
      "sbg:y": 937.6655351650572
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 4008.0558845844103,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Scrambled Junctions PE Known",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 1077.4848470206896,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.read_sequence",
          "source": [
            "#SplitFastaforBadFJ.fusion_junction_fq2",
            "#SplitFastaforBadFJ.fusion_junction_fq1"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.output_file_suffix",
          "default": "scrambled_PE_SCRAMBLED"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.number_of_cpu",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.minimum_fragment_length",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.maximum_fragment_length",
          "default": 50000
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.mates_alignment_orientation",
          "default": "--ff"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.ignore_paired_end_metadata"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.disable_unpaired_alignments",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_scrambled_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junctions_PE_Known.aligned_reads_only"
        }
      ],
      "sbg:x": 4008.0558845844103,
      "sbg:y": 1077.4848470206896
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3671.7651921044694,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Scrambled Junction FJ Known",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 1062.3716594608886,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.read_sequence",
          "source": [
            "#MACHETE_combine_fasta_files_by_coordinate_Known.far_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.output_file_suffix",
          "default": "scrambled_FJ_Known_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.number_of_cpu",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.coefficient_nceil_b",
          "default": 100
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_scrambled_junctions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.ambiguous_character_penalty",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.aligned_reads_only"
        }
      ],
      "sbg:x": 3671.7651921044694,
      "sbg:y": 1062.3716594608886
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 4686.11777866588,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner FJ Indels R1",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 238.48622451152877,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.threads",
          "default": 16
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.read_sequence",
          "source": [
            "#MACHETE_Split_Fastq_Files.fastq_file_1"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.output_file_suffix",
          "default": "FJIndels1_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.number_of_cpu",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.input_fasta_files",
          "default": false
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.bowtie_index_archive",
          "source": [
            "#MACHETE_Bowtie2_Indexer_Indels.bowtie_index_archive"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.aligned_reads_only"
        }
      ],
      "sbg:x": 4686.11777866588,
      "sbg:y": 238.48622451152877,
      "scatter": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R1.bowtie_index_archive"
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 4694.235425556408,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner FJ Indels R2",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 470.48622989698373,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.threads",
          "default": 16
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.read_sequence",
          "source": [
            "#MACHETE_Split_Fastq_Files.fastq_file_2"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.output_file_suffix",
          "default": "FJIndels2_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.number_of_cpu",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.input_fasta_files"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.bowtie_index_archive",
          "source": [
            "#MACHETE_Bowtie2_Indexer_Indels.bowtie_index_archive"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.aligned_reads_only"
        }
      ],
      "sbg:x": 4694.235425556408,
      "sbg:y": 470.48622989698373,
      "scatter": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Indels_R2.bowtie_index_archive"
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 5003.294171884397,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Regular Indels R1",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 210.78033703217557,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.threads",
          "default": 16
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.read_sequence",
          "source": [
            "#getUnalignedReads_1.unaligned_fastq"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.output_file_suffix",
          "default": "RegIndels1"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.number_of_cpu",
          "default": 4
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.input_fasta_files"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.aligned_reads_only"
        }
      ],
      "sbg:x": 5003.294171884397,
      "sbg:y": 210.78033703217557,
      "scatter": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R1.bowtie_index_archive"
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 5007.824186188142,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Regular Indels R2",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 472.01583338323184,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.threads",
          "default": 16
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.read_sequence",
          "source": [
            "#getUnalignedReads_2.unaligned_fastq"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.output_file_suffix",
          "default": "RegIndels2"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.number_of_cpu",
          "default": 4
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.input_fasta_files"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_regular_indels"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.aligned_reads_only"
        }
      ],
      "sbg:x": 5007.824186188142,
      "sbg:y": 472.01583338323184,
      "scatter": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Indels_R2.bowtie_index_archive"
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 4635.294219238122,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner FJ Known Indels R1",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 748.2536903769293,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.read_sequence",
          "source": [
            "#MACHETE_Split_Fastq_Files_Known.fastq_file_1"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.output_file_suffix",
          "default": "FJIndels1_Known_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.number_of_cpu",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.input_fasta_files"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.bowtie_index_archive",
          "source": [
            "#Bowtie2_2_3_4_1_Indexer.bowtie_index_archive"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.aligned_reads_only"
        }
      ],
      "sbg:x": 4635.294219238122,
      "sbg:y": 748.2536903769293,
      "scatter": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R1.bowtie_index_archive"
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 4634.117921116448,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner FJ Known Indels R2",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 934.136037728056,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.threads",
          "default": 8
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.read_sequence",
          "source": [
            "#MACHETE_Split_Fastq_Files_Known.fastq_file_2"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.output_file_suffix",
          "default": "FJIndels2_Known_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.number_of_cpu",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.input_fasta_files"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.bowtie_index_archive",
          "source": [
            "#Bowtie2_2_3_4_1_Indexer.bowtie_index_archive"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.aligned_reads_only"
        }
      ],
      "sbg:x": 4634.117921116448,
      "sbg:y": 934.136037728056,
      "scatter": "#MACHETE_Bowtie2_2_3_4_1_Aligner_FJ_Known_Indels_R2.bowtie_index_archive"
    },
    {
      "id": "#MACHETE_Bowtie2_Aligner_5_prime",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3826.7898193630176,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2 Aligner 5 prime",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 1223.7297467246674,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.threads",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.suppress_sam_records"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.suppress_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.read_sequence",
          "source": [
            "#MACHETE_GetBasesAroundJunctionPoint.5prime_fasta"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.output_file_suffix",
          "default": "_5prime_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.number_of_cpu",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime.aligned_reads_only"
        }
      ],
      "sbg:x": 3826.7898193630176,
      "sbg:y": 1223.7297467246674
    },
    {
      "id": "#MACHETE_Bowtie2_Aligner_3_prime",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3826.6973447929327,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2 Aligner 3 prime",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 1371.4213307982077,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.threads",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.suppress_sam_records"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.suppress_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.read_sequence",
          "source": [
            "#MACHETE_GetBasesAroundJunctionPoint.3prime_fasta"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.output_file_suffix",
          "default": "_3prime_MACHETE"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.number_of_cpu",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime.aligned_reads_only"
        }
      ],
      "sbg:x": 3826.6973447929327,
      "sbg:y": 1371.4213307982077
    },
    {
      "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3441.1768739165823,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2 Aligner 5 prime Known",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 1203.5478836381535,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.threads",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.suppress_sam_records"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.suppress_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.read_sequence",
          "source": [
            "#MACHETE_GetBasesAroundJunctionPoint_Known.5prime_fasta"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.output_file_suffix",
          "default": "_5prime_MACHETE_Known"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.number_of_cpu",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.ignore_paired_end_metadata",
          "default": false
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_5_prime_Known.aligned_reads_only"
        }
      ],
      "sbg:x": 3441.1768739165823,
      "sbg:y": 1203.5478836381535
    },
    {
      "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3434.118353006557,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2 Aligner 3 prime Known",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 1359.6565596431012,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.unpaired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.threads",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.suppress_sam_records"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.suppress_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.reference_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.read_sequence",
          "source": [
            "#MACHETE_GetBasesAroundJunctionPoint_Known.3prime_fasta"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.read_gap_penalties"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.output_file_suffix",
          "default": "_3prime_MACHETE_Known"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.number_of_cpu",
          "default": 2
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.input_fasta_files",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.function_score_min"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.function_n_ceil"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.constant_scoremin_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.constant_nceil_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.coefficient_scoremin_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.coefficient_nceil_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.bowtie_index_archive",
          "source": [
            "#bowtie_index_archive_genome"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_Aligner_3_prime_Known.aligned_reads_only"
        }
      ],
      "sbg:x": 3434.118353006557,
      "sbg:y": 1359.6565596431012
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 3357.648100513103,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Unaligned to Known Filtered FJ",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 868.2540666724058,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.unpaired_unaligned_reads",
          "default": "raw"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.threads",
          "default": 16
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.read_sequence",
          "source": [
            "#getUnalignedReads_2.unaligned_fastq",
            "#getUnalignedReads_1.unaligned_fastq"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.output_file_suffix"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.number_of_cpu",
          "default": 1
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.input_fasta_files"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.coefficient_nceil_b",
          "default": 1
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.bowtie_index_archive",
          "source": [
            "#MACHETE_Bowtie2_Indexer_Known_Filtered_FJ.bowtie_index_archive"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.aligned_reads_only"
        }
      ],
      "sbg:x": 3357.648100513103,
      "sbg:y": 868.2540666724058,
      "scatter": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Unaligned_to_Known_Filtered_FJ.read_sequence"
    },
    {
      "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions",
      "run": {
        "sbg:validationErrors": [],
        "sbg:cmdPreview": "tar -xvf chr20_bowtie2-2.3.4.1.tar && rm -rf chr20_bowtie2-2.3.4.1.tar &&  bowtie2 -x chr20  --un mate1.fq.unpaired_unaligned.fastq.gz  --al mate1.fq.unpaired_aligned.fastq.gz  --un-conc mate1.fq.paired_unaligned.fastq  --al-conc mate1.fq.paired_aligned.fastq.gz  -i L,0,0  --n-ceil S,0,4  --score-min L,0,0  --phred33   -S ./mate1.fq.sam   && head -n 2 ./mate1.fq.sam > ./mate1.fq_sorted.sam && tail -n +3 ./mate1.fq.sam | sort -k 1 >> ./mate1.fq_sorted.sam && rm ./mate1.fq.sam  && mv mate1.fq.paired_aligned.fastq.1.gz mate1.fq.paired_aligned.1.fastq.gz && mv mate1.fq.paired_aligned.fastq.2.gz mate1.fq.paired_aligned.2.fastq.gz    && rm *bt2*",
        "sbg:toolkitVersion": "2.3.4.1",
        "sbg:id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "arguments": [
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\ncmd = \"\"\nreads1 = [];\nreads2 = [];\nu_reads = [];\nreads = [].concat($job.inputs.read_sequence)\n\nif($job.inputs.ignore_paired_end_metadata)\n{\n\tfor (var i = 0; i < reads.length; i++){\n    \tu_reads.push(reads[i].path);\n    }\n}\nelse\n{\n\n  for (var i = 0; i < reads.length; i++){\n      if (reads[i].metadata != null && reads[i].metadata.paired_end == 1){\n        reads1.push(reads[i].path);\n      }\n      else if (reads[i].metadata != null && reads[i].metadata.paired_end == 2){\n        reads2.push(reads[i].path);\n      }\n    else {\n      u_reads.push(reads[i].path);\n     }\n    }\n}\n  \nif (reads1.length > 0 & reads1.length == reads2.length){\n\tcmd = \"-1 \" + reads1.join(\",\") + \" -2 \" + reads2.join(\",\");\n}\nif (u_reads.length > 0){\n    cmd = \" -U \" + u_reads.join(\",\");\n}\n\n\nreturn cmd\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "",
            "position": 100
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  \n  function sharedStart(array){\n  var A= array.concat().sort(), \n      a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n  while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n  return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  if($job.inputs.output_file_suffix)\n  {\n  \tcommon_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n  }\n  return \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-S",
            "position": 101
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var index_prefix = $job.inputs.bowtie_index_archive.metadata.reference_genome\n  return index_prefix\n}\n",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": "-x"
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_unaligned_reads && $job.inputs.unpaired_unaligned_reads != \"None\") {\n    if ($job.inputs.unpaired_unaligned_reads == \"raw\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"gzip compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un \".concat(common_prefix, \".unpaired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.unpaired_aligned_reads && $job.inputs.unpaired_aligned_reads != \"None\") {\n    if ($job.inputs.unpaired_aligned_reads == \"raw\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"gzip compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.unpaired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al \".concat(common_prefix, \".unpaired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_unaligned_reads && $job.inputs.paired_unaligned_reads != \"None\") {\n    if ($job.inputs.paired_unaligned_reads == \"raw\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"gzip compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_unaligned_reads == \"bzip2 compressed\") {\n      return \"--un-conc \".concat(common_prefix, \".paired_unaligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  \n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n\n  common_prefix = sharedStart(path_list)\n  \n  if ($job.inputs.paired_aligned_reads && $job.inputs.paired_aligned_reads != \"None\") {\n    if ($job.inputs.paired_aligned_reads == \"raw\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"gzip compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.gz\")\n    }\n    else if ($job.inputs.paired_aligned_reads == \"bzip2 compressed\") {\n      return \"--al-conc \".concat(common_prefix, \".paired_aligned.fastq.bz2\")\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_i\n  value_list = [functions[function_type], $job.inputs.constant_i_a, $job.inputs.coefficient_i_b]\n  if (functions[function_type]) {\n    return \"-i \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_n_ceil\n  value_list = [functions[function_type], $job.inputs.constant_nceil_a, $job.inputs.coefficient_nceil_b]\n  if (functions[function_type]) {\n    return \"--n-ceil \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "prefix": ""
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  var functions = {\n    \"Constant\": \"C\",\n    \"Linear\": \"L\",\n    \"Square-root\": \"S\",\n    \"Natural log\": \"G\"\n  }\n  function_type = $job.inputs.function_score_min\n  \n  value_list = [functions[function_type], $job.inputs.constant_scoremin_a, $job.inputs.coefficient_scoremin_b]\n  if (functions[function_type]) {\n    return \"--score-min \".concat(value_list.join(\",\"))\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  meta_qual=\"\";\n  if ([].concat($job.inputs.read_sequence)[0].metadata){\n    if ([].concat($job.inputs.read_sequence)[0].metadata.quality_scale){\n      meta_qual = [].concat($job.inputs.read_sequence)[0].metadata.quality_scale\n    }\n  }\n  \n  if ($job.inputs.quality_scale == \"Phred+33\") {\n    return \"--phred33\"\n  }\n  else if ($job.inputs.quality_scale == \"Phred+64\") {\n    return \"--phred64\"\n  }\n  else if ($job.inputs.quality_scale == \"Solexa\") {\n    return \"--solexa-quals\"\n  }\n  else if ($job.inputs.quality_scale == \"Auto-detect\") {\n    if (meta_qual == \"solexa\") {\n      return \"--solexa-quals\"\n    }\n    else if (meta_qual == \"illumina13\" || meta_qual == \"illumina15\") {\n      return \"--phred64\"\n    }\n  }\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n  }\n  path_list = []\n  tmp = [].concat($job.inputs.read_sequence)\n  tmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n  common_prefix = sharedStart(path_list)\n  \n  gzip = \"gzip compressed\"\n  bzip = \"bzip2 compressed\"\n  paired_aligned = $job.inputs.paired_aligned_reads\n  paired_unaligned = $job.inputs.paired_unaligned_reads\n  aligned_first = common_prefix.concat(\".paired_aligned.fastq.1\")\n  aligned_second = common_prefix.concat(\".paired_aligned.fastq.2\")\n  aligned_first_mv = common_prefix.concat(\".paired_aligned.1.fastq\")\n  aligned_second_mv = common_prefix.concat(\".paired_aligned.2.fastq\")\n  \n  unaligned_first = common_prefix.concat(\".paired_unaligned.fastq.1\")\n  unaligned_second = common_prefix.concat(\".paired_unaligned.fastq.2\")\n  unaligned_first_mv = common_prefix.concat(\".paired_unaligned.1.fastq\")\n  unaligned_second_mv = common_prefix.concat(\".paired_unaligned.2.fastq\")\n  \n  aligned = \"\"\n  unaligned = \"\"\n  \n  if (paired_aligned && paired_aligned == gzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".gz \", aligned_first_mv, \".gz && mv \", aligned_second, \".gz \", aligned_second_mv, \".gz \") \n  }\n  else if (paired_aligned && paired_aligned == bzip) {\n    aligned = \"&& mv \".concat(aligned_first, \".bz2 \", aligned_first_mv, \".bz2 && mv \", aligned_second, \".bz2 \", aligned_second_mv, \".bz2 \")\n  }\n  if (paired_unaligned && paired_unaligned == gzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".gz \", unaligned_first_mv, \".gz && mv \", unaligned_second, \".gz \", unaligned_second_mv, \".gz\")\n  }\n  else if (paired_unaligned && paired_unaligned == bzip) {\n    unaligned = \"&& mv \".concat(unaligned_first, \".bz2 \", unaligned_first_mv, \".bz2 && mv \", unaligned_second, \".bz2 \", unaligned_second_mv, \".bz2\")\n  }\n  \n  return aligned.concat(unaligned)\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 103
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n  if($job.inputs.sort_sam)\n  {\n    function sharedStart(array){\n    var A= array.concat().sort(), \n        a1= A[0], a2= A[A.length-1], L= a1.length, i= 0;\n    while(i<L && a1.charAt(i)=== a2.charAt(i)) i++;\n    return a1.substring(0, i);\n    }\n    path_list = []\n    tmp = [].concat($job.inputs.read_sequence)\n  \ttmp.forEach(function(f){return path_list.push(f.path.replace(/\\\\/g,'/').replace( /.*\\//, '' ))})\n  \n    common_prefix = sharedStart(path_list)\n    common_prefix_sorted = common_prefix + \"_sorted\"\n    if($job.inputs.output_file_suffix)\n    {\n      common_prefix = common_prefix + \"_\" + $job.inputs.output_file_suffix\n      common_prefix_sorted = common_prefix + \"_sorted\"\n    }\n    output_name = \"./\".concat(common_prefix.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    output_name_sorted = \"./\".concat(common_prefix_sorted.replace( /\\-$|\\_$|\\.$/, '' ), \".\", \"sam\")\n    return \" && head -n 2 \" + output_name + \" > \" + output_name_sorted + \" && tail -n +3 \" + output_name + \" | sort -k 1 >> \" + output_name_sorted + \" && rm \" + output_name\n  }\n  return \"\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 102
          },
          {
            "valueFrom": {
              "class": "Expression",
              "script": "{\n\treturn \" && rm *bt2*\"\n}",
              "engine": "#cwl-js-engine"
            },
            "separate": true,
            "position": 104
          }
        ],
        "x": 2587.529642712291,
        "sbg:categories": [
          "Alignment"
        ],
        "sbg:toolAuthor": "Ben Langmead/John Hopkins University",
        "id": "milos_jordanski/spachete-salzman-collaboration/bowtie2-2-3-4-1/4",
        "temporaryFailCodes": [],
        "stdin": "",
        "sbg:modifiedOn": 1533223927,
        "sbg:createdBy": "milos_jordanski",
        "requirements": [
          {
            "engineCommand": "cwl-engine.js",
            "class": "ExpressionEngineRequirement",
            "requirements": [
              {
                "class": "DockerRequirement",
                "dockerPull": "rabix/js-engine"
              }
            ],
            "id": "#cwl-js-engine"
          }
        ],
        "sbg:appVersion": [
          "sbg:draft-2"
        ],
        "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
        "$namespaces": {
          "sbg": "https://sevenbridges.com"
        },
        "cwlVersion": "sbg:draft-2",
        "sbg:job": {
          "allocatedResources": {
            "cpu": 7,
            "mem": 6000
          },
          "inputs": {
            "allowed_mismatch_number": "0",
            "unpaired_aligned_reads": "gzip compressed",
            "alignment_mode": "Local",
            "function_i": "Linear",
            "ignore_paired_end_metadata": false,
            "bowtie_index_archive": {
              "path": "/demo/test-data/chr20_bowtie2-2.3.4.1.tar",
              "class": "File",
              "size": 0,
              "secondaryFiles": [],
              "metadata": {
                "reference_genome": "chr20"
              }
            },
            "read_gap_penalties": [
              0
            ],
            "reference_gap_penalties": [
              0
            ],
            "quality_scale": "Phred+33",
            "paired_aligned_reads": "gzip compressed",
            "number_of_cpu": 7,
            "coefficient_scoremin_b": 0,
            "input_fasta_files": true,
            "paired_unaligned_reads": "raw",
            "coefficient_i_b": 0,
            "preset_option": "Very fast",
            "constant_nceil_a": "0",
            "minimum_fragment_length": "minimum_fragment_length-string-value",
            "unpaired_unaligned_reads": "gzip compressed",
            "coefficient_nceil_b": 4,
            "disable_overlapping_alignments": false,
            "ambiguous_character_penalty": "ambiguous_character_penalty-string-value",
            "sort_sam": true,
            "output_file_suffix": "",
            "constant_i_a": 0,
            "suppress_sam_records": true,
            "read_sequence": [
              {
                "path": "/demo/test-data/mate1.fq",
                "class": "File",
                "size": 0,
                "secondaryFiles": [],
                "metadata": {
                  "quality_scale": "illumina15",
                  "file_format": "fastq",
                  "paired_end": "1"
                }
              }
            ],
            "function_score_min": "Linear",
            "disable_unpaired_alignments": false,
            "threads": 7,
            "mates_alignment_orientation": "--rf",
            "function_n_ceil": "Square-root",
            "constant_scoremin_a": "0"
          }
        },
        "sbg:revisionsInfo": [
          {
            "sbg:modifiedOn": 1520434786,
            "sbg:revision": 0,
            "sbg:revisionNotes": null,
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1520434814,
            "sbg:revision": 1,
            "sbg:revisionNotes": "revision 2 copied",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1525306849,
            "sbg:revision": 2,
            "sbg:revisionNotes": "output unaligned reads updated",
            "sbg:modifiedBy": "milos_jordanski"
          },
          {
            "sbg:modifiedOn": 1533171459,
            "sbg:revision": 3,
            "sbg:revisionNotes": "rm *bt2*",
            "sbg:modifiedBy": "jordanski.milos"
          },
          {
            "sbg:modifiedOn": 1533223927,
            "sbg:revision": 4,
            "sbg:revisionNotes": "&& instead of &",
            "sbg:modifiedBy": "jordanski.milos"
          }
        ],
        "sbg:links": [
          {
            "label": "Homepage",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/index.shtml"
          },
          {
            "label": "Download",
            "id": "http://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.2.6/"
          },
          {
            "label": "Publication",
            "id": "http://www.nature.com/nmeth/journal/v9/n4/full/nmeth.1923.html"
          },
          {
            "label": "Manual",
            "id": "http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml"
          },
          {
            "label": "Source Code",
            "id": "https://github.com/BenLangmead/bowtie2"
          }
        ],
        "label": "MACHETE Bowtie2-2.3.4.1 Aligner Known Fusions",
        "sbg:publisher": "sbg",
        "sbg:revisionNotes": "&& instead of &",
        "y": 856.3097992690234,
        "inputs": [
          {
            "label": "Unpaired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that fail to align. These reads correspond to the SAM records with the FLAGS 0x4 bit set and neither the 0x40 nor 0x80 bits set. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_unaligned_reads"
          },
          {
            "label": "Unpaired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output unpaired reads that align at least once. These reads correspond to the SAM records with the FLAGS 0x4, 0x40, and 0x80 bits unset. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "unpaired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#unpaired_aligned_reads"
          },
          {
            "label": "Trim from 5'",
            "sbg:altPrefix": "-5",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 5' (left) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim5"
            },
            "id": "#trim_from_5",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Trim from 3'",
            "sbg:altPrefix": "-3",
            "sbg:category": "Input",
            "description": "Trim given number of bases from 3' (right) end of each read before alignment.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--trim3"
            },
            "id": "#trim_from_3",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.threads)\n    {\n    \treturn \" -p \" + $job.inputs.threads\n    }\n  \telse\n    {\n    \treturn \" -p 8 \"\n    }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#threads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Suppress SQ header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress @SQ SAM header lines.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-sq"
            },
            "id": "#suppress_sq_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress SAM records for unaligned reads",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM records for reads that failed to align.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-unal"
            },
            "id": "#suppress_sam_records",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Suppress header lines",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "Suppress SAM header lines (starting with @).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-hd"
            },
            "id": "#suppress_header_lines",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "type": [
              "null",
              "boolean"
            ],
            "id": "#sort_sam",
            "sbg:stageInput": null
          },
          {
            "label": "Skip reads",
            "sbg:altPrefix": "-s",
            "sbg:category": "Input",
            "description": "Skip (i.e. do not align) the first given number of reads or pairs in the input.",
            "sbg:toolDefaultValue": "-",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--skip"
            },
            "id": "#skip_reads",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set seed",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Other",
            "description": "Set the seed for pseudo-random number generator.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--seed"
            },
            "id": "#set_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Set match bonus",
            "sbg:toolDefaultValue": "0 for \"End-to-end\" mode, 2 for \"Local\" mode",
            "sbg:category": "Scoring",
            "description": "Sets the match bonus. The given number is added to the alignment score for each position where a read character aligns to a reference character and the characters match.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ma"
            },
            "id": "#set_match_bonus",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed substring length",
            "sbg:toolDefaultValue": "22 or 20 (depending on preset type and alignment mode)",
            "sbg:category": "Alignment",
            "description": "Sets the length of the seed substrings to align during multiseed alignment. Smaller values make alignment slower but more senstive. Must be > 3 and < 32. The \"Sensitive\" preset is used by default, which sets this option to 22 in \"End-to-end\" mode and to 20 in \"Local\" mode.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-L"
            },
            "id": "#seed_substring_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Seed extension attempts",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Effort",
            "description": "Maximum number of to consecutive seed extension attempts that can \"fail\" before Bowtie2 moves on, using the alignments found so far. A seed extension \"fails\" if it does not yield a new best or a new second-best alignment.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-D"
            },
            "id": "#seed_extension_attempts",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report k alignments",
            "sbg:toolDefaultValue": "-",
            "sbg:category": "Reporting",
            "description": "By default, Bowtie2 searches for distinct, valid alignments for each read. When it finds a valid alignment, it continues looking for alignments that are nearly as good or better. The best alignment found is reported (randomly selected from among best if tied). Information about the best alignments is used to estimate mapping quality and to set SAM optional fields, such as AS:i and XS:i. When \"Report k alignments\" is specified, however, Bowtie2 behaves differently. Instead, it searches for at most <given-number> distinct, valid alignments for each read. The search terminates when it can't find more distinct valid alignments, or when it finds <given-number>, whichever happens first. All alignments found are reported in descending order by alignment score. The alignment score for a paired-end alignment equals the sum of the alignment scores of the individual mates. Each reported read or pair alignment beyond the first has the SAM 'secondary' bit (which equals 256) set in its FLAGS field. For reads that have more than <given-number> distinct, valid alignments, Bowtie2 does not gaurantee that the <given-number> alignments reported are the best possible in terms of alignment score. \"Report k alignments\" is mutually exclusive with \"Report all alignments\". Note: Bowtie 2 is not designed with large values for \"Report k alignments\" in mind, and when aligning reads to long, repetitive genomes alignment can be very, very slow.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-k"
            },
            "id": "#report_k_alignments",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Report all alignments",
            "sbg:altPrefix": "-a",
            "sbg:category": "Reporting",
            "description": "Like \"Report k alignments\" but with no upper limit on number of alignments to search for. \"Report all alignments\" is mutually exclusive with \"Report k alignments\".",
            "sbg:toolDefaultValue": "False",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--all"
            },
            "id": "#report_all_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reorder output",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Performance",
            "description": "Guarantees that output SAM records are printed in an order corresponding to the order of the reads in the original input file. Specifying \"Reorder output\" causes Bowtie2 to run somewhat slower and use somewhat more memory.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--reorder"
            },
            "id": "#reorder_output",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Reference gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the reference gap open (first value) and extend (second value) penalty, respectively. A reference gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rfg",
              "itemSeparator": ","
            },
            "id": "#reference_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Read sequence",
            "sbg:category": "Input files",
            "sbg:fileTypes": "FASTA, FASTA.GZ, FASTA.BZ2, FA.GZ, FA.BZ2, FASTQ, FA, FQ, FASTQ.GZ, FQ.GZ, FASTQ.BZ2, FQ.BZ2",
            "description": "Read sequence in FASTQ or FASTA format. COuld be also gzip'ed (extension .gz) or bzip2'ed (extension .bz2). In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2.",
            "type": [
              {
                "type": "array",
                "name": "read_sequence",
                "items": "File"
              }
            ],
            "id": "#read_sequence",
            "required": true
          },
          {
            "label": "Read gap penalties",
            "sbg:toolDefaultValue": "5,3",
            "sbg:category": "Scoring",
            "description": "Sets the read gap open (first value) and extend (second value) penalty, respectively. A read gap of length N gets a penalty of <gap-open-penalty> + N * <gap-extend-penalty>.",
            "inputBinding": {
              "separate": true,
              "sbg:cmdInclude": true,
              "prefix": "--rdg",
              "itemSeparator": ","
            },
            "id": "#read_gap_penalties",
            "type": [
              "null",
              {
                "type": "array",
                "items": "int"
              }
            ]
          },
          {
            "label": "Quality scale",
            "sbg:toolDefaultValue": "Phred+33",
            "sbg:category": "Input",
            "description": "Set quality scale.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "quality_scale",
                "symbols": [
                  "Auto-detect",
                  "Phred+33",
                  "Phred+64",
                  "Solexa"
                ]
              }
            ],
            "id": "#quality_scale"
          },
          {
            "label": "Preset",
            "sbg:toolDefaultValue": "Sensitive",
            "sbg:category": "Presets",
            "description": "Preset options for \"Seed extension attempts\" (-D), \"Max number of re-seed\" (-R), \"Allowed mismatch number\" (-N), \"Seed substring length\" (-L) and \"Interval function\" (-i) parameters. Values for these options vary depending on whether the \"Local\" or \"End-to-end\" mode is selected under \"Alignment mode\".",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  var preset_option = $job.inputs.preset_option\n  var alignment_mode = $job.inputs.alignment_mode\n  \n  var presets = {\n    \"Very fast\": \"--very-fast\",\n    \"Fast\": \"--fast\",\n    \"Sensitive\": \"--sensitive\",\n    \"Very sensitive\": \"--very-sensitive\"\n  }\n  if (alignment_mode == \"Local\" && preset_option) {\n    return presets[preset_option].concat(\"-local\")\n  }\n  else if (preset_option){\n    return presets[preset_option]\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#preset_option",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "preset_option",
                "symbols": [
                  "Very fast",
                  "Fast",
                  "Sensitive",
                  "Very sensitive"
                ]
              }
            ]
          },
          {
            "label": "Paired unaligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that fail to align concordantly. These reads correspond to the SAM records with the FLAGS 0x4 bit set and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_unaligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_unaligned_reads"
          },
          {
            "label": "Paired aligned reads",
            "sbg:toolDefaultValue": "None",
            "sbg:category": "Output",
            "description": "Output paired-end reads that align concordantly at least once. These reads correspond to the SAM records with the FLAGS 0x4 bit unset and either the 0x40 or 0x80 bit set (depending on whether it's mate #1 or #2). .1 and .2 strings are added to the filename to distinguish which file contains mate #1 and mate #2. If \"gzip compressed\" is specified, output will be gzip compressed. If \"bzip2 compressed\" is specified, output will be bzip2 compressed. Reads written in this way will appear exactly as they did in the input file, without any modification (same sequence, same name, same quality string, same quality encoding). Reads will not necessarily appear in the same order as they did in the input.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "paired_aligned_reads",
                "symbols": [
                  "raw",
                  "gzip compressed",
                  "bzip2 compressed",
                  "None"
                ]
              }
            ],
            "id": "#paired_aligned_reads"
          },
          {
            "description": "Output Suffix String.",
            "label": "Output Suffix String",
            "type": [
              "null",
              "string"
            ],
            "id": "#output_file_suffix"
          },
          {
            "label": "Omit SEQ and QUAL",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Output",
            "description": "When printing secondary alignments, Bowtie 2 by default will write out the SEQ and QUAL strings. Specifying this option causes Bowtie 2 to print an asterisk ('*') in those fields instead.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--omit-sec-seq"
            },
            "id": "#omit_seq_and_qual",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Number of cpu",
            "sbg:toolDefaultValue": "8",
            "description": "Number of cpu.",
            "type": [
              "null",
              "int"
            ],
            "id": "#number_of_cpu",
            "sbg:stageInput": null
          },
          {
            "label": "Non deterministic",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Other",
            "description": "Normally, Bowtie2 re-initializes its pseudo-random generator for each read. It seeds the generator with a number derived from (a) the read name, (b) the nucleotide sequence, (c) the quality sequence, (d) the value of the \"Set seed\" option. This means that if two reads are identical (same name, same nucleotides, same qualities) Bowtie2 will find and report the same alignment(s) for both, even if there was ambiguity. When \"Non deterministic\" is specified, Bowtie2 re-initializes its pseudo-random generator for each read using the current time. This means that Bowtie2 will not necessarily report the same alignment for two identical reads. This is counter-intuitive for some users, but might be more appropriate in situations where the input consists of many identical reads.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--non-deterministic"
            },
            "id": "#non_deterministic",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Minimum fragment length",
            "sbg:altPrefix": "-I",
            "sbg:category": "Paired-end",
            "description": "The minimum fragment length for valid paired-end alignments. E.g. if 60 is specified for \"Minimum fragment length\" (-I) and a paired-end alignment consists of two 20-bp alignments in the appropriate orientation with a 20-bp gap between them, that alignment is considered valid (as long as \"Maximum fragment length\" (-X) is also satisfied). A 19-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Minimum fragment length\" constraint is applied with respect to the untrimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "0",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--minins"
            },
            "id": "#minimum_fragment_length",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Maximum mismatch penalty",
            "sbg:toolDefaultValue": "6",
            "sbg:category": "Scoring",
            "description": "Sets the maximum penalty for mismatch. Lower quality = lower penalty.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--mp"
            },
            "id": "#maximum_mismatch_penalty",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Maximum fragment length",
            "sbg:altPrefix": "-X",
            "sbg:category": "Paired-end",
            "description": "The maximum fragment length for valid paired-end alignments. E.g. if \"Maximum fragment length\" (-X) 100 is specified and a paired-end alignment consists of two 20-bp alignments in the proper orientation with a 60-bp gap between them, that alignment is considered valid (as long as \"Minimum fragment length\" (-I) is also satisfied). A 61-bp gap would not be valid in that case. If trimming options -3 or -5 are also used, the \"Maximum fragment length\" constraint is applied with respect to the untrimmed mates, not the trimmed mates. The larger the difference between \"Minimum fragment length\" and \"Maximum fragment length\", the slower Bowtie2 will run. This is because larger differences bewteen those two require that Bowtie2 scan a larger window to determine if a concordant alignment exists. For typical fragment length ranges (200 to 400 nucleotides), Bowtie2 is very efficient.",
            "sbg:toolDefaultValue": "500",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--maxins"
            },
            "id": "#maximum_fragment_length",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Max number of re-seed",
            "sbg:toolDefaultValue": "2",
            "sbg:category": "Effort",
            "description": "Given number is the maximum number of times Bowtie2 will 're-seed' reads with repetitive seeds. When 're-seeding', Bowtie2 simply chooses a new set of reads (same length, same number of mismatches allowed) at different offsets and searches for more alignments. A read is considered to have repetitive seeds if the total number of seed hits divided by the number of seeds that aligned at least once is greater than 300.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-R"
            },
            "id": "#max_number_of_re_seed",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Mates alignment orientation",
            "sbg:toolDefaultValue": "--fr",
            "sbg:category": "Paired-end",
            "description": "The upstream/downstream mate orientations for a valid paired-end alignment against the forward reference strand. E.g., if --fr is specified and there is a candidate paired-end alignment where mate 1 appears upstream of the reverse complement of mate 2 and the fragment length constraints (\"Minimum fragment length\" (-I) and \"Maximum fragment length\" (-X)) are met, that alignment is valid. Also, if mate 2 appears upstream of the reverse complement of mate 1 and all other constraints are met, that too is valid. --rf likewise requires that an upstream mate1 be reverse-complemented and a downstream mate2 be forward-oriented. --ff requires both an upstream mate 1 and a downstream mate 2 to be forward-oriented. Default orientation --fr is appropriate for Illumina's Paired-end Sequencing Assay.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#mates_alignment_orientation",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "mates_alignment_orientation",
                "symbols": [
                  "--fr",
                  "--rf",
                  "--ff"
                ]
              }
            ]
          },
          {
            "label": "Integer qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Quality values are represented in the read input file as space-separated ASCII integers, e.g., 40 40 30 40..., rather than ASCII characters, e.g., II?I....",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--int-quals"
            },
            "id": "#integer_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-f"
            },
            "id": "#input_fasta_files",
            "type": [
              "null",
              "boolean"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Ignore qualities",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "When calculating a mismatch penalty, always consider the quality value at the mismatched position to be the highest possible, regardless of the actual value. I.e. treat all quality values as 30 on Phred scale. This is also the default behavior when the input doesn't specify quality values (e.g. when processing .fasta reads).",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--ignore-quals"
            },
            "id": "#ignore_qualities",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Ignore paired_end metadata",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Input",
            "description": "Set this option to True in order to process single_end reads which have paired_end metadata set",
            "type": [
              "null",
              "boolean"
            ],
            "id": "#ignore_paired_end_metadata"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Natural log or Linear (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a function type F in function governing the minimum alignment score needed for an alignment to be considered \"valid\" (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to \"Natural log\" or \"Linear\", Constant A to 20 or -0.6 and Coefficient B to 8 or -0.6 depending on the \"Alignment mode\": \"End-to-end\" or \"Local\" respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_score_min",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_score_min"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Linear",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a function type F in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_n_ceil",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_n_ceil"
          },
          {
            "label": "Function type",
            "sbg:toolDefaultValue": "Square-root",
            "sbg:category": "Interval function",
            "description": "Sets a function type F in function f governing the interval between seed substrings, to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. By default, function F is set to 'Square-root', Constant A to 1 and Coefficient B to 1.15 or 0.75 for \"End-to-end\" and \"Local\" mode respectively.",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "function_i",
                "symbols": [
                  "Constant",
                  "Linear",
                  "Square-root",
                  "Natural log"
                ]
              }
            ],
            "id": "#function_i"
          },
          {
            "label": "Dynamic padding",
            "sbg:toolDefaultValue": "15",
            "sbg:category": "Alignment",
            "description": "\"Pads\" dynamic programming problems by the given number of columns on either side to allow gaps.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--dpad"
            },
            "id": "#dynamic_padding",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Don't align reverse complement",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads against the reverse-complement (Crick) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--norc"
            },
            "id": "#dont_align_reverse_complement",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Don't align forward",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "If this option is specified, Bowtie2 will not attempt to align unpaired reads to the forward (Watson) reference strand. In paired-end mode, \"Don't align forward\" and \"Don't align reverse complement\" pertain to the fragments; i.e. specifying \"Don't align forward\" causes Bowtie2 to explore only those paired-end configurations corresponding to fragments from the reverse-complement (Crick) strand. Default: both strands enabled.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--nofw"
            },
            "id": "#dont_align_forward",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disallow gaps",
            "sbg:toolDefaultValue": "4",
            "sbg:category": "Alignment",
            "description": "Disallow gaps within the given number of positions of the beginning or end of the read.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--gbar"
            },
            "id": "#disallow_gaps",
            "type": [
              "null",
              "int"
            ]
          },
          {
            "label": "Disable unpaired alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, when Bowtie2 cannot find a concordant or discordant alignment for a pair, it then tries to find alignments for the individual mates. This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-mixed"
            },
            "id": "#disable_unpaired_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable overlapping alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment overlaps the other at all, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-overlap"
            },
            "id": "#disable_overlapping_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable dovetail alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If the mates \"dovetail\", that is if one mate alignment extends past the beginning of the other such that the wrong mate begins upstream, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-dovetail"
            },
            "id": "#disable_dovetail_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable discordant alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "By default, Bowtie2 looks for discordant alignments if it cannot find any concordant alignments. A discordant alignment is an alignment where both mates align uniquely, but that does not satisfy the paired-end constraints (--fr/--rf/--ff, -I, -X). This option disables that behavior.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-discordant"
            },
            "id": "#disable_discordant_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable containing alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Paired-end",
            "description": "If one mate alignment contains the other, consider that to be non-concordant.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-contain"
            },
            "id": "#disable_containing_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Disable 1 mismatch alignments",
            "sbg:toolDefaultValue": "False",
            "sbg:category": "Alignment",
            "description": "By default, Bowtie2 will attempt to find either an exact or a 1-mismatch end-to-end alignment for the read before trying the multiseed heuristic. Such alignments can be found very quickly, and many short read alignments have exact or near-exact end-to-end alignments. However, this can lead to unexpected alignments when the user also sets options governing the multiseed heuristic, like \"Seed substring length\" (-L) and \"Allowed mismatch number\" (-N). For instance, if the user specifies 0 for \"Allowed mismatch number\" and \"Seed substring length\" equal to the length of the read, the user will be surprised to find 1-mismatch alignments reported. This option prevents Bowtie2 from searching for 1-mismatch end-to-end alignments before using the multiseed heuristic, which leads to the expected behavior when combined with options such as \"Seed substring length\" and \"Allowed mismatch number\". This comes at the expense of speed.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--no-1mm-upfront"
            },
            "id": "#disable_1_mismatch_alignments",
            "type": [
              "null",
              "boolean"
            ]
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "20 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a constant A in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 20 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_scoremin_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a constant A in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "string"
            ],
            "id": "#constant_nceil_a",
            "sbg:stageInput": null
          },
          {
            "label": "Constant A",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Interval function",
            "description": "Sets a constant A in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length.",
            "type": [
              "null",
              "float"
            ],
            "id": "#constant_i_a"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "8 or -0.6 (depending on \"Alignment mode\")",
            "sbg:category": "Alignment score function",
            "description": "Sets a coefficient B in function governing the minimum alignment score needed for an alignment to be considered 'valid' (i.e. good enough to report). This is a function of read length. The minimum-score function f is f(x) = A + B * F(x), where x is the read length. Default: 8 in \"End-to-end\" mode and -0.6 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_scoremin_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "0.15",
            "sbg:category": "Ambiguous chars function",
            "description": "Sets a coefficient B in function governing the maximum number of ambiguous characters (usually Ns and/or .s) allowed in a read as a function of read length. The N-ceiling function f is f(x) = A + B * F(x), where x is the read length. Reads exceeding this ceiling are filtered out.",
            "type": [
              "null",
              "int"
            ],
            "id": "#coefficient_nceil_b"
          },
          {
            "label": "Coefficient B",
            "sbg:toolDefaultValue": "1.15 or 0.75 (depending on \"Alignment mode\")",
            "sbg:category": "Interval function",
            "description": "Sets a coefficient B in function governing the interval between seed substrings to use during multiseed alignment. The interval function f is f(x) = A + B * F(x), where x is the read length. Default: 1.15 in \"End-to-end\" mode and 0.75 in \"Local\" mode.",
            "type": [
              "null",
              "float"
            ],
            "id": "#coefficient_i_b"
          },
          {
            "label": "Bowtie index archive",
            "sbg:category": "Input files",
            "sbg:fileTypes": "TAR",
            "description": "Archive file produced by Bowtie2 Indexer.",
            "type": [
              "File"
            ],
            "id": "#bowtie_index_archive",
            "sbg:stageInput": "link",
            "required": true
          },
          {
            "label": "Ambiguous character penalty",
            "sbg:toolDefaultValue": "1",
            "sbg:category": "Scoring",
            "description": "Sets penalty for positions where the read, reference, or both, contain an ambiguous character such as N.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--np"
            },
            "id": "#ambiguous_character_penalty",
            "type": [
              "null",
              "string"
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Allowed mismatch number",
            "sbg:toolDefaultValue": "0",
            "sbg:category": "Alignment",
            "description": "Sets the number of mismatches to allowed in a seed alignment during multiseed alignment. Can be set to 0 or 1. Setting this higher makes alignment slower (often much slower) but increases sensitivity.",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "-N"
            },
            "id": "#allowed_mismatch_number",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "allowed_mismatch_number",
                "symbols": [
                  "0",
                  "1"
                ]
              }
            ],
            "sbg:stageInput": null
          },
          {
            "label": "Alignment mode",
            "sbg:toolDefaultValue": "End-to-end",
            "sbg:category": "Alignment",
            "description": "Alignment mode. End-to-end: entire read must align; no clipping. Local: local alignment; ends might be soft clipped.",
            "inputBinding": {
              "valueFrom": {
                "class": "Expression",
                "script": "{\n  if ($job.inputs.alignment_mode == \"Local\") {\n    return \"--local\"\n  }\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:cmdInclude": true,
              "separate": true
            },
            "id": "#alignment_mode",
            "type": [
              "null",
              {
                "type": "enum",
                "name": "alignment_mode",
                "symbols": [
                  "End-to-end",
                  "Local"
                ]
              }
            ]
          },
          {
            "label": "Align next n reads",
            "sbg:altPrefix": "-u",
            "sbg:category": "Input",
            "description": "Align the first given number of reads or read pairs from the input (after the <int> reads or pairs have been skipped with \"Skip reads\"), then stop.",
            "sbg:toolDefaultValue": "No limit",
            "inputBinding": {
              "sbg:cmdInclude": true,
              "separate": true,
              "prefix": "--upto"
            },
            "id": "#align_next_n_reads",
            "type": [
              "null",
              "int"
            ]
          }
        ],
        "description": "Bowtie 2 is an ultrafast and memory-efficient tool for aligning sequencing reads to long reference sequences. It is particularly good at aligning reads of about 50 up to 100s or 1,000s of characters to relatively long (e.g. mammalian) genomes. Bowtie 2 indexes the genome with an [FM Index](http://portal.acm.org/citation.cfm?id=796543) (based on the [Burrows-Wheeler Transform](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform) or [BWT](http://en.wikipedia.org/wiki/Burrows-Wheeler_transform)) to keep its memory footprint small: for the human genome, its memory footprint is typically around 3.2 gigabytes of RAM. In order to create needed index files, you should run [Bowtie2 Indexer](https://igor.sbgenomics.com/public/apps#tool/admin/sbg-public-data/bowtie2-indexer), which produces archived index files (containing 6 files with suffixes .1.bt2, .2.bt2, .3.bt2, .4.bt2, .rev.1.bt2, and .rev.2.bt2).\n\nBowtie 2 supports gapped, local, and paired-end alignment modes. Bowtie 2 outputs alignments in SAM format, enabling interoperation with a large number of other tools (e.g. [SAMtools](http://samtools.sourceforge.net/), [GATK](http://www.broadinstitute.org/gsa/wiki/index.php/The_Genome_Analysis_Toolkit)) that use SAM.\n\n###Common issues###\nNo issues have been reported.\n\n**Q&A:**\n\n***Q: What should I do if I already have Bowtie2 index files, not archived as tar bundle?***\n\n***A***: You can provide your *.bt2 files to [SBG Compressor](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/sbg-compressor-1-0/) app from our public apps and set \"TAR\" as your output format. After the task is finished, **you should assign common prefix of the index files to the `Reference genome` metadata field** and your TAR is ready for use.\n\n***Example:***\nIndexed files: chr20.1.bt2, chr20.2.bt2, chr20.3.bt2, chr20.4.bt2, chr20.rev.1.bt2, chr20.rev.2.bt2\n\nMetadata - `Reference genome`: **chr20**\n\n__Important note: In case of paired-end alignment it is crucial to set metadata 'paired-end' field to 1/2. Sequences specified as mate 1s must correspond file-for-file and read-for-read with those specified for mate 2s. Reads may be a mix of different lengths. In case of unpaired reads, the same metadata field should be set to '-'. Only one type of alignment can be performed at once, so all specified reads should be either paired or unpaired.__",
        "class": "CommandLineTool",
        "sbg:license": "GNU General Public License v3.0 only",
        "sbg:modifiedBy": "jordanski.milos",
        "outputs": [
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*_unaligned*fastq",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Unaligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that failed to align.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#unaligned_reads_only"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": "*.sam",
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Result SAM file",
            "sbg:fileTypes": "SAM",
            "description": "SAM file containing the results of the alignment. It contains both aligned and unaligned reads.",
            "type": [
              "null",
              "File"
            ],
            "id": "#result_sam_file"
          },
          {
            "outputBinding": {
              "sbg:inheritMetadataFrom": "#read_sequence",
              "glob": {
                "class": "Expression",
                "script": "{\n\tif($job.inputs.sort_sam)\n    {\n    \treturn \"*_sorted*\"\n    }\n  \treturn \"*_aligned*\"\n}",
                "engine": "#cwl-js-engine"
              },
              "sbg:metadata": {
                "__inherit__": "fasta_reference"
              },
              "streamable": false
            },
            "label": "Aligned reads only",
            "sbg:fileTypes": "FASTQ, FASTQ.GZ, FASTQ.BZ2",
            "description": "FASTQ file with reads that align at least once.",
            "type": [
              "null",
              {
                "type": "array",
                "items": "File"
              }
            ],
            "id": "#aligned_reads_only"
          }
        ],
        "sbg:image_url": null,
        "sbg:contributors": [
          "milos_jordanski",
          "jordanski.milos"
        ],
        "stdout": "",
        "successCodes": [],
        "baseCommand": [
          {
            "class": "Expression",
            "script": "{\n  var archive_name = $job.inputs.bowtie_index_archive.path.split(\"/\").pop()\n  return \"tar -xvf \".concat(archive_name, \" && rm -rf \", archive_name, \" && \")\n}",
            "engine": "#cwl-js-engine"
          },
          "bowtie2"
        ],
        "sbg:sbgMaintained": false,
        "sbg:projectName": "SPACHETE Salzman Collaboration ",
        "sbg:latestRevision": 4,
        "sbg:revision": 4,
        "sbg:toolkit": "Bowtie2",
        "hints": [
          {
            "class": "DockerRequirement",
            "dockerImageId": "029d3a264215",
            "dockerPull": "images.sbgenomics.com/milos_jordanski/bowtie2:2.3.4.1"
          },
          {
            "class": "sbg:MemRequirement",
            "value": 6000
          },
          {
            "class": "sbg:CPURequirement",
            "value": {
              "class": "Expression",
              "script": "{\n\tif($job.inputs.number_of_cpu)\n      return $job.inputs.number_of_cpu\n    return 8\n}",
              "engine": "#cwl-js-engine"
            }
          }
        ],
        "sbg:createdOn": 1520434786
      },
      "inputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.unpaired_unaligned_reads",
          "default": "raw"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.unpaired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.trim_from_5"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.trim_from_3"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.threads",
          "default": 16
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.suppress_sq_header_lines",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.suppress_sam_records",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.suppress_header_lines"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.sort_sam"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.skip_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.set_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.set_match_bonus"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.seed_substring_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.seed_extension_attempts"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.report_k_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.report_all_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.reorder_output"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.reference_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.read_sequence",
          "source": [
            "#getUnalignedReads_2.unaligned_fastq",
            "#getUnalignedReads_1.unaligned_fastq"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.read_gap_penalties",
          "default": [
            50,
            50
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.quality_scale"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.preset_option"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.paired_unaligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.paired_aligned_reads"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.output_file_suffix"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.omit_seq_and_qual"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.number_of_cpu"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.non_deterministic"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.minimum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.maximum_mismatch_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.maximum_fragment_length"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.max_number_of_re_seed"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.mates_alignment_orientation"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.integer_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.input_fasta_files"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.ignore_qualities"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.ignore_paired_end_metadata",
          "default": true
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.function_score_min",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.function_n_ceil",
          "default": "Linear"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.function_i"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.dynamic_padding"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.dont_align_reverse_complement"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.dont_align_forward"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.disallow_gaps"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.disable_unpaired_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.disable_overlapping_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.disable_dovetail_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.disable_discordant_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.disable_containing_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.disable_1_mismatch_alignments"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.constant_scoremin_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.constant_nceil_a",
          "default": "0"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.constant_i_a"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.coefficient_scoremin_b",
          "default": -0.24
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.coefficient_nceil_b",
          "default": 1
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.coefficient_i_b"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.bowtie_index_archive",
          "source": [
            "#MACHETE_Known_Fusions"
          ]
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.ambiguous_character_penalty"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.allowed_mismatch_number"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.alignment_mode"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.align_next_n_reads"
        }
      ],
      "outputs": [
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.unaligned_reads_only"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.result_sam_file"
        },
        {
          "id": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.aligned_reads_only"
        }
      ],
      "sbg:x": 2587.529642712291,
      "sbg:y": 856.3097992690234,
      "scatter": "#MACHETE_Bowtie2_2_3_4_1_Aligner_Known_Fusions.read_sequence"
    }
  ],
  "requirements": [],
  "inputs": [
    {
      "label": "fastq_files",
      "sbg:x": 136,
      "sbg:fileTypes": "FQ,FASTQ,FQ.GZ,FASTQ.GZ",
      "type": [
        "null",
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:y": -72,
      "id": "#fastq_files"
    },
    {
      "label": "pickle_tar",
      "sbg:x": 1607,
      "sbg:fileTypes": "TAR.GZ, tar.gz",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 626,
      "id": "#pickle_tar"
    },
    {
      "label": "MACHETE Known Fusions",
      "sbg:includeInPorts": true,
      "sbg:x": 2154,
      "sbg:fileTypes": "TAR",
      "type": [
        "File"
      ],
      "sbg:y": 707,
      "id": "#MACHETE_Known_Fusions"
    },
    {
      "label": "bowtie_index_archive_genome",
      "sbg:includeInPorts": true,
      "sbg:x": 138,
      "sbg:fileTypes": "TAR",
      "type": [
        "File"
      ],
      "sbg:y": 69,
      "id": "#bowtie_index_archive_genome"
    },
    {
      "label": "bowtie_index_archive_ribosomal",
      "sbg:includeInPorts": true,
      "sbg:x": 138,
      "sbg:fileTypes": "TAR",
      "type": [
        "File"
      ],
      "sbg:y": 196,
      "id": "#bowtie_index_archive_ribosomal"
    },
    {
      "label": "bowtie_index_archive_regular_junctions",
      "sbg:includeInPorts": true,
      "sbg:x": 141,
      "sbg:fileTypes": "TAR",
      "type": [
        "File"
      ],
      "sbg:y": 342,
      "id": "#bowtie_index_archive_regular_junctions"
    },
    {
      "label": "bowtie_index_archive_scrambled_junctions",
      "sbg:includeInPorts": true,
      "sbg:x": 138,
      "sbg:fileTypes": "TAR",
      "type": [
        "File"
      ],
      "sbg:y": 468,
      "id": "#bowtie_index_archive_scrambled_junctions"
    },
    {
      "label": "bowtie_index_archive_transcriptome",
      "sbg:includeInPorts": true,
      "sbg:x": 3331.764985470629,
      "sbg:fileTypes": "TAR",
      "type": [
        "File"
      ],
      "sbg:y": 1096.7059129827164,
      "id": "#bowtie_index_archive_transcriptome"
    },
    {
      "label": "bowtie_index_archive_regular_indels",
      "sbg:includeInPorts": true,
      "sbg:x": 4589.88248095793,
      "sbg:fileTypes": "TAR",
      "type": [
        {
          "type": "array",
          "items": "File"
        }
      ],
      "sbg:y": 1228.5294377102573,
      "id": "#bowtie_index_archive_regular_indels"
    },
    {
      "label": "known_fusions",
      "sbg:x": 2160.353001706741,
      "sbg:fileTypes": "PICKLE, pickle",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 901.9411997234122,
      "id": "#known_fusions"
    },
    {
      "label": "Size of window",
      "sbg:includeInPorts": false,
      "required": false,
      "sbg:suggestedValue": 10000,
      "description": "Size of window, where if read occurs at X, then window starts at X-w and ends at X+w",
      "type": [
        "null",
        "int"
      ],
      "id": "#window"
    },
    {
      "label": "Minimal distance for paired end reads to be considered as discordant",
      "sbg:includeInPorts": false,
      "required": false,
      "sbg:suggestedValue": 100000,
      "description": "looking for PE > distance base pairs apart (default 100K)",
      "type": [
        "null",
        "int"
      ],
      "id": "#discordant_distance",
      "sbg:stageInput": null
    },
    {
      "label": "skip_trimming",
      "sbg:includeInPorts": false,
      "sbg:x": 123,
      "type": [
        "null",
        "boolean"
      ],
      "sbg:y": 77,
      "id": "#skip_trimming",
      "required": false
    }
  ],
  "outputs": [
    {
      "label": "circ_junc_probs",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 1409,
      "sbg:fileTypes": "TXT",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 429,
      "id": "#circ_junc_probs",
      "source": [
        "#KNIFE_GLM_model.circ_junc_probs"
      ]
    },
    {
      "label": "MACHETE_appended_naive_report",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 5946.000167341795,
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 349.8823670779958,
      "id": "#appended_naive_report",
      "source": [
        "#MACHETE_AppendNaiveReptParallel.appended_naive_report"
      ]
    },
    {
      "label": "MACHETE_class_id",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 1142.3529731526096,
      "sbg:fileTypes": "TXT",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -77.64707692024251,
      "id": "#MACHETE_class_id",
      "source": [
        "#KNIFE_filterFDR.output"
      ]
    },
    {
      "label": "MACHETE_Knife_GLM",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 1403,
      "sbg:fileTypes": "TXT",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": -142,
      "id": "#MACHETE_Knife_GLM",
      "source": [
        "#KNIFE_GLM_model.linear_junc_probs"
      ]
    },
    {
      "label": "MACHETE_Genome_FJ",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 3800.0000629359038,
      "sbg:fileTypes": "SAM",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 84.7058802211985,
      "id": "#MACHETE_Genome_FJ",
      "source": [
        "#MACHETE_Bowtie2_2_3_4_1_Genome_FJ.result_sam_file"
      ]
    },
    {
      "label": "MACHETE_Transcriptome_FJ",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 3798.823591786684,
      "sbg:fileTypes": "SAM",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 209.41176891656892,
      "id": "#MACHETE_Transcriptome_FJ",
      "source": [
        "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ.result_sam_file"
      ]
    },
    {
      "label": "MACHETE_Regular_FJ",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 3794.1176242960332,
      "sbg:fileTypes": "SAM",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 471.76475182371667,
      "id": "#MACHETE_Regular_FJ",
      "source": [
        "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ.result_sam_file"
      ]
    },
    {
      "label": "MACHETE_Scrambled_FJ",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 3796.470852729776,
      "sbg:fileTypes": "SAM",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 589.4118532095009,
      "id": "#MACHETE_Scrambled_FJ",
      "source": [
        "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ.result_sam_file"
      ]
    },
    {
      "label": "MACHETE_fusion_w_anomaly_and_indel_juncp_out_lef_join",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 5685.882525163539,
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 480.00001933747956,
      "id": "#MACHETE_fusion_w_anomaly_and_indel_juncp_out_lef_join",
      "source": [
        "#MACHETE_GLM_script_UseIndel.fusion_w_anomaly_and_indel_juncp_out_lef_join"
      ]
    },
    {
      "label": "MACHETE_Genome_FJ_Known",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 3799.9998983231326,
      "sbg:fileTypes": "SAM",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 680.0000067516179,
      "id": "#MACHETE_Genome_FJ_Known",
      "source": [
        "#MACHETE_Bowtie2_2_3_4_1_Aligner_Genome_FJ_Known.result_sam_file"
      ]
    },
    {
      "label": "MACHETE_Transcriptome_FJ_Known",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 3804.7064481029183,
      "sbg:fileTypes": "SAM",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 804.7058823925396,
      "id": "#MACHETE_Transcriptome_FJ_Known",
      "source": [
        "#MACHETE_Bowtie2_2_3_4_1_Aligner_Transcriptome_FJ_Known.result_sam_file"
      ]
    },
    {
      "label": "MACHETE_Regular_FJ_Known",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 3808.23575854055,
      "sbg:fileTypes": "SAM",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 942.3530084220608,
      "id": "#MACHETE_Regular_FJ_Known",
      "source": [
        "#MACHETE_Bowtie2_2_3_4_1_Aligner_Regular_Junction_FJ_Known.result_sam_file"
      ]
    },
    {
      "label": "MACHETE_Scrambled_FJ_Known",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 3814.1180543668634,
      "sbg:fileTypes": "SAM",
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 1069.4118173922643,
      "id": "#MACHETE_Scrambled_FJ_Known",
      "source": [
        "#MACHETE_Bowtie2_2_3_4_1_Aligner_Scrambled_Junction_FJ_Known.result_sam_file"
      ]
    },
    {
      "label": "MACHETE_Known_fusion_w_anomaly_and_indel_juncp_out_lef_join",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 5298.823533602648,
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 974.1177103841193,
      "id": "#MACHETE_Known_fusion_w_anomaly_and_indel_juncp_out_lef_join",
      "source": [
        "#GLM_script_UseIndel_MACHETE_Known.fusion_w_anomaly_and_indel_juncp_out_lef_join"
      ]
    },
    {
      "label": "appended_naive_report_machete_parallel_known",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 5542.3533838265585,
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 847.0588974870216,
      "id": "#appended_naive_report_machete_parallel_known",
      "source": [
        "#MACHETE_AppendNaiveReptParallel_Known.appended_naive_report"
      ]
    },
    {
      "label": "MACHETE_class_input",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 3543.5296561429286,
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 498.8235462413116,
      "id": "#MACHETE_class_input",
      "source": [
        "#MACHETE_FarJuncNaiveReport.IDs"
      ]
    },
    {
      "label": "MACHETE_Known_class_input",
      "sbg:includeInPorts": true,
      "required": false,
      "sbg:x": 3596.4705705477672,
      "type": [
        "null",
        "File"
      ],
      "sbg:y": 1008.2353680884562,
      "id": "#MACHETE_Known_class_input",
      "source": [
        "#MACHETE_FarJuncNaiveReport_Known.IDs"
      ]
    }
  ],
  "sbg:canvas_y": -522,
  "sbg:revisionsInfo": [
    {
      "sbg:modifiedOn": 1527712866,
      "sbg:revision": 0,
      "sbg:revisionNotes": null,
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1527713474,
      "sbg:revision": 1,
      "sbg:revisionNotes": "rev: 38 copied, SPORK removed",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1527722561,
      "sbg:revision": 2,
      "sbg:revisionNotes": "Bowtie2 Aligner Scrambled Junctions PE Known",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1527746842,
      "sbg:revision": 3,
      "sbg:revisionNotes": "skip_trimming exposed",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1527807597,
      "sbg:revision": 4,
      "sbg:revisionNotes": "MACHETE_AppendNaiveReptParallel updated, makeJunctions_new updated",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1527808912,
      "sbg:revision": 5,
      "sbg:revisionNotes": "MACHETE_AppendNaiveRept Parallel updated",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1531976427,
      "sbg:revision": 6,
      "sbg:revisionNotes": "update AppendedNaiveReport to version 18",
      "sbg:modifiedBy": "roozbehdn"
    },
    {
      "sbg:modifiedOn": 1532032356,
      "sbg:revision": 7,
      "sbg:revisionNotes": "the same as revision 6",
      "sbg:modifiedBy": "roozbehdn"
    },
    {
      "sbg:modifiedOn": 1532037526,
      "sbg:revision": 8,
      "sbg:revisionNotes": "AppendedReport updated",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1532043616,
      "sbg:revision": 9,
      "sbg:revisionNotes": "version 21 AppendedNaiveReport script",
      "sbg:modifiedBy": "roozbehdn"
    },
    {
      "sbg:modifiedOn": 1532045399,
      "sbg:revision": 10,
      "sbg:revisionNotes": "AppendNaiveReptParallel updated: typo fixed",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1532288175,
      "sbg:revision": 11,
      "sbg:revisionNotes": "some output nodes removed",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1532516540,
      "sbg:revision": 12,
      "sbg:revisionNotes": "junction_length added to all scripts",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1532538568,
      "sbg:revision": 13,
      "sbg:revisionNotes": "makeJunctions_new: () fixed",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1532538628,
      "sbg:revision": 14,
      "sbg:revisionNotes": "makeJunctions_new: () fixed",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1532558979,
      "sbg:revision": 15,
      "sbg:revisionNotes": "GetBasesAroundJunctionPoint updated",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1532610673,
      "sbg:revision": 16,
      "sbg:revisionNotes": "GetBasesAroundJunctionPoint junction_length connected",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1532769030,
      "sbg:revision": 17,
      "sbg:revisionNotes": "MACHETE PEfinder: windows and discordant_distance exposed",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1532769779,
      "sbg:revision": 18,
      "sbg:revisionNotes": "MACHETE PEfinder: windows and discordant_distance exposed",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1532820170,
      "sbg:revision": 19,
      "sbg:revisionNotes": "junction_length fixed to 300 for known",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1532820477,
      "sbg:revision": 20,
      "sbg:revisionNotes": "Bowtie2 Aligner 5 prime: genome input set",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1533221934,
      "sbg:revision": 21,
      "sbg:revisionNotes": "Bowtie updated to remove bt2 files",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1533224549,
      "sbg:revision": 22,
      "sbg:revisionNotes": "Bowtie2 Aligner && instead of &",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1533224655,
      "sbg:revision": 23,
      "sbg:revisionNotes": "regular_junction index set as input",
      "sbg:modifiedBy": "jordanski.milos"
    },
    {
      "sbg:modifiedOn": 1533333483,
      "sbg:revision": 24,
      "sbg:revisionNotes": "junction_length removed and set 300",
      "sbg:modifiedBy": "jordanski.milos"
    }
  ],
  "sbg:revisionNotes": "junction_length removed and set 300",
  "sbg:image_url": null,
  "sbg:createdOn": 1527712866,
  "sbg:publisher": "sbg",
  "sbg:validationErrors": [],
  "sbg:id": "milos_jordanski/spachete-salzman-collaboration/knife-and-machete-known-fusions-parallel/24",
  "sbg:sbgMaintained": false,
  "sbg:canvas_zoom": 0.6499999999999997,
  "sbg:modifiedOn": 1533333483,
  "sbg:createdBy": "jordanski.milos",
  "sbg:appVersion": [
    "sbg:draft-2"
  ],
  "sbg:project": "milos_jordanski/spachete-salzman-collaboration",
  "sbg:canvas_x": -1471,
  "sbg:modifiedBy": "jordanski.milos",
  "sbg:contributors": [
    "jordanski.milos",
    "roozbehdn"
  ],
  "sbg:revision": 24,
  "sbg:projectName": "SPACHETE Salzman Collaboration ",
  "sbg:latestRevision": 24,
  "id": "milos_jordanski/spachete-salzman-collaboration/knife-and-machete-known-fusions-parallel/24",
  "label": "Knife and MACHETE Known fusions parallel",
  "description": "",
  "hints": [
    {
      "class": "sbg:AWSInstanceType",
      "value": "r4.8xlarge;ebs-gp2;1024"
    }
  ]
}
